<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html" charset="utf-8">
    <title>Intel OSPRay Documentation</title>
    <link rel="stylesheet" type="text/css" media="screen" href="stylesheet.css">
    <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
div.sourceCode { overflow-x: initial; }
    </style>
  </head>

  <body>
    <div id="header">
      <div id="header-github">
        <a id="forkme-banner" href="https://github.com/ospray/OSPRay">View on GitHub</a>
      </div>
      <div id="header-title">
        Intel<sup>®</sup> OSPRay
              <div id="header-subtitle">
        A Ray Tracing Based Rendering Engine for High-Fidelity Visualization
      </div>
      </div>

      <div id="header-navbar">
        <ul>
          <li><a href="index.html">Overview</a></li>
	  <li><a href="news.html">News</a></li>
	  <li><a href="demos.html">Demos</a></li>
	  <li id="selected"><a href="documentation.html">Documentation</a></li>
	  <li><a href="gallery.html">Gallery</a></li>
	  <li><a href="downloads.html">Downloads</a></li>
	  <li><a href="https://github.com/ospray/OSPRay/wiki">Wiki</a></li>
	  <li><a href="https://github.com/ospray/OSPRay/issues">Bugs/Issues</a></li>
	  <li><a href="related_projects.html">Related Projects</a></li>
	</ul>
      </div>
      <div id="header-spacing"></div>
    </div>

    <div id="content-wrap">
      <div id="content">

<h1 id="documentation">Documentation</h1>
<p>The following <a href="http://www.sdvis.org/ospray/download/OSPRay_readme.pdf" title="OSPRay Documentation">API documentation</a> of OSPRay can also be found as a <a href="http://www.sdvis.org/ospray/download/OSPRay_readme.pdf" title="OSPRay Documentation">pdf document</a>.</p>
<p>For a deeper explanation of the concepts, design, features and performance of OSPRay also have a look at the IEEE Vis 2016 paper “<a href="http://www.sdvis.org/ospray/download/talks/IEEEVis2016_OSPRay_paper.pdf">OSPRay – A CPU Ray Tracing Framework for Scientific Visualization</a>” (49MB, or get the <a href="http://www.sdvis.org/ospray/download/talks/IEEEVis2016_OSPRay_paper_small.pdf">smaller version</a> 1.8MB). Also available are the <a href="http://www.sdvis.org/ospray/download/talks/IEEEVis2016_OSPRay_talk.pdf">slides of the talk</a> (5.2MB).</p>
<h1 id="ospray-api">OSPRay API</h1>
<p>To access the OSPRay API you first need to include the OSPRay header</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1-1" title="1"><span class="pp">#include </span><span class="im">&quot;ospray/ospray.h&quot;</span></a></code></pre></div>
<p>where the API is compatible with C99 and C++.</p>
<h2 id="initialization-and-shutdown">Initialization and Shutdown</h2>
<p>In order to use the API, OSPRay must be initialized with a “device”. A device is the object which implements the API. Creating and initializing a device can be done in either of two ways: command line arguments or manually instantiating a device.</p>
<h3 id="command-line-arguments">Command Line Arguments</h3>
<p>The first is to do so by giving OSPRay the command line from <code>main()</code> by calling</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb2-1" title="1">OSPError ospInit(<span class="dt">int</span> *argc, <span class="at">const</span> <span class="dt">char</span> **argv);</a></code></pre></div>
<p>OSPRay parses (and removes) its known command line parameters from your application’s <code>main</code> function. For an example see the <a href="#tutorial">tutorial</a>. For possible error codes see section <a href="#error-handling-and-status-messages">Error Handling and Status Messages</a>. It is important to note that the arguments passed to <code>ospInit()</code> are processed in order they are listed. The following parameters (which are prefixed by convention with “<code>--osp:</code>”) are understood:</p>
<table style="width:97%;">
<caption>Command line parameters accepted by OSPRay’s <code>ospInit</code>.</caption>
<colgroup>
<col style="width: 36%" />
<col style="width: 61%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Parameter</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>--osp:debug</code></td>
<td style="text-align: left;">enables various extra checks and debug output, and disables multi-threading</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>--osp:numthreads &lt;n&gt;</code></td>
<td style="text-align: left;">use <code>n</code> threads instead of per default using all detected hardware threads</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>--osp:loglevel &lt;n&gt;</code></td>
<td style="text-align: left;">set logging level, default <code>0</code>; increasing <code>n</code> means increasingly verbose log messages</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>--osp:verbose</code></td>
<td style="text-align: left;">shortcut for <code>--osp:loglevel 1</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>--osp:vv</code></td>
<td style="text-align: left;">shortcut for <code>--osp:loglevel 2</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>--osp:module:&lt;name&gt;</code></td>
<td style="text-align: left;">load a module during initialization; equivalent to calling <code>ospLoadModule(name)</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>--osp:mpi</code></td>
<td style="text-align: left;">enables MPI mode for parallel rendering with the <code>mpi_offload</code> device, to be used in conjunction with <code>mpirun</code>; this will automatically load the “mpi” module if it is not yet loaded or linked</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>--osp:mpi-offload</code></td>
<td style="text-align: left;">same as <code>--osp:mpi</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>--osp:mpi-distributed</code></td>
<td style="text-align: left;">same as <code>--osp:mpi</code>, but will create an <code>mpi_distributed</code> device instead; Note that this will likely require application changes to work properly</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>--osp:logoutput &lt;dst&gt;</code></td>
<td style="text-align: left;">convenience for setting where status messages go; valid values for <code>dst</code> are <code>cerr</code> and <code>cout</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>--osp:erroroutput &lt;dst&gt;</code></td>
<td style="text-align: left;">convenience for setting where error messages go; valid values for <code>dst</code> are <code>cerr</code> and <code>cout</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>--osp:device:&lt;name&gt;</code></td>
<td style="text-align: left;">use <code>name</code> as the type of device for OSPRay to create; e.g. <code>--osp:device:default</code> gives you the default local device; Note if the device to be used is defined in a module, remember to pass <code>--osp:module:&lt;name&gt;</code> first</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>--osp:setaffinity &lt;n&gt;</code></td>
<td style="text-align: left;">if <code>1</code>, bind software threads to hardware threads; <code>0</code> disables binding; default is <code>1</code> on KNL and <code>0</code> otherwise</td>
</tr>
</tbody>
</table>
<h3 id="manual-device-instantiation">Manual Device Instantiation</h3>
<p>The second method of initialization is to explicitly create the device yourself, and possibly set parameters. This method looks almost identical to how other <a href="#objects">objects</a> are created and used by OSPRay (described in later sections). The first step is to create the device with</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb3-1" title="1">OSPDevice ospNewDevice(<span class="at">const</span> <span class="dt">char</span> *type);</a></code></pre></div>
<p>where the <code>type</code> string maps to a specific device implementation. OSPRay always provides the “<code>default</code>” device, which maps to a local CPU rendering device. If it is enabled in the build, you can also use “<code>mpi</code>” to access the MPI multi-node rendering device (see <a href="#parallel-rendering-with-mpi">Parallel Rendering with MPI</a> section for more information). Once a device is created, you can call</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb4-1" title="1"><span class="dt">void</span> ospDeviceSet1i(OSPDevice, <span class="at">const</span> <span class="dt">char</span> *id, <span class="dt">int</span> val);</a>
<a class="sourceLine" id="cb4-2" title="2"><span class="dt">void</span> ospDeviceSetString(OSPDevice, <span class="at">const</span> <span class="dt">char</span> *id, <span class="at">const</span> <span class="dt">char</span> *val);</a>
<a class="sourceLine" id="cb4-3" title="3"><span class="dt">void</span> ospDeviceSetVoidPtr(OSPDevice, <span class="at">const</span> <span class="dt">char</span> *id, <span class="dt">void</span> *val);</a></code></pre></div>
<p>to set parameters on the device. The following parameters can be set on all devices:</p>
<table style="width:97%;">
<caption>Parameters shared by all devices.</caption>
<colgroup>
<col style="width: 11%" />
<col style="width: 18%" />
<col style="width: 67%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">int</td>
<td style="text-align: left;">numThreads</td>
<td style="text-align: left;">number of threads which OSPRay should use</td>
</tr>
<tr class="even">
<td style="text-align: left;">int</td>
<td style="text-align: left;">logLevel</td>
<td style="text-align: left;">logging level</td>
</tr>
<tr class="odd">
<td style="text-align: left;">string</td>
<td style="text-align: left;">logOutput</td>
<td style="text-align: left;">convenience for setting where status messages go; valid values are <code>cerr</code> and <code>cout</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">string</td>
<td style="text-align: left;">errorOutput</td>
<td style="text-align: left;">convenience for setting where error messages go; valid values are <code>cerr</code> and <code>cout</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">int</td>
<td style="text-align: left;">debug</td>
<td style="text-align: left;">set debug mode; equivalent to logLevel=2 and numThreads=1</td>
</tr>
<tr class="even">
<td style="text-align: left;">int</td>
<td style="text-align: left;">setAffinity</td>
<td style="text-align: left;">bind software threads to hardware threads if set to 1; 0 disables binding omitting the parameter will let OSPRay choose</td>
</tr>
</tbody>
</table>
<p>Once parameters are set on the created device, the device must be committed with</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb5-1" title="1"><span class="dt">void</span> ospDeviceCommit(OSPDevice);</a></code></pre></div>
<p>To use the newly committed device, you must call</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb6-1" title="1"><span class="dt">void</span> ospSetCurrentDevice(OSPDevice);</a></code></pre></div>
<p>This then sets the given device as the object which will respond to all other OSPRay API calls.</p>
<p>Users can change parameters on the device after initialization (from either method above), by calling</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb7-1" title="1">OSPDevice ospGetCurrentDevice();</a></code></pre></div>
<p>This function returns the handle to the device currently used to respond to OSPRay API calls, where users can set/change parameters and recommit the device. If changes are made to the device that is already set as the current device, it does not need to be set as current again.</p>
<h3 id="environment-variables">Environment Variables</h3>
<p>Finally, OSPRay’s generic device parameters can be overridden via environment variables for easy changes to OSPRay’s behavior without needing to change the application (variables are prefixed by convention with “<code>OSPRAY_</code>”):</p>
<table>
<caption>Environment variables interpreted by OSPRay.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Variable</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">OSPRAY_THREADS</td>
<td style="text-align: left;">equivalent to <code>--osp:numthreads</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">OSPRAY_LOG_LEVEL</td>
<td style="text-align: left;">equivalent to <code>--osp:loglevel</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSPRAY_LOG_OUTPUT</td>
<td style="text-align: left;">equivalent to <code>--osp:logoutput</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">OSPRAY_ERROR_OUTPUT</td>
<td style="text-align: left;">equivalent to <code>--osp:erroroutput</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSPRAY_DEBUG</td>
<td style="text-align: left;">equivalent to <code>--osp:debug</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">OSPRAY_SET_AFFINITY</td>
<td style="text-align: left;">equivalent to <code>--osp:setaffinity</code></td>
</tr>
</tbody>
</table>
<h3 id="error-handling-and-status-messages">Error Handling and Status Messages</h3>
<p>The following errors are currently used by OSPRay:</p>
<table>
<caption>Possible error codes, i.e. valid named constants of type <code>OSPError</code>.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">OSP_NO_ERROR</td>
<td style="text-align: left;">no error occurred</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_UNKNOWN_ERROR</td>
<td style="text-align: left;">an unknown error occurred</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_INVALID_ARGUMENT</td>
<td style="text-align: left;">an invalid argument was specified</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_INVALID_OPERATION</td>
<td style="text-align: left;">the operation is not allowed for the specified object</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_OUT_OF_MEMORY</td>
<td style="text-align: left;">there is not enough memory to execute the command</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_UNSUPPORTED_CPU</td>
<td style="text-align: left;">the CPU is not supported (minimum ISA is SSE4.1)</td>
</tr>
</tbody>
</table>
<p>These error codes are either directly return by some API functions, or are recorded to be later queried by the application via</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb8-1" title="1">OSPError ospDeviceGetLastErrorCode(OSPDevice);</a></code></pre></div>
<p>A more descriptive error message can be queried by calling</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb9-1" title="1"><span class="at">const</span> <span class="dt">char</span>* ospDeviceGetLastErrorMsg(OSPDevice);</a></code></pre></div>
<p>Alternatively, the application can also register a callback function of type</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb10-1" title="1"><span class="kw">typedef</span> <span class="dt">void</span> (*OSPErrorFunc)(OSPError, <span class="at">const</span> <span class="dt">char</span>* errorDetails);</a></code></pre></div>
<p>via</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb11-1" title="1"><span class="dt">void</span> ospDeviceSetErrorFunc(OSPDevice, OSPErrorFunc);</a></code></pre></div>
<p>to get notified when errors occur.</p>
<p>Applications may be interested in messages which OSPRay emits, whether for debugging or logging events. Applications can call</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb12-1" title="1"><span class="dt">void</span> ospDeviceSetStatusFunc(OSPDevice, OSPStatusFunc);</a></code></pre></div>
<p>in order to register a callback function of type</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb13-1" title="1"><span class="kw">typedef</span> <span class="dt">void</span> (*OSPStatusFunc)(<span class="at">const</span> <span class="dt">char</span>* messageText);</a></code></pre></div>
<p>which OSPRay will use to emit status messages. By default, OSPRay uses a callback which does nothing, so any output desired by an application will require that a callback is provided. Note that callbacks for C++ <code>std::cout</code> and <code>std::cerr</code> can be alternatively set through <code>ospInit()</code> or the <code>OSPRAY_LOG_OUTPUT</code> environment variable.</p>
<h3 id="loading-ospray-extensions-at-runtime">Loading OSPRay Extensions at Runtime</h3>
<p>OSPRay’s functionality can be extended via plugins, which are implemented in shared libraries. To load plugin <code>name</code> from <code>libospray_module_&lt;name&gt;.so</code> (on Linux and Mac OS X) or <code>ospray_module_&lt;name&gt;.dll</code> (on Windows) use</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb14-1" title="1">OSPError ospLoadModule(<span class="at">const</span> <span class="dt">char</span> *name);</a></code></pre></div>
<p>Modules are searched in OS-dependent paths. <code>ospLoadModule</code> returns <code>OSP_NO_ERROR</code> if the plugin could be successfully loaded.</p>
<h3 id="shutting-down-ospray">Shutting Down OSPRay</h3>
<p>When the application is finished using OSPRay (typically on application exit), the OSPRay API should be finalized with</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb15-1" title="1"><span class="dt">void</span> ospShutdown();</a></code></pre></div>
<p>This API call ensures that the current device is cleaned up appropriately. Due to static object allocation having non-deterministic ordering, it is recommended that applications call <code>ospShutdown()</code> before the calling application process terminates.</p>
<h2 id="objects">Objects</h2>
<p>All entities of OSPRay (the renderer, volumes, geometries, lights, cameras, …) are a specialization of <code>OSPObject</code> and share common mechanism to deal with parameters and lifetime.</p>
<p>An important aspect of object parameters is that parameters do not get passed to objects immediately. Instead, parameters are not visible at all to objects until they get explicitly committed to a given object via a call to</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb16-1" title="1"><span class="dt">void</span> ospCommit(OSPObject);</a></code></pre></div>
<p>at which time all previously additions or changes to parameters are visible at the same time. If a user wants to change the state of an existing object (e.g., to change the origin of an already existing camera) it is perfectly valid to do so, as long as the changed parameters are recommitted.</p>
<p>The commit semantic allow for batching up multiple small changes, and specifies exactly when changes to objects will occur. This is important to ensure performance and consistency for devices crossing a PCI bus, or across a network. In our MPI implementation, for example, we can easily guarantee consistency among different nodes by MPI barrier’ing on every commit.</p>
<p>Note that OSPRay uses reference counting to manage the lifetime of all objects, so one cannot explicitly “delete” any object. Instead, to indicate that the application does not need and does not access the given object anymore, call</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb17-1" title="1"><span class="dt">void</span> ospRelease(OSPObject);</a></code></pre></div>
<p>This decreases its reference count and if the count reaches <code>0</code> the object will automatically get deleted. Passing <code>NULL</code> is not an error.</p>
<h3 id="parameters">Parameters</h3>
<p>Parameters allow to configure the behavior of and to pass data to objects. However, objects do <em>not</em> have an explicit interface for reasons of high flexibility and a more stable compile-time API. Instead, parameters are passed separately to objects in an arbitrary order, and unknown parameters will simply be ignored. The following functions allow adding various types of parameters with name <code>id</code> to a given object:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb18-1" title="1"><span class="co">// add a C-string (zero-terminated char *) parameter</span></a>
<a class="sourceLine" id="cb18-2" title="2"><span class="dt">void</span> ospSetString(OSPObject, <span class="at">const</span> <span class="dt">char</span> *id, <span class="at">const</span> <span class="dt">char</span> *s);</a>
<a class="sourceLine" id="cb18-3" title="3"></a>
<a class="sourceLine" id="cb18-4" title="4"><span class="co">// add an object handle parameter to another object</span></a>
<a class="sourceLine" id="cb18-5" title="5"><span class="dt">void</span> ospSetObject(OSPObject, <span class="at">const</span> <span class="dt">char</span> *id, OSPObject object);</a>
<a class="sourceLine" id="cb18-6" title="6"></a>
<a class="sourceLine" id="cb18-7" title="7"><span class="co">// add an untyped pointer -- this will *ONLY* work in local rendering!</span></a>
<a class="sourceLine" id="cb18-8" title="8"><span class="dt">void</span> ospSetVoidPtr(OSPObject, <span class="at">const</span> <span class="dt">char</span> *id, <span class="dt">void</span> *v);</a>
<a class="sourceLine" id="cb18-9" title="9"></a>
<a class="sourceLine" id="cb18-10" title="10"><span class="co">// add scalar and vector integer and float parameters</span></a>
<a class="sourceLine" id="cb18-11" title="11"><span class="dt">void</span> ospSetf  (OSPObject, <span class="at">const</span> <span class="dt">char</span> *id, <span class="dt">float</span> x);</a>
<a class="sourceLine" id="cb18-12" title="12"><span class="dt">void</span> ospSet1f (OSPObject, <span class="at">const</span> <span class="dt">char</span> *id, <span class="dt">float</span> x);</a>
<a class="sourceLine" id="cb18-13" title="13"><span class="dt">void</span> ospSet1i (OSPObject, <span class="at">const</span> <span class="dt">char</span> *id, <span class="dt">int32_t</span> x);</a>
<a class="sourceLine" id="cb18-14" title="14"><span class="dt">void</span> ospSet2f (OSPObject, <span class="at">const</span> <span class="dt">char</span> *id, <span class="dt">float</span> x, <span class="dt">float</span> y);</a>
<a class="sourceLine" id="cb18-15" title="15"><span class="dt">void</span> ospSet2fv(OSPObject, <span class="at">const</span> <span class="dt">char</span> *id, <span class="at">const</span> <span class="dt">float</span> *xy);</a>
<a class="sourceLine" id="cb18-16" title="16"><span class="dt">void</span> ospSet2i (OSPObject, <span class="at">const</span> <span class="dt">char</span> *id, <span class="dt">int</span> x, <span class="dt">int</span> y);</a>
<a class="sourceLine" id="cb18-17" title="17"><span class="dt">void</span> ospSet2iv(OSPObject, <span class="at">const</span> <span class="dt">char</span> *id, <span class="at">const</span> <span class="dt">int</span> *xy);</a>
<a class="sourceLine" id="cb18-18" title="18"><span class="dt">void</span> ospSet3f (OSPObject, <span class="at">const</span> <span class="dt">char</span> *id, <span class="dt">float</span> x, <span class="dt">float</span> y, <span class="dt">float</span> z);</a>
<a class="sourceLine" id="cb18-19" title="19"><span class="dt">void</span> ospSet3fv(OSPObject, <span class="at">const</span> <span class="dt">char</span> *id, <span class="at">const</span> <span class="dt">float</span> *xyz);</a>
<a class="sourceLine" id="cb18-20" title="20"><span class="dt">void</span> ospSet3i (OSPObject, <span class="at">const</span> <span class="dt">char</span> *id, <span class="dt">int</span> x, <span class="dt">int</span> y, <span class="dt">int</span> z);</a>
<a class="sourceLine" id="cb18-21" title="21"><span class="dt">void</span> ospSet3iv(OSPObject, <span class="at">const</span> <span class="dt">char</span> *id, <span class="at">const</span> <span class="dt">int</span> *xyz);</a>
<a class="sourceLine" id="cb18-22" title="22"><span class="dt">void</span> ospSet4f (OSPObject, <span class="at">const</span> <span class="dt">char</span> *id, <span class="dt">float</span> x, <span class="dt">float</span> y, <span class="dt">float</span> z, <span class="dt">float</span> w);</a>
<a class="sourceLine" id="cb18-23" title="23"><span class="dt">void</span> ospSet4fv(OSPObject, <span class="at">const</span> <span class="dt">char</span> *id, <span class="at">const</span> <span class="dt">float</span> *xyzw);</a>
<a class="sourceLine" id="cb18-24" title="24"></a>
<a class="sourceLine" id="cb18-25" title="25"><span class="co">// additional functions to pass vector integer and float parameters in C++</span></a>
<a class="sourceLine" id="cb18-26" title="26"><span class="dt">void</span> ospSetVec2f(OSPObject, <span class="at">const</span> <span class="dt">char</span> *id, <span class="at">const</span> vec2f &amp;v);</a>
<a class="sourceLine" id="cb18-27" title="27"><span class="dt">void</span> ospSetVec2i(OSPObject, <span class="at">const</span> <span class="dt">char</span> *id, <span class="at">const</span> vec2i &amp;v);</a>
<a class="sourceLine" id="cb18-28" title="28"><span class="dt">void</span> ospSetVec3f(OSPObject, <span class="at">const</span> <span class="dt">char</span> *id, <span class="at">const</span> vec3f &amp;v);</a>
<a class="sourceLine" id="cb18-29" title="29"><span class="dt">void</span> ospSetVec3i(OSPObject, <span class="at">const</span> <span class="dt">char</span> *id, <span class="at">const</span> vec3i &amp;v);</a>
<a class="sourceLine" id="cb18-30" title="30"><span class="dt">void</span> ospSetVec4f(OSPObject, <span class="at">const</span> <span class="dt">char</span> *id, <span class="at">const</span> vec4f &amp;v);</a></code></pre></div>
<p>Users can also remove parameters that have been explicitly set via an ospSet call. Any parameters which have been removed will go back to their default value during the next commit unless a new parameter was set after the parameter was removed. The following API function removes the named parameter from the given object:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb19-1" title="1"><span class="dt">void</span> ospRemoveParam(OSPObject, <span class="at">const</span> <span class="dt">char</span> *id);</a></code></pre></div>
<h3 id="data">Data</h3>
<p>There is also the possibility to aggregate many values of the same type into an array, which then itself can be used as a parameter to objects. To create such a new data buffer, holding <code>numItems</code> elements of the given type, from the initialization data pointed to by <code>source</code> and optional creation flags, use</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb20-1" title="1">OSPData ospNewData(<span class="dt">size_t</span> numItems,</a>
<a class="sourceLine" id="cb20-2" title="2">                   OSPDataType,</a>
<a class="sourceLine" id="cb20-3" title="3">                   <span class="at">const</span> <span class="dt">void</span> *source,</a>
<a class="sourceLine" id="cb20-4" title="4">                   <span class="at">const</span> <span class="dt">uint32_t</span> dataCreationFlags = <span class="dv">0</span>);</a></code></pre></div>
<p>The call returns an <code>OSPData</code> handle to the created array. The flag <code>OSP_DATA_SHARED_BUFFER</code> indicates that the buffer can be shared with the application. In this case the calling program guarantees that the <code>source</code> pointer will remain valid for the duration that this data array is being used. The enum type <code>OSPDataType</code> describes the different data types that can be represented in OSPRay; valid constants are listed in the table below.</p>
<table>
<caption>Valid named constants for <code>OSPDataType</code>.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Type/Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">OSP_DEVICE</td>
<td style="text-align: left;">API device object reference</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_VOID_PTR</td>
<td style="text-align: left;">void pointer</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_DATA</td>
<td style="text-align: left;">data reference</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_OBJECT</td>
<td style="text-align: left;">generic object reference</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_CAMERA</td>
<td style="text-align: left;">camera object reference</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_FRAMEBUFFER</td>
<td style="text-align: left;">framebuffer object reference</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_LIGHT</td>
<td style="text-align: left;">light object reference</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_MATERIAL</td>
<td style="text-align: left;">material object reference</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_TEXTURE</td>
<td style="text-align: left;">texture object reference</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_RENDERER</td>
<td style="text-align: left;">renderer object reference</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_MODEL</td>
<td style="text-align: left;">model object reference</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_GEOMETRY</td>
<td style="text-align: left;">geometry object reference</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_VOLUME</td>
<td style="text-align: left;">volume object reference</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_TRANSFER_FUNCTION</td>
<td style="text-align: left;">transfer function object reference</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_PIXEL_OP</td>
<td style="text-align: left;">pixel operation object reference</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_STRING</td>
<td style="text-align: left;">C-style zero-terminated character string</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_CHAR</td>
<td style="text-align: left;">8 bit signed character scalar</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_UCHAR</td>
<td style="text-align: left;">8 bit unsigned character scalar</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_UCHAR[234]</td>
<td style="text-align: left;">… and [234]-element vector</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_USHORT</td>
<td style="text-align: left;">16 bit unsigned integer scalar</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_INT</td>
<td style="text-align: left;">32 bit signed integer scalar</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_INT[234]</td>
<td style="text-align: left;">… and [234]-element vector</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_UINT</td>
<td style="text-align: left;">32 bit unsigned integer scalar</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_UINT[234]</td>
<td style="text-align: left;">… and [234]-element vector</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_LONG</td>
<td style="text-align: left;">64 bit signed integer scalar</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_LONG[234]</td>
<td style="text-align: left;">… and [234]-element vector</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_ULONG</td>
<td style="text-align: left;">64 bit unsigned integer scalar</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_ULONG[234]</td>
<td style="text-align: left;">… and [234]-element vector</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_FLOAT</td>
<td style="text-align: left;">32 bit single precision floating point scalar</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_FLOAT[234]</td>
<td style="text-align: left;">… and [234]-element vector</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_FLOAT3A</td>
<td style="text-align: left;">… and 3-element vector with padding (same size as an OSP_FLOAT4)</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_DOUBLE</td>
<td style="text-align: left;">64 bit double precision floating point scalar</td>
</tr>
</tbody>
</table>
<p>To add a data array as parameter named <code>id</code> to another object call</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb21-1" title="1"><span class="dt">void</span> ospSetData(OSPObject, <span class="at">const</span> <span class="dt">char</span> *id, OSPData);</a></code></pre></div>
<h2 id="volumes">Volumes</h2>
<p>Volumes are volumetric datasets with discretely sampled values in 3D space, typically a 3D scalar field. To create a new volume object of given type <code>type</code> use</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb22-1" title="1">OSPVolume ospNewVolume(<span class="at">const</span> <span class="dt">char</span> *type);</a></code></pre></div>
<p>The call returns <code>NULL</code> if that type of volume is not known by OSPRay, or else an <code>OSPVolume</code> handle.</p>
<p>The common parameters understood by all volume variants are summarized in the table below.</p>
<table style="width:98%;">
<caption>Configuration parameters shared by all volume types.</caption>
<colgroup>
<col style="width: 23%" />
<col style="width: 27%" />
<col style="width: 11%" />
<col style="width: 34%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: right;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">OSPTransferFunction</td>
<td style="text-align: left;">transferFunction</td>
<td style="text-align: right;"></td>
<td style="text-align: left;"><a href="#transfer-function">transfer function</a> to use</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec2f</td>
<td style="text-align: left;">voxelRange</td>
<td style="text-align: right;"></td>
<td style="text-align: left;">minimum and maximum of the scalar values</td>
</tr>
<tr class="odd">
<td style="text-align: left;">bool</td>
<td style="text-align: left;">gradientShadingEnabled</td>
<td style="text-align: right;">false</td>
<td style="text-align: left;">volume is rendered with surface shading wrt. to normalized gradient</td>
</tr>
<tr class="even">
<td style="text-align: left;">bool</td>
<td style="text-align: left;">preIntegration</td>
<td style="text-align: right;">false</td>
<td style="text-align: left;">use pre-integration for <a href="#transfer-function">transfer function</a> lookups</td>
</tr>
<tr class="odd">
<td style="text-align: left;">bool</td>
<td style="text-align: left;">singleShade</td>
<td style="text-align: right;">true</td>
<td style="text-align: left;">shade only at the point of maximum intensity</td>
</tr>
<tr class="even">
<td style="text-align: left;">bool</td>
<td style="text-align: left;">adaptiveSampling</td>
<td style="text-align: right;">true</td>
<td style="text-align: left;">adapt ray step size based on opacity</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">adaptiveScalar</td>
<td style="text-align: right;">15</td>
<td style="text-align: left;">modifier for adaptive step size</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">adaptiveMaxSamplingRate</td>
<td style="text-align: right;">2</td>
<td style="text-align: left;">maximum sampling rate for adaptive sampling</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">samplingRate</td>
<td style="text-align: right;">0.125</td>
<td style="text-align: left;">sampling rate of the volume (this is the minimum step size for adaptive sampling)</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">specular</td>
<td style="text-align: right;">gray 0.3</td>
<td style="text-align: left;">specular color for shading</td>
</tr>
<tr class="odd">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">volumeClippingBoxLower</td>
<td style="text-align: right;">disabled</td>
<td style="text-align: left;">lower coordinate (in object-space) to clip the volume values</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">volumeClippingBoxUpper</td>
<td style="text-align: right;">disabled</td>
<td style="text-align: left;">upper coordinate (in object-space) to clip the volume values</td>
</tr>
</tbody>
</table>
<p>Note that if <code>voxelRange</code> is not provided for a volume then OSPRay will compute it based on the voxel data, which may result in slower data updates.</p>
<h3 id="structured-volume">Structured Volume</h3>
<p>Structured volumes only need to store the values of the samples, because their addresses in memory can be easily computed from a 3D position. A common type of structured volumes are regular grids. OSPRay supports two variants that differ in how the volumetric data for the regular grids is specified.</p>
<p>The first variant shares the voxel data with the application. Such a volume type is created by passing the type string “<code>shared_structured_volume</code>” to <code>ospNewVolume</code>. The voxel data is laid out in memory in xyz-order<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a> and provided to the volume via a <a href="#data">data</a> buffer parameter named “<code>voxelData</code>”.</p>
<p>The second regular grid variant is optimized for rendering performance: data locality in memory is increased by arranging the voxel data in smaller blocks. This volume type is created by passing the type string “<code>block_bricked_volume</code>” to <code>ospNewVolume</code>. Because of this rearrangement of voxel data it cannot be shared the with the application anymore, but has to be transferred to OSPRay via</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb23-1" title="1">OSPError ospSetRegion(OSPVolume, <span class="dt">void</span> *source,</a>
<a class="sourceLine" id="cb23-2" title="2">                      <span class="at">const</span> vec3i &amp;regionCoords,</a>
<a class="sourceLine" id="cb23-3" title="3">                      <span class="at">const</span> vec3i &amp;regionSize);</a></code></pre></div>
<p>The voxel data pointed to by <code>source</code> is copied into the given volume starting at position <code>regionCoords</code>, must be of size <code>regionSize</code> and be placed in memory in xyz-order. Note that OSPRay distinguishes between volume data and volume parameters. This function must be called only after all volume parameters (in particular <code>dimensions</code> and <code>voxelType</code>, see below) have been set and <em>before</em> <code>ospCommit(volume)</code> is called. If necessary then memory for the volume is allocated on the first call to this function.</p>
<p>The common parameters understood by both structured volume variants are summarized in the table below.</p>
<table style="width:97%;">
<caption>Additional configuration parameters for structured volumes.</caption>
<colgroup>
<col style="width: 12%" />
<col style="width: 18%" />
<col style="width: 18%" />
<col style="width: 48%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: right;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">vec3i</td>
<td style="text-align: left;">dimensions</td>
<td style="text-align: right;"></td>
<td style="text-align: left;">number of voxels in each dimension <span class="math inline">(<em>x</em>, <em>y</em>, <em>z</em>)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">string</td>
<td style="text-align: left;">voxelType</td>
<td style="text-align: right;"></td>
<td style="text-align: left;">data type of each voxel, currently supported are:</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: right;"></td>
<td style="text-align: left;">“uchar” (8 bit unsigned integer)</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: right;"></td>
<td style="text-align: left;">“short” (16 bit signed integer)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: right;"></td>
<td style="text-align: left;">“ushort” (16 bit unsigned integer)</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: right;"></td>
<td style="text-align: left;">“float” (32 bit single precision floating point)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: right;"></td>
<td style="text-align: left;">“double” (64 bit double precision floating point)</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">gridOrigin</td>
<td style="text-align: right;"><span class="math inline">(0, 0, 0)</span></td>
<td style="text-align: left;">origin of the grid in world-space</td>
</tr>
<tr class="odd">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">gridSpacing</td>
<td style="text-align: right;"><span class="math inline">(1, 1, 1)</span></td>
<td style="text-align: left;">size of the grid cells in world-space</td>
</tr>
</tbody>
</table>
<h3 id="adaptive-mesh-refinement-amr-volume">Adaptive Mesh Refinement (AMR) Volume</h3>
<p>AMR volumes are specified as a list of bricks, which are levels of refinement in potentially overlapping regions. There can be any number of refinement levels and any number of bricks at any level of refinement. An AMR volume type is created by passing the type string “<code>amr_volume</code>” to <code>ospNewVolume</code>.</p>
<p>Applications should first create an <code>OSPData</code> array which holds information about each brick. The following structure is used to populate this array (found in <code>ospray.h</code>):</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb24-1" title="1"><span class="kw">struct</span> amr_brick_info</a>
<a class="sourceLine" id="cb24-2" title="2">{</a>
<a class="sourceLine" id="cb24-3" title="3">  box3i bounds;</a>
<a class="sourceLine" id="cb24-4" title="4">  <span class="dt">int</span>   refinementLevel;</a>
<a class="sourceLine" id="cb24-5" title="5">  <span class="dt">float</span> cellWidth;</a>
<a class="sourceLine" id="cb24-6" title="6">};</a></code></pre></div>
<p>Then for each brick, the application should create an <code>OSPData</code> array of <code>OSPData</code> handles, where each handle is the data per-brick. Currently we only support <code>float</code> voxels.</p>
<table style="width:97%;">
<caption>Additional configuration parameters for AMR volumes.</caption>
<colgroup>
<col style="width: 13%" />
<col style="width: 18%" />
<col style="width: 18%" />
<col style="width: 47%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: right;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">gridOrigin</td>
<td style="text-align: right;"><span class="math inline">(0, 0, 0)</span></td>
<td style="text-align: left;">origin of the grid in world-space</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">gridSpacing</td>
<td style="text-align: right;"><span class="math inline">(1, 1, 1)</span></td>
<td style="text-align: left;">size of the grid cells in world-space</td>
</tr>
<tr class="odd">
<td style="text-align: left;">string</td>
<td style="text-align: left;">amrMethod</td>
<td style="text-align: right;">current</td>
<td style="text-align: left;">sampling method; valid values are “finest”, “current”, or “octant”</td>
</tr>
<tr class="even">
<td style="text-align: left;">string</td>
<td style="text-align: left;">voxelType</td>
<td style="text-align: right;">undefined</td>
<td style="text-align: left;">data type of each voxel, currently supported are:</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: right;"></td>
<td style="text-align: left;">“uchar” (8 bit unsigned integer)</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: right;"></td>
<td style="text-align: left;">“short” (16 bit signed integer)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: right;"></td>
<td style="text-align: left;">“ushort” (16 bit unsigned integer)</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: right;"></td>
<td style="text-align: left;">“float” (32 bit single precision floating point)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: right;"></td>
<td style="text-align: left;">“double” (64 bit double precision floating point)</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSPData</td>
<td style="text-align: left;">brickInfo</td>
<td style="text-align: right;"></td>
<td style="text-align: left;">array of info defining each brick</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSPData</td>
<td style="text-align: left;">brickData</td>
<td style="text-align: right;"></td>
<td style="text-align: left;">array of handles to per-brick voxel data</td>
</tr>
</tbody>
</table>
<p>Lastly, note that the <code>gridOrigin</code> and <code>gridSpacing</code> parameters act just like the structured volume equivalent, but they only modify the root (coarsest level) of refinement.</p>
<h3 id="unstructured-volumes">Unstructured Volumes</h3>
<p>Unstructured volumes can contain tetrahedral, wedge, or hexahedral cell types, and are defined by three arrays: vertices, corresponding field values, and eight indices per cell (first four are -1 for tetrahedral cells, first two are -2 for wedge cells). An unstructured volume type is created by passing the type string “<code>unstructured_volume</code>” to <code>ospNewVolume</code>.</p>
<p>Field values can be specified per-vertex (<code>field</code>) or per-cell (<code>cellField</code>). If both values are set, <code>cellField</code> takes precedence.</p>
<p>Similar to <a href="#triangle-mesh">triangle mesh</a>, each tetrahedron is formed by a group of indices into the vertices. For each vertex, the corresponding (by array index) data value will be used for sampling when rendering. Note that the index order for each tetrahedron does not matter, as OSPRay internally calculates vertex normals to ensure proper sampling and interpolation.</p>
<p>For wedge cells, each wedge is formed by a group of six indices into the vertices and data value. Vertex ordering is the same as <code>VTK_WEDGE</code>: three bottom vertices counterclockwise, then top three counterclockwise.</p>
<p>For hexahedral cells, each hexahedron is formed by a group of eight indices into the vertices and data value. Vertex ordering is the same as <code>VTK_HEXAHEDRON</code>: four bottom vertices counterclockwise, then top four counterclockwise.</p>
<table style="width:98%;">
<caption>Additional configuration parameters for unstructured volumes.</caption>
<colgroup>
<col style="width: 14%" />
<col style="width: 25%" />
<col style="width: 12%" />
<col style="width: 44%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">vec3f[]</td>
<td style="text-align: left;">vertices</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><a href="#data">data</a> array of vertex positions</td>
</tr>
<tr class="even">
<td style="text-align: left;">float[]</td>
<td style="text-align: left;">field</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><a href="#data">data</a> array of vertex data values to be sampled</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float[]</td>
<td style="text-align: left;">cellField</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><a href="#data">data</a> array of cell data values to be sampled</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec4i[]</td>
<td style="text-align: left;">indices</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><a href="#data">data</a> array of tetrahedra indices (into vertices and field)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">string</td>
<td style="text-align: left;">hexMethod</td>
<td style="text-align: left;">planar</td>
<td style="text-align: left;">“planar” (faster, assumes planar sides) or “nonplanar”</td>
</tr>
<tr class="even">
<td style="text-align: left;">bool</td>
<td style="text-align: left;">precomputedNormals</td>
<td style="text-align: left;">true</td>
<td style="text-align: left;">whether to accelerate by precomputing, at a cost of 72 bytes/cell</td>
</tr>
</tbody>
</table>
<h3 id="transfer-function">Transfer Function</h3>
<p>Transfer functions map the scalar values of volumes to color and opacity and thus they can be used to visually emphasize certain features of the volume. To create a new transfer function of given type <code>type</code> use</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb25-1" title="1">OSPTransferFunction ospNewTransferFunction(<span class="at">const</span> <span class="dt">char</span> *type);</a></code></pre></div>
<p>The call returns <code>NULL</code> if that type of transfer functions is not known by OSPRay, or else an <code>OSPTransferFunction</code> handle to the created transfer function. That handle can be assigned to a volume as parameter “<code>transferFunction</code>” using <code>ospSetObject</code>.</p>
<p>One type of transfer function that is built-in in OSPRay is the linear transfer function, which interpolates between given equidistant colors and opacities. It is create by passing the string “<code>piecewise_linear</code>” to <code>ospNewTransferFunction</code> and it is controlled by these parameters:</p>
<table>
<caption>Parameters accepted by the linear transfer function.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">vec3f[]</td>
<td style="text-align: left;">colors</td>
<td style="text-align: left;"><a href="#data">data</a> array of RGB colors</td>
</tr>
<tr class="even">
<td style="text-align: left;">float[]</td>
<td style="text-align: left;">opacities</td>
<td style="text-align: left;"><a href="#data">data</a> array of opacities</td>
</tr>
<tr class="odd">
<td style="text-align: left;">vec2f</td>
<td style="text-align: left;">valueRange</td>
<td style="text-align: left;">domain (scalar range) this function maps from</td>
</tr>
</tbody>
</table>
<h2 id="geometries">Geometries</h2>
<p>Geometries in OSPRay are objects that describe surfaces. To create a new geometry object of given type <code>type</code> use</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb26-1" title="1">OSPGeometry ospNewGeometry(<span class="at">const</span> <span class="dt">char</span> *type);</a></code></pre></div>
<p>The call returns <code>NULL</code> if that type of geometry is not known by OSPRay, or else an <code>OSPGeometry</code> handle.</p>
<h3 id="triangle-mesh">Triangle Mesh</h3>
<p>A traditional triangle mesh (indexed face set) geometry is created by calling <code>ospNewGeometry</code> with type string “<code>triangles</code>”. Once created, a triangle mesh recognizes the following parameters:</p>
<table>
<caption>Parameters defining a triangle mesh geometry.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">vec3f(a)[]</td>
<td style="text-align: left;">vertex</td>
<td style="text-align: left;"><a href="#data">data</a> array of vertex positions</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec3f(a)[]</td>
<td style="text-align: left;">vertex.normal</td>
<td style="text-align: left;"><a href="#data">data</a> array of vertex normals</td>
</tr>
<tr class="odd">
<td style="text-align: left;">vec4f[] / vec3fa[]</td>
<td style="text-align: left;">vertex.color</td>
<td style="text-align: left;"><a href="#data">data</a> array of vertex colors (RGBA/RGB)</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec2f[]</td>
<td style="text-align: left;">vertex.texcoord</td>
<td style="text-align: left;"><a href="#data">data</a> array of vertex texture coordinates</td>
</tr>
<tr class="odd">
<td style="text-align: left;">vec3i(a)[]</td>
<td style="text-align: left;">index</td>
<td style="text-align: left;"><a href="#data">data</a> array of triangle indices (into the vertex array(s))</td>
</tr>
</tbody>
</table>
<p>The <code>vertex</code> and <code>index</code> arrays are mandatory to create a valid triangle mesh.</p>
<h3 id="quad-mesh">Quad Mesh</h3>
<p>A mesh consisting of quads is created by calling <code>ospNewGeometry</code> with type string “<code>quads</code>”. Once created, a quad mesh recognizes the following parameters:</p>
<table>
<caption>Parameters defining a quad mesh geometry.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">vec3f(a)[]</td>
<td style="text-align: left;">vertex</td>
<td style="text-align: left;"><a href="#data">data</a> array of vertex positions</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec3f(a)[]</td>
<td style="text-align: left;">vertex.normal</td>
<td style="text-align: left;"><a href="#data">data</a> array of vertex normals</td>
</tr>
<tr class="odd">
<td style="text-align: left;">vec4f[] / vec3fa[]</td>
<td style="text-align: left;">vertex.color</td>
<td style="text-align: left;"><a href="#data">data</a> array of vertex colors (RGBA/RGB)</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec2f[]</td>
<td style="text-align: left;">vertex.texcoord</td>
<td style="text-align: left;"><a href="#data">data</a> array of vertex texture coordinates</td>
</tr>
<tr class="odd">
<td style="text-align: left;">vec4i[]</td>
<td style="text-align: left;">index</td>
<td style="text-align: left;"><a href="#data">data</a> array of quad indices (into the vertex array(s))</td>
</tr>
</tbody>
</table>
<p>The <code>vertex</code> and <code>index</code> arrays are mandatory to create a valid quad mesh. A quad is internally handled as a pair of two triangles, thus mixing triangles and quad is supported by encoding a triangle as a quad with the last two vertex indices being identical (<code>w=z</code>).</p>
<h3 id="spheres">Spheres</h3>
<p>A geometry consisting of individual spheres, each of which can have an own radius, is created by calling <code>ospNewGeometry</code> with type string “<code>spheres</code>”. The spheres will not be tessellated but rendered procedurally and are thus perfectly round. To allow a variety of sphere representations in the application this geometry allows a flexible way of specifying the data of center position and radius within a <a href="#data">data</a> array:</p>
<table style="width:98%;">
<caption>Parameters defining a spheres geometry.</caption>
<colgroup>
<col style="width: 16%" />
<col style="width: 22%" />
<col style="width: 26%" />
<col style="width: 32%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: right;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">radius</td>
<td style="text-align: right;">0.01</td>
<td style="text-align: left;">radius of all spheres (if <code>offset_radius</code> is not used)</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSPData</td>
<td style="text-align: left;">spheres</td>
<td style="text-align: right;">NULL</td>
<td style="text-align: left;">memory holding the spatial <a href="#data">data</a> of all spheres</td>
</tr>
<tr class="odd">
<td style="text-align: left;">int</td>
<td style="text-align: left;">bytes_per_sphere</td>
<td style="text-align: right;">16</td>
<td style="text-align: left;">size (in bytes) of each sphere within the <code>spheres</code> array</td>
</tr>
<tr class="even">
<td style="text-align: left;">int</td>
<td style="text-align: left;">offset_center</td>
<td style="text-align: right;">0</td>
<td style="text-align: left;">offset (in bytes) of each sphere’s “vec3f center” position (in object-space) within the <code>spheres</code> array</td>
</tr>
<tr class="odd">
<td style="text-align: left;">int</td>
<td style="text-align: left;">offset_radius</td>
<td style="text-align: right;">-1</td>
<td style="text-align: left;">offset (in bytes) of each sphere’s “float radius” within the <code>spheres</code> array (<code>-1</code> means disabled and use <code>radius</code>)</td>
</tr>
<tr class="even">
<td style="text-align: left;">int</td>
<td style="text-align: left;">offset_colorID</td>
<td style="text-align: right;">-1</td>
<td style="text-align: left;">offset (in bytes) of each sphere’s “int colorID” within the <code>spheres</code> array (<code>-1</code> means disabled and use the shared material color)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">vec4f[] / vec3f(a)[] / vec4uc</td>
<td style="text-align: left;">color</td>
<td style="text-align: right;">NULL</td>
<td style="text-align: left;"><a href="#data">data</a> array of colors (RGBA/RGB), color is constant for each sphere</td>
</tr>
<tr class="even">
<td style="text-align: left;">int</td>
<td style="text-align: left;">color_offset</td>
<td style="text-align: right;">0</td>
<td style="text-align: left;">offset (in bytes) to the start of the color data in <code>color</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">int</td>
<td style="text-align: left;">color_format</td>
<td style="text-align: right;"><code>color.data_type</code></td>
<td style="text-align: left;">the format of the color data. Can be one of: <code>OSP_FLOAT4</code>, <code>OSP_FLOAT3</code>, <code>OSP_FLOAT3A</code> or <code>OSP_UCHAR4</code>. Defaults to the type of data in <code>color</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">int</td>
<td style="text-align: left;">color_stride</td>
<td style="text-align: right;"><code>sizeof(color_format)</code></td>
<td style="text-align: left;">stride (in bytes) between each color element in the <code>color</code> array. Defaults to the size of a single element of type <code>color_format</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">vec2f[]</td>
<td style="text-align: left;">texcoord</td>
<td style="text-align: right;">NULL</td>
<td style="text-align: left;"><a href="#data">data</a> array of texture coordinates, coordinate is constant for each sphere</td>
</tr>
</tbody>
</table>
<h3 id="cylinders">Cylinders</h3>
<p>A geometry consisting of individual cylinders, each of which can have an own radius, is created by calling <code>ospNewGeometry</code> with type string “<code>cylinders</code>”. The cylinders will not be tessellated but rendered procedurally and are thus perfectly round. To allow a variety of cylinder representations in the application this geometry allows a flexible way of specifying the data of offsets for start position, end position and radius within a <a href="#data">data</a> array. All parameters are listed in the table below.</p>
<table style="width:98%;">
<caption>Parameters defining a cylinders geometry.</caption>
<colgroup>
<col style="width: 17%" />
<col style="width: 27%" />
<col style="width: 11%" />
<col style="width: 40%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: right;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">radius</td>
<td style="text-align: right;">0.01</td>
<td style="text-align: left;">radius of all cylinders (if <code>offset_radius</code> is not used)</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSPData</td>
<td style="text-align: left;">cylinders</td>
<td style="text-align: right;">NULL</td>
<td style="text-align: left;">memory holding the spatial <a href="#data">data</a> of all cylinders</td>
</tr>
<tr class="odd">
<td style="text-align: left;">int</td>
<td style="text-align: left;">bytes_per_cylinder</td>
<td style="text-align: right;">24</td>
<td style="text-align: left;">size (in bytes) of each cylinder within the <code>cylinders</code> array</td>
</tr>
<tr class="even">
<td style="text-align: left;">int</td>
<td style="text-align: left;">offset_v0</td>
<td style="text-align: right;">0</td>
<td style="text-align: left;">offset (in bytes) of each cylinder’s “vec3f v0” position (the start vertex, in object-space) within the <code>cylinders</code> array</td>
</tr>
<tr class="odd">
<td style="text-align: left;">int</td>
<td style="text-align: left;">offset_v1</td>
<td style="text-align: right;">12</td>
<td style="text-align: left;">offset (in bytes) of each cylinder’s “vec3f v1” position (the end vertex, in object-space) within the <code>cylinders</code> array</td>
</tr>
<tr class="even">
<td style="text-align: left;">int</td>
<td style="text-align: left;">offset_radius</td>
<td style="text-align: right;">-1</td>
<td style="text-align: left;">offset (in bytes) of each cylinder’s “float radius” within the <code>cylinders</code> array (<code>-1</code> means disabled and use <code>radius</code> instead)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">vec4f[] / vec3f(a)[]</td>
<td style="text-align: left;">color</td>
<td style="text-align: right;">NULL</td>
<td style="text-align: left;"><a href="#data">data</a> array of colors (RGBA/RGB), color is constant for each cylinder</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSPData</td>
<td style="text-align: left;">texcoord</td>
<td style="text-align: right;">NULL</td>
<td style="text-align: left;"><a href="#data">data</a> array of texture coordinates, in pairs (each a vec2f at vertex v0 and v1)</td>
</tr>
</tbody>
</table>
<p>For texturing each cylinder is seen as a 1D primitive, i.e. a line segment: the 2D texture coordinates at its vertices v0 and v1 are linearly interpolated.</p>
<h3 id="streamlines">Streamlines</h3>
<p>A geometry consisting of multiple streamlines is created by calling <code>ospNewGeometry</code> with type string “<code>streamlines</code>”. The streamlines are internally assembled either from connected (and rounded) cylinder segments, or represented as Bézier curves; they are thus always perfectly round. The parameters defining this geometry are listed in the table below.</p>
<table style="width:97%;">
<caption>Parameters defining a streamlines geometry.</caption>
<colgroup>
<col style="width: 22%" />
<col style="width: 21%" />
<col style="width: 53%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">radius</td>
<td style="text-align: left;">global radius of all streamlines (if per-vertex radius is not used), default 0.01</td>
</tr>
<tr class="even">
<td style="text-align: left;">bool</td>
<td style="text-align: left;">smooth</td>
<td style="text-align: left;">enable curve interpolation, default off (always on if per-vertex radius is used)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">vec3fa[] / vec4f[]</td>
<td style="text-align: left;">vertex</td>
<td style="text-align: left;"><a href="#data">data</a> array of all vertex position (and optional radius) for <em>all</em> streamlines</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec4f[]</td>
<td style="text-align: left;">vertex.color</td>
<td style="text-align: left;"><a href="#data">data</a> array of corresponding vertex colors (RGBA)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float[]</td>
<td style="text-align: left;">vertex.radius</td>
<td style="text-align: left;"><a href="#data">data</a> array of corresponding vertex radius</td>
</tr>
<tr class="even">
<td style="text-align: left;">int32[]</td>
<td style="text-align: left;">index</td>
<td style="text-align: left;"><a href="#data">data</a> array of indices to the first vertex of a link</td>
</tr>
</tbody>
</table>
<p>Each streamline is specified by a set of (aligned) control points in <code>vertex</code>. If <code>smooth</code> is disabled and a constant <code>radius</code> is used for all streamlines then all vertices belonging to to the same logical streamline are connected via <a href="#cylinders">cylinders</a>, with additional <a href="#spheres">spheres</a> at each vertex to create a continuous, closed surface. Otherwise, streamlines are represented as Bézier curves, smoothly interpolating the vertices. This mode supports per-vertex varying radii (either given in <code>vertex.radius</code>, or in the 4th component of a <em>vec4f</em> <code>vertex</code>), but is slower and consumes more memory. Also, the radius needs to be smaller than the curvature radius of the Bézier curve at each location on the curve.</p>
<p>A streamlines geometry can contain multiple disjoint streamlines, each streamline is specified as a list of segments (or links) referenced via <code>index</code>: each entry <code>e</code> of the <code>index</code> array points the first vertex of a link (<code>vertex[index[e]]</code>) and the second vertex of the link is implicitly the directly following one (<code>vertex[index[e]+1]</code>). For example, two streamlines of vertices <code>(A-B-C-D)</code> and <code>(E-F-G)</code>, respectively, would internally correspond to five links (<code>A-B</code>, <code>B-C</code>, <code>C-D</code>, <code>E-F</code>, and <code>F-G</code>), and would be specified via an array of vertices <code>[A,B,C,D,E,F,G]</code>, plus an array of link indices <code>[0,1,2,4,5]</code>.</p>
<h3 id="curves">Curves</h3>
<p>A geometry consisting of multiple curves is created by calling <code>ospNewGeometry</code> with type string “<code>curves</code>”. The parameters defining this geometry are listed in the table below.</p>
<table style="width:97%;">
<caption>Parameters defining a curves geometry.</caption>
<colgroup>
<col style="width: 22%" />
<col style="width: 22%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">string</td>
<td style="text-align: left;">curveType</td>
<td style="text-align: left;">“flat” (ray oriented), “round” (circular cross section), “ribbon” (normal oriented flat curve)</td>
</tr>
<tr class="even">
<td style="text-align: left;">string</td>
<td style="text-align: left;">curveBasis</td>
<td style="text-align: left;">“linear”, “bezier”, “bspline”, “hermite”</td>
</tr>
<tr class="odd">
<td style="text-align: left;">vec4f[]</td>
<td style="text-align: left;">vertex</td>
<td style="text-align: left;"><a href="#data">data</a> array of vertex position and radius</td>
</tr>
<tr class="even">
<td style="text-align: left;">int32[]</td>
<td style="text-align: left;">index</td>
<td style="text-align: left;"><a href="#data">data</a> array of indices to the first vertex or tangent of a curve segment</td>
</tr>
<tr class="odd">
<td style="text-align: left;">vec3f[]</td>
<td style="text-align: left;">vertex.normal</td>
<td style="text-align: left;"><a href="#data">data</a> array of curve normals (only for “ribbon” curves)</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec3f[]</td>
<td style="text-align: left;">vertex.tangent</td>
<td style="text-align: left;"><a href="#data">data</a> array of curve tangents (only for “hermite” curves)</td>
</tr>
</tbody>
</table>
<p>See Embree documentation for discussion of curve types and data formatting.</p>
<h3 id="isosurfaces">Isosurfaces</h3>
<p>OSPRay can directly render multiple isosurfaces of a volume without first tessellating them. To do so create an isosurfaces geometry by calling <code>ospNewGeometry</code> with type string “<code>isosurfaces</code>”. Each isosurface will be colored according to the provided volume’s <a href="#transfer-function">transfer function</a>.</p>
<table>
<caption>Parameters defining an isosurfaces geometry.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">float[]</td>
<td style="text-align: left;">isovalues</td>
<td style="text-align: left;"><a href="#data">data</a> array of isovalues</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSPVolume</td>
<td style="text-align: left;">volume</td>
<td style="text-align: left;">handle of the <a href="#volumes">volume</a> to be isosurfaced</td>
</tr>
</tbody>
</table>
<h3 id="slices">Slices</h3>
<p>One tool to highlight interesting features of volumetric data is to visualize 2D cuts (or slices) by placing planes into the volume. Such a slices geometry is created by calling <code>ospNewGeometry</code> with type string “<code>slices</code>”. The planes are defined by the coefficients <span class="math inline">(<em>a</em>, <em>b</em>, <em>c</em>, <em>d</em>)</span> of the plane equation <span class="math inline"><em>a</em><em>x</em> + <em>b</em><em>y</em> + <em>c</em><em>z</em> + <em>d</em> = 0</span>. Each slice is colored according to the provided volume’s <a href="#transfer-function">transfer function</a>.</p>
<table>
<caption>Parameters defining a slices geometry.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">vec4f[]</td>
<td style="text-align: left;">planes</td>
<td style="text-align: left;"><a href="#data">data</a> array with plane coefficients for all slices</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSPVolume</td>
<td style="text-align: left;">volume</td>
<td style="text-align: left;">handle of the <a href="#volumes">volume</a> that will be sliced</td>
</tr>
</tbody>
</table>
<h3 id="instances">Instances</h3>
<p>OSPRay supports instancing via a special type of geometry. Instances are created by transforming another given <a href="#model">model</a> <code>modelToInstantiate</code> with the given affine transformation <code>transform</code> by calling</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb27-1" title="1">OSPGeometry ospNewInstance(OSPModel modelToInstantiate, <span class="at">const</span> affine3f &amp;transform);</a></code></pre></div>
<h2 id="renderer">Renderer</h2>
<p>A renderer is the central object for rendering in OSPRay. Different renderers implement different features and support different materials. To create a new renderer of given type <code>type</code> use</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb28-1" title="1">OSPRenderer ospNewRenderer(<span class="at">const</span> <span class="dt">char</span> *type);</a></code></pre></div>
<p>The call returns <code>NULL</code> if that type of renderer is not known, or else an <code>OSPRenderer</code> handle to the created renderer. General parameters of all renderers are</p>
<table style="width:98%;">
<caption>Parameters understood by all renderers.</caption>
<colgroup>
<col style="width: 18%" />
<col style="width: 24%" />
<col style="width: 12%" />
<col style="width: 42%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: right;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">OSPModel</td>
<td style="text-align: left;">model</td>
<td style="text-align: right;"></td>
<td style="text-align: left;">the <a href="#model">model</a> to render</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSPCamera</td>
<td style="text-align: left;">camera</td>
<td style="text-align: right;"></td>
<td style="text-align: left;">the <a href="#cameras">camera</a> to be used for rendering</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSPLight[]</td>
<td style="text-align: left;">lights</td>
<td style="text-align: right;"></td>
<td style="text-align: left;"><a href="#data">data</a> array with handles of the <a href="#lights">lights</a></td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">epsilon</td>
<td style="text-align: right;">10<sup>-6</sup></td>
<td style="text-align: left;">ray epsilon to avoid self-intersections, relative to scene diameter</td>
</tr>
<tr class="odd">
<td style="text-align: left;">int</td>
<td style="text-align: left;">spp</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">samples per pixel</td>
</tr>
<tr class="even">
<td style="text-align: left;">int</td>
<td style="text-align: left;">maxDepth</td>
<td style="text-align: right;">20</td>
<td style="text-align: left;">maximum ray recursion depth</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">minContribution</td>
<td style="text-align: right;">0.001</td>
<td style="text-align: left;">sample contributions below this value will be neglected to speed-up rendering</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">varianceThreshold</td>
<td style="text-align: right;">0</td>
<td style="text-align: left;">threshold for adaptive accumulation</td>
</tr>
</tbody>
</table>
<p>OSPRay’s renderers support a feature called adaptive accumulation, which accelerates progressive <a href="#rendering">rendering</a> by stopping the rendering and refinement of image regions that have an estimated variance below the <code>varianceThreshold</code>. This feature requires a <a href="#framebuffer">framebuffer</a> with an <code>OSP_FB_VARIANCE</code> channel.</p>
<h3 id="scivis-renderer">SciVis Renderer</h3>
<p>The SciVis renderer is a fast ray tracer for scientific visualization which supports volume rendering and ambient occlusion (AO). It is created by passing the type string “<code>scivis</code>” or “<code>raytracer</code>” to <code>ospNewRenderer</code>. In addition to the <a href="#renderer">general parameters</a> understood by all renderers the SciVis renderer supports the following special parameters:</p>
<table style="width:97%;">
<caption>Special parameters understood by the SciVis renderer.</caption>
<colgroup>
<col style="width: 16%" />
<col style="width: 30%" />
<col style="width: 17%" />
<col style="width: 32%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: right;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">bool</td>
<td style="text-align: left;">shadowsEnabled</td>
<td style="text-align: right;">false</td>
<td style="text-align: left;">whether to compute (hard) shadows</td>
</tr>
<tr class="even">
<td style="text-align: left;">int</td>
<td style="text-align: left;">aoSamples</td>
<td style="text-align: right;">0</td>
<td style="text-align: left;">number of rays per sample to compute ambient occlusion</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">aoDistance</td>
<td style="text-align: right;">10<sup>20</sup></td>
<td style="text-align: left;">maximum distance to consider for ambient occlusion</td>
</tr>
<tr class="even">
<td style="text-align: left;">bool</td>
<td style="text-align: left;">aoTransparencyEnabled</td>
<td style="text-align: right;">false</td>
<td style="text-align: left;">whether object transparency is respected when computing ambient occlusion (slower)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">bool</td>
<td style="text-align: left;">oneSidedLighting</td>
<td style="text-align: right;">true</td>
<td style="text-align: left;">if true back-facing surfaces (wrt. light source) receive no illumination</td>
</tr>
<tr class="even">
<td style="text-align: left;">float / vec3f / vec4f</td>
<td style="text-align: left;">bgColor</td>
<td style="text-align: right;">black, transparent</td>
<td style="text-align: left;">background color and alpha (RGBA)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSPTexture</td>
<td style="text-align: left;">maxDepthTexture</td>
<td style="text-align: right;">NULL</td>
<td style="text-align: left;">screen-sized float <a href="#texture">texture</a> with maximum far distance per pixel (use texture type ‘texture2d’)</td>
</tr>
</tbody>
</table>
<p>Note that the intensity (and color) of AO is deduced from an <a href="#ambient-light">ambient light</a> in the <code>lights</code> array.<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a> If <code>aoSamples</code> is zero (the default) then ambient lights cause ambient illumination (without occlusion).</p>
<p>Per default the background of the rendered image will be transparent black, i.e. the alpha channel holds the opacity of the rendered objects. This facilitates transparency-aware blending of the image with an arbitrary background image by the application. The parameter <code>bgColor</code> can be used to already blend with a constant background color (and alpha) during rendering.</p>
<p>The SciVis renderer supports depth composition with images of other renderers, for example to incorporate help geometries of a 3D UI that were rendered with OpenGL. The screen-sized <a href="#texture">texture</a> <code>maxDepthTexture</code> must have format <code>OSP_TEXTURE_R32F</code> and flag <code>OSP_TEXTURE_FILTER_NEAREST</code>. The fetched values are used to limit the distance of primary rays, thus objects of other renderers can hide objects rendered by OSPRay.</p>
<h3 id="path-tracer">Path Tracer</h3>
<p>The path tracer supports soft shadows, indirect illumination and realistic materials. This renderer is created by passing the type string “<code>pathtracer</code>” to <code>ospNewRenderer</code>. In addition to the <a href="#renderer">general parameters</a> understood by all renderers the path tracer supports the following special parameters:</p>
<table style="width:97%;">
<caption>Special parameters understood by the path tracer.</caption>
<colgroup>
<col style="width: 16%" />
<col style="width: 23%" />
<col style="width: 12%" />
<col style="width: 44%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: right;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">int</td>
<td style="text-align: left;">rouletteDepth</td>
<td style="text-align: right;">5</td>
<td style="text-align: left;">ray recursion depth at which to start Russian roulette termination</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">maxContribution</td>
<td style="text-align: right;">∞</td>
<td style="text-align: left;">samples are clamped to this value before they are accumulated into the framebuffer</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSPTexture</td>
<td style="text-align: left;">backplate</td>
<td style="text-align: right;">NULL</td>
<td style="text-align: left;"><a href="#texture">texture</a> image used as background, replacing visible lights in infinity (e.g. the <a href="#hdri-light">HDRI light</a>)</td>
</tr>
</tbody>
</table>
<p>The path tracer requires that <a href="#materials">materials</a> are assigned to <a href="#geometries">geometries</a>, otherwise surfaces are treated as completely black.</p>
<h3 id="model">Model</h3>
<p>Models are a container of scene data. They can hold the different <a href="#geometries">geometries</a> and <a href="#volumes">volumes</a> as well as references to (and <a href="#instances">instances</a> of) other models. A model is associated with a single logical acceleration structure. To create an (empty) model call</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb29-1" title="1">OSPModel ospNewModel();</a></code></pre></div>
<p>The call returns an <code>OSPModel</code> handle to the created model. To add an already created geometry or volume to a model use</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb30-1" title="1"><span class="dt">void</span> ospAddGeometry(OSPModel, OSPGeometry);</a>
<a class="sourceLine" id="cb30-2" title="2"><span class="dt">void</span> ospAddVolume(OSPModel, OSPVolume);</a></code></pre></div>
<p>An existing geometry or volume can be removed from a model with</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb31-1" title="1"><span class="dt">void</span> ospRemoveGeometry(OSPModel, OSPGeometry);</a>
<a class="sourceLine" id="cb31-2" title="2"><span class="dt">void</span> ospRemoveVolume(OSPModel, OSPVolume);</a></code></pre></div>
<p>Finally, Models can be configured with parameters for making various feature/performance trade-offs:</p>
<table style="width:97%;">
<caption>Parameters understood by Models</caption>
<colgroup>
<col style="width: 17%" />
<col style="width: 20%" />
<col style="width: 13%" />
<col style="width: 45%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: right;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">bool</td>
<td style="text-align: left;">dynamicScene</td>
<td style="text-align: right;">false</td>
<td style="text-align: left;">use RTC_SCENE_DYNAMIC flag (faster BVH build, slower ray traversal), otherwise uses RTC_SCENE_STATIC flag (faster ray traversal, slightly slower BVH build)</td>
</tr>
<tr class="even">
<td style="text-align: left;">bool</td>
<td style="text-align: left;">compactMode</td>
<td style="text-align: right;">false</td>
<td style="text-align: left;">tell Embree to use a more compact BVH in memory by trading ray traversal performance</td>
</tr>
<tr class="odd">
<td style="text-align: left;">bool</td>
<td style="text-align: left;">robustMode</td>
<td style="text-align: right;">false</td>
<td style="text-align: left;">tell Embree to enable more robust ray intersection code paths (slightly slower)</td>
</tr>
</tbody>
</table>
<h3 id="lights">Lights</h3>
<p>To create a new light source of given type <code>type</code> use</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb32-1" title="1">OSPLight ospNewLight3(<span class="at">const</span> <span class="dt">char</span> *type);</a></code></pre></div>
<p>The call returns <code>NULL</code> if that type of light is not known by the renderer, or else an <code>OSPLight</code> handle to the created light source. All light sources<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a> accept the following parameters:</p>
<table>
<caption>Parameters accepted by all lights.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: right;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">vec3f(a)</td>
<td style="text-align: left;">color</td>
<td style="text-align: right;">white</td>
<td style="text-align: left;">color of the light</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">intensity</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">intensity of the light (a factor)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">bool</td>
<td style="text-align: left;">isVisible</td>
<td style="text-align: right;">true</td>
<td style="text-align: left;">whether the light can be directly seen</td>
</tr>
</tbody>
</table>
<p>The following light types are supported by most OSPRay renderers.</p>
<h4 id="directional-light-distant-light">Directional Light / Distant Light</h4>
<p>The distant light (or traditionally the directional light) is thought to be very far away (outside of the scene), thus its light arrives (almost) as parallel rays. It is created by passing the type string “<code>distant</code>” to <code>ospNewLight3</code>. In addition to the <a href="#lights">general parameters</a> understood by all lights the distant light supports the following special parameters:</p>
<table>
<caption>Special parameters accepted by the distant light.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">vec3f(a)</td>
<td style="text-align: left;">direction</td>
<td style="text-align: left;">main emission direction of the distant light</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">angularDiameter</td>
<td style="text-align: left;">apparent size (angle in degree) of the light</td>
</tr>
</tbody>
</table>
<p>Setting the angular diameter to a value greater than zero will result in soft shadows when the renderer uses stochastic sampling (like the <a href="#path-tracer">path tracer</a>). For instance, the apparent size of the sun is about 0.53°.</p>
<h4 id="point-light-sphere-light">Point Light / Sphere Light</h4>
<p>The sphere light (or the special case point light) is a light emitting uniformly in all directions. It is created by passing the type string “<code>sphere</code>” to <code>ospNewLight3</code>. In addition to the <a href="#lights">general parameters</a> understood by all lights the sphere light supports the following special parameters:</p>
<table>
<caption>Special parameters accepted by the sphere light.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">vec3f(a)</td>
<td style="text-align: left;">position</td>
<td style="text-align: left;">the center of the sphere light, in world-space</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">radius</td>
<td style="text-align: left;">the size of the sphere light</td>
</tr>
</tbody>
</table>
<p>Setting the radius to a value greater than zero will result in soft shadows when the renderer uses stochastic sampling (like the <a href="#path-tracer">path tracer</a>).</p>
<h4 id="spot-light">Spot Light</h4>
<p>The spot light is a light emitting into a cone of directions. It is created by passing the type string “<code>spot</code>” to <code>ospNewLight3</code>. In addition to the <a href="#lights">general parameters</a> understood by all lights the spot light supports the special parameters listed in the table.</p>
<table style="width:97%;">
<caption>Special parameters accepted by the spot light.</caption>
<colgroup>
<col style="width: 14%" />
<col style="width: 21%" />
<col style="width: 61%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">vec3f(a)</td>
<td style="text-align: left;">position</td>
<td style="text-align: left;">the center of the spot light, in world-space</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec3f(a)</td>
<td style="text-align: left;">direction</td>
<td style="text-align: left;">main emission direction of the spot</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">openingAngle</td>
<td style="text-align: left;">full opening angle (in degree) of the spot; outside of this cone is no illumination</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">penumbraAngle</td>
<td style="text-align: left;">size (angle in degree) of the “penumbra”, the region between the rim (of the illumination cone) and full intensity of the spot; should be smaller than half of <code>openingAngle</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">radius</td>
<td style="text-align: left;">the size of the spot light, the radius of a disk with normal <code>direction</code></td>
</tr>
</tbody>
</table>
<figure>
<img src="images/spot_light.png" alt="Angles used by the spot light." /><figcaption>Angles used by the spot light.</figcaption>
</figure>
<p>Setting the radius to a value greater than zero will result in soft shadows when the renderer uses stochastic sampling (like the <a href="#path-tracer">path tracer</a>).</p>
<h4 id="quad-light">Quad Light</h4>
<p>The quad<a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a> light is a planar, procedural area light source emitting uniformly on one side into the half space. It is created by passing the type string “<code>quad</code>” to <code>ospNewLight3</code>. In addition to the <a href="#lights">general parameters</a> understood by all lights the quad light supports the following special parameters:</p>
<table>
<caption>Special parameters accepted by the quad light.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">vec3f(a)</td>
<td style="text-align: left;">position</td>
<td style="text-align: left;">world-space position of one vertex of the quad light</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec3f(a)</td>
<td style="text-align: left;">edge1</td>
<td style="text-align: left;">vector to one adjacent vertex</td>
</tr>
<tr class="odd">
<td style="text-align: left;">vec3f(a)</td>
<td style="text-align: left;">edge2</td>
<td style="text-align: left;">vector to the other adjacent vertex</td>
</tr>
</tbody>
</table>
<figure>
<img src="images/quad_light.png" alt="Defining a quad light which emits towards the reader." /><figcaption>Defining a quad light which emits towards the reader.</figcaption>
</figure>
<p>The emission side is determined by the cross product of <code>edge1</code>×<code>edge2</code>. Note that only renderers that use stochastic sampling (like the path tracer) will compute soft shadows from the quad light. Other renderers will just sample the center of the quad light, which results in hard shadows.</p>
<h4 id="hdri-light">HDRI Light</h4>
<p>The HDRI light is a textured light source surrounding the scene and illuminating it from infinity. It is created by passing the type string “<code>hdri</code>” to <code>ospNewLight3</code>. In addition to the <a href="#lights">parameter <code>intensity</code></a> the HDRI light supports the following special parameters:</p>
<table style="width:97%;">
<caption>Special parameters accepted by the HDRI light.</caption>
<colgroup>
<col style="width: 17%" />
<col style="width: 9%" />
<col style="width: 69%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">vec3f(a)</td>
<td style="text-align: left;">up</td>
<td style="text-align: left;">up direction of the light in world-space</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec3f(a)</td>
<td style="text-align: left;">dir</td>
<td style="text-align: left;">direction to which the center of the texture will be mapped to (analog to <a href="#panoramic-camera">panoramic camera</a>)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSPTexture</td>
<td style="text-align: left;">map</td>
<td style="text-align: left;">environment map in latitude / longitude format</td>
</tr>
</tbody>
</table>
<figure>
<img src="images/hdri_light.png" alt="Orientation and Mapping of an HDRI Light." /><figcaption>Orientation and Mapping of an HDRI Light.</figcaption>
</figure>
<p>Note that the currently only the <a href="#path-tracer">path tracer</a> supports the HDRI light.</p>
<h4 id="ambient-light">Ambient Light</h4>
<p>The ambient light surrounds the scene and illuminates it from infinity with constant radiance (determined by combining the <a href="#lights">parameters <code>color</code> and <code>intensity</code></a>). It is created by passing the type string “<code>ambient</code>” to <code>ospNewLight3</code>.</p>
<p>Note that the <a href="#scivis-renderer">SciVis renderer</a> uses ambient lights to control the color and intensity of the computed ambient occlusion (AO).</p>
<h4 id="emissive-objects">Emissive Objects</h4>
<p>The <a href="#path-tracer">path tracer</a> will consider illumination by <a href="#geometries">geometries</a> which have a light emitting material assigned (for example the <a href="#luminous">Luminous</a> material).</p>
<h3 id="materials">Materials</h3>
<p>Materials describe how light interacts with surfaces, they give objects their distinctive look. To let the given renderer create a new material of given type <code>type</code> call</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb33-1" title="1">OSPMaterial ospNewMaterial2(<span class="at">const</span> <span class="dt">char</span> *<span class="dt">renderer_type</span>, <span class="at">const</span> <span class="dt">char</span> *<span class="dt">material_type</span>);</a></code></pre></div>
<p>The call returns <code>NULL</code> if the material type is not known by the renderer type, or else an <code>OSPMaterial</code> handle to the created material. The handle can then be used to assign the material to a given geometry with</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb34-1" title="1"><span class="dt">void</span> ospSetMaterial(OSPGeometry, OSPMaterial);</a></code></pre></div>
<h4 id="obj-material">OBJ Material</h4>
<p>The OBJ material is the workhorse material supported by both the <a href="#scivis-renderer">SciVis renderer</a> and the <a href="#path-tracer">path tracer</a>. It offers widely used common properties like diffuse and specular reflection and is based on the <a href="http://paulbourke.net/dataformats/mtl/">MTL material format</a> of Lightwave’s OBJ scene files. To create an OBJ material pass the type string “<code>OBJMaterial</code>” to <code>ospNewMaterial2</code>. Its main parameters are</p>
<table>
<caption>Main parameters of the OBJ material.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: right;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">Kd</td>
<td style="text-align: right;">white 0.8</td>
<td style="text-align: left;">diffuse color</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">Ks</td>
<td style="text-align: right;">black</td>
<td style="text-align: left;">specular color</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">Ns</td>
<td style="text-align: right;">10</td>
<td style="text-align: left;">shininess (Phong exponent), usually in [2–10<sup>4</sup>]</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">d</td>
<td style="text-align: right;">opaque</td>
<td style="text-align: left;">opacity</td>
</tr>
<tr class="odd">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">Tf</td>
<td style="text-align: right;">black</td>
<td style="text-align: left;">transparency filter color</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSPTexture</td>
<td style="text-align: left;">map_Bump</td>
<td style="text-align: right;">NULL</td>
<td style="text-align: left;">normal map</td>
</tr>
</tbody>
</table>
<p>In particular when using the path tracer it is important to adhere to the principle of energy conservation, i.e. that the amount of light reflected by a surface is not larger than the light arriving. Therefore the path tracer issues a warning and renormalizes the color parameters if the sum of <code>Kd</code>, <code>Ks</code>, and <code>Tf</code> is larger than one in any color channel. Similarly important to mention is that almost all materials of the real world reflect at most only about 80% of the incoming light. So even for a white sheet of paper or white wall paint do better not set <code>Kd</code> larger than 0.8; otherwise rendering times are unnecessary long and the contrast in the final images is low (for example, the corners of a white room would hardly be discernible, as can be seen in the figure below).</p>
<figure>
<img src="images/diffuse_rooms.png" alt="Comparison of diffuse rooms with 100% reflecting white paint (left) and realistic 80% reflecting white paint (right), which leads to higher overall contrast. Note that exposure has been adjusted to achieve similar brightness levels." style="width:80.0%" /><figcaption>Comparison of diffuse rooms with 100% reflecting white paint (left) and realistic 80% reflecting white paint (right), which leads to higher overall contrast. Note that exposure has been adjusted to achieve similar brightness levels.</figcaption>
</figure>
<p>If present, the color component of <a href="#geometries">geometries</a> is also used for the diffuse color <code>Kd</code> and the alpha component is also used for the opacity <code>d</code>.</p>
<p>Note that currently only the path tracer implements colored transparency with <code>Tf</code>.</p>
<p>Normal mapping can simulate small geometric features via the texture <code>map_Bump</code>. The normals <span class="math inline"><em>n</em></span> in the normal map are wrt. the local tangential shading coordinate system and are encoded as <span class="math inline">½(<em>n</em> + 1)</span>, thus a texel <span class="math inline">(0.5, 0.5, 1)</span><a href="#fn5" class="footnote-ref" id="fnref5"><sup>5</sup></a> represents the unperturbed shading normal <span class="math inline">(0, 0, 1)</span>. Because of this encoding an sRGB gamma <a href="#texture">texture</a> format is ignored and normals are always fetched as linear from a normal map. Note that the orientation of normal maps is important for a visually consistent look: by convention OSPRay uses a coordinate system with the origin in the lower left corner; thus a convexity will look green towards the top of the texture image (see also the example image of a normal map). If this is not the case flip the normal map vertically or invert its green channel.</p>
<figure>
<img src="images/normalmap_frustum.png" alt="Normal map representing an exalted square pyramidal frustum." style="width:60.0%" /><figcaption>Normal map representing an exalted square pyramidal frustum.</figcaption>
</figure>
<p>All parameters (except <code>Tf</code>) can be textured by passing a <a href="#texture">texture</a> handle, prefixed with “<code>map_</code>”. The fetched texels are multiplied by the respective parameter value. Texturing requires <a href="#geometries">geometries</a> with texture coordinates, e.g. a <a href="#triangle-mesh">triangle mesh</a> with <code>vertex.texcoord</code> provided. The color textures <code>map_Kd</code> and <code>map_Ks</code> are typically in one of the sRGB gamma encoded formats, whereas textures <code>map_Ns</code> and <code>map_d</code> are usually in a linear format (and only the first component is used). Additionally, all textures support <a href="#texture2d-transformations">texture transformations</a>.</p>
<figure>
<img src="images/material_OBJ.jpg" alt="Rendering of a OBJ material with wood textures." style="width:60.0%" /><figcaption>Rendering of a OBJ material with wood textures.</figcaption>
</figure>
<h4 id="principled">Principled</h4>
<p>The Principled material is the most complex material offered by the <a href="#path-tracer">path tracer</a>, which is capable of producing a wide variety of materials (e.g., plastic, metal, wood, glass) by combining multiple different layers and lobes. It uses the GGX microfacet distribution with approximate multiple scattering for dielectrics and metals, uses the Oren-Nayar model for diffuse reflection, and is energy conserving. To create a Principled material, pass the type string “<code>Principled</code>” to <code>ospNewMaterial2</code>. Its parameters are listed in the table below.</p>
<table style="width:98%;">
<caption>Parameters of the Principled material.</caption>
<colgroup>
<col style="width: 9%" />
<col style="width: 24%" />
<col style="width: 12%" />
<col style="width: 51%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: right;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">baseColor</td>
<td style="text-align: right;">white 0.8</td>
<td style="text-align: left;">base reflectivity (diffuse and/or metallic)</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">edgeColor</td>
<td style="text-align: right;">white</td>
<td style="text-align: left;">edge tint (metallic only)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">metallic</td>
<td style="text-align: right;">0</td>
<td style="text-align: left;">mix between dielectric (diffuse and/or specular) and metallic (specular only with complex IOR) in [0–1]</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">diffuse</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">diffuse reflection weight in [0–1]</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">specular</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">specular reflection/transmission weight in [0–1]</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">ior</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">dielectric index of refraction</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">transmission</td>
<td style="text-align: right;">0</td>
<td style="text-align: left;">specular transmission weight in [0–1]</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">transmissionColor</td>
<td style="text-align: right;">white</td>
<td style="text-align: left;">attenuated color due to transmission (Beer’s law)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">transmissionDepth</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">distance at which color attenuation is equal to transmissionColor</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">roughness</td>
<td style="text-align: right;">0</td>
<td style="text-align: left;">diffuse and specular roughness in [0–1], 0 is perfectly smooth</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">anisotropy</td>
<td style="text-align: right;">0</td>
<td style="text-align: left;">amount of specular anisotropy in [0–1]</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">rotation</td>
<td style="text-align: right;">0</td>
<td style="text-align: left;">rotation of the direction of anisotropy in [0–1], 1 is going full circle</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">normal</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">default normal map/scale for all layers</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">baseNormal</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">base normal map/scale (overrides default normal)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">bool</td>
<td style="text-align: left;">thin</td>
<td style="text-align: right;">false</td>
<td style="text-align: left;">flag specifying whether the material is thin or solid</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">thickness</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">thickness of the material (thin only), affects the amount of color attenuation due to specular transmission</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">backlight</td>
<td style="text-align: right;">0</td>
<td style="text-align: left;">amount of diffuse transmission (thin only) in [0–2], 1 is 50% reflection and 50% transmission, 2 is transmission only</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">coat</td>
<td style="text-align: right;">0</td>
<td style="text-align: left;">clear coat layer weight in [0–1]</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">coatIor</td>
<td style="text-align: right;">1.5</td>
<td style="text-align: left;">clear coat index of refraction</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">coatColor</td>
<td style="text-align: right;">white</td>
<td style="text-align: left;">clear coat color tint</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">coatThickness</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">clear coat thickness, affects the amount of color attenuation</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">coatRoughness</td>
<td style="text-align: right;">0</td>
<td style="text-align: left;">clear coat roughness in [0–1], 0 is perfectly smooth</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">coatNormal</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">clear coat normal map/scale (overrides default normal)</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">sheen</td>
<td style="text-align: right;">0</td>
<td style="text-align: left;">sheen layer weight in [0–1]</td>
</tr>
<tr class="odd">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">sheenColor</td>
<td style="text-align: right;">white</td>
<td style="text-align: left;">sheen color tint</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">sheenTint</td>
<td style="text-align: right;">0</td>
<td style="text-align: left;">how much sheen is tinted from sheenColor towards baseColor</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">sheenRoughness</td>
<td style="text-align: right;">0.2</td>
<td style="text-align: left;">sheen roughness in [0–1], 0 is perfectly smooth</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">opacity</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">cut-out opacity/transparency, 1 is fully opaque</td>
</tr>
</tbody>
</table>
<p>All parameters can be textured by passing a <a href="#texture">texture</a> handle, suffixed with “<code>Map</code>” (e.g., “<code>baseColorMap</code>”); <a href="#texture2d-transformations">texture transformations</a> are supported as well.</p>
<figure>
<img src="images/material_Principled.jpg" alt="Rendering of a Principled coated brushed metal material with textured anisotropic rotation and a dust layer (sheen) on top." style="width:60.0%" /><figcaption>Rendering of a Principled coated brushed metal material with textured anisotropic rotation and a dust layer (sheen) on top.</figcaption>
</figure>
<h4 id="carpaint">CarPaint</h4>
<p>The CarPaint material is a specialized version of the Principled material for rendering different types of car paints. To create a CarPaint material, pass the type string “<code>CarPaint</code>” to <code>ospNewMaterial2</code>. Its parameters are listed in the table below.</p>
<table style="width:98%;">
<caption>Parameters of the CarPaint material.</caption>
<colgroup>
<col style="width: 10%" />
<col style="width: 22%" />
<col style="width: 12%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: right;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">baseColor</td>
<td style="text-align: right;">white 0.8</td>
<td style="text-align: left;">diffuse base reflectivity</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">roughness</td>
<td style="text-align: right;">0</td>
<td style="text-align: left;">diffuse roughness in [0–1], 0 is perfectly smooth</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">normal</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">normal map/scale</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">flakeDensity</td>
<td style="text-align: right;">0</td>
<td style="text-align: left;">density of metallic flakes in [0–1], 0 disables flakes, 1 fully covers the surface with flakes</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">flakeScale</td>
<td style="text-align: right;">100</td>
<td style="text-align: left;">scale of the flake structure, higher values increase the amount of flakes</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">flakeSpread</td>
<td style="text-align: right;">0.3</td>
<td style="text-align: left;">flake spread in [0–1]</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">flakeJitter</td>
<td style="text-align: right;">0.75</td>
<td style="text-align: left;">flake randomness in [0–1]</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">flakeRoughness</td>
<td style="text-align: right;">0.3</td>
<td style="text-align: left;">flake roughness in [0–1], 0 is perfectly smooth</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">coat</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">clear coat layer weight in [0–1]</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">coatIor</td>
<td style="text-align: right;">1.5</td>
<td style="text-align: left;">clear coat index of refraction</td>
</tr>
<tr class="odd">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">coatColor</td>
<td style="text-align: right;">white</td>
<td style="text-align: left;">clear coat color tint</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">coatThickness</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">clear coat thickness, affects the amount of color attenuation</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">coatRoughness</td>
<td style="text-align: right;">0</td>
<td style="text-align: left;">clear coat roughness in [0–1], 0 is perfectly smooth</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">coatNormal</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">clear coat normal map/scale</td>
</tr>
<tr class="odd">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">flipflopColor</td>
<td style="text-align: right;">white</td>
<td style="text-align: left;">reflectivity of coated flakes at grazing angle, used together with coatColor produces a pearlescent paint</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">flipflopFalloff</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">flip flop color falloff, 1 disables the flip flop effect</td>
</tr>
</tbody>
</table>
<p>All parameters can be textured by passing a <a href="#texture">texture</a> handle, suffixed with “<code>Map</code>” (e.g., “<code>baseColorMap</code>”); <a href="#texture2d-transformations">texture transformations</a> are supported as well.</p>
<figure>
<img src="images/material_CarPaint.jpg" alt="Rendering of a pearlescent CarPaint material." style="width:60.0%" /><figcaption>Rendering of a pearlescent CarPaint material.</figcaption>
</figure>
<h4 id="metal">Metal</h4>
<p>The <a href="#path-tracer">path tracer</a> offers a physical metal, supporting changing roughness and realistic color shifts at edges. To create a Metal material pass the type string “<code>Metal</code>” to <code>ospNewMaterial2</code>. Its parameters are</p>
<table style="width:97%;">
<caption>Parameters of the Metal material.</caption>
<colgroup>
<col style="width: 15%" />
<col style="width: 15%" />
<col style="width: 15%" />
<col style="width: 51%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: right;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">vec3f[]</td>
<td style="text-align: left;">ior</td>
<td style="text-align: right;">Aluminium</td>
<td style="text-align: left;"><a href="#data">data</a> array of spectral samples of complex refractive index, each entry in the form (wavelength, eta, k), ordered by wavelength (which is in nm)</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">eta</td>
<td style="text-align: right;"></td>
<td style="text-align: left;">RGB complex refractive index, real part</td>
</tr>
<tr class="odd">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">k</td>
<td style="text-align: right;"></td>
<td style="text-align: left;">RGB complex refractive index, imaginary part</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">roughness</td>
<td style="text-align: right;">0.1</td>
<td style="text-align: left;">roughness in [0–1], 0 is perfect mirror</td>
</tr>
</tbody>
</table>
<p>The main appearance (mostly the color) of the Metal material is controlled by the physical parameters <code>eta</code> and <code>k</code>, the wavelength-dependent, complex index of refraction. These coefficients are quite counterintuitive but can be found in <a href="https://refractiveindex.info/">published measurements</a>. For accuracy the index of refraction can be given as an array of spectral samples in <code>ior</code>, each sample a triplet of wavelength (in nm), eta, and k, ordered monotonically increasing by wavelength; OSPRay will then calculate the Fresnel in the spectral domain. Alternatively, <code>eta</code> and <code>k</code> can also be specified as approximated RGB coefficients; some examples are given in below table.</p>
<table>
<caption>Index of refraction of selected metals as approximated RGB coefficients, based on data from https://refractiveindex.info/.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Metal</th>
<th style="text-align: center;">eta</th>
<th style="text-align: center;">k</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Ag, Silver</td>
<td style="text-align: center;">(0.051, 0.043, 0.041)</td>
<td style="text-align: center;">(5.3, 3.6, 2.3)</td>
</tr>
<tr class="even">
<td style="text-align: left;">Al, Aluminium</td>
<td style="text-align: center;">(1.5, 0.98, 0.6)</td>
<td style="text-align: center;">(7.6, 6.6, 5.4)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Au, Gold</td>
<td style="text-align: center;">(0.07, 0.37, 1.5)</td>
<td style="text-align: center;">(3.7, 2.3, 1.7)</td>
</tr>
<tr class="even">
<td style="text-align: left;">Cr, Chromium</td>
<td style="text-align: center;">(3.2, 3.1, 2.3)</td>
<td style="text-align: center;">(3.3, 3.3, 3.1)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Cu, Copper</td>
<td style="text-align: center;">(0.1, 0.8, 1.1)</td>
<td style="text-align: center;">(3.5, 2.5, 2.4)</td>
</tr>
</tbody>
</table>
<p>The <code>roughness</code> parameter controls the variation of microfacets and thus how polished the metal will look. The roughness can be modified by a <a href="#texture">texture</a> <code>map_roughness</code> (<a href="#texture2d-transformations">texture transformations</a> are supported as well) to create interesting edging effects.</p>
<figure>
<img src="images/material_Metal.jpg" alt="Rendering of golden Metal material with textured roughness." style="width:60.0%" /><figcaption>Rendering of golden Metal material with textured roughness.</figcaption>
</figure>
<h4 id="alloy">Alloy</h4>
<p>The <a href="#path-tracer">path tracer</a> offers an alloy material, which behaves similar to <a href="#metal">Metal</a>, but allows for more intuitive and flexible control of the color. To create an Alloy material pass the type string “<code>Alloy</code>” to <code>ospNewMaterial2</code>. Its parameters are</p>
<table>
<caption>Parameters of the Alloy material.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: right;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">color</td>
<td style="text-align: right;">white 0.9</td>
<td style="text-align: left;">reflectivity at normal incidence (0 degree)</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">edgeColor</td>
<td style="text-align: right;">white</td>
<td style="text-align: left;">reflectivity at grazing angle (90 degree)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">roughness</td>
<td style="text-align: right;">0.1</td>
<td style="text-align: left;">roughness, in [0–1], 0 is perfect mirror</td>
</tr>
</tbody>
</table>
<p>The main appearance of the Alloy material is controlled by the parameter <code>color</code>, while <code>edgeColor</code> influences the tint of reflections when seen at grazing angles (for real metals this is always 100% white). If present, the color component of <a href="#geometries">geometries</a> is also used for reflectivity at normal incidence <code>color</code>. As in <a href="#metal">Metal</a> the <code>roughness</code> parameter controls the variation of microfacets and thus how polished the alloy will look. All parameters can be textured by passing a <a href="#texture">texture</a> handle, prefixed with “<code>map_</code>”; <a href="#texture2d-transformations">texture transformations</a> are supported as well.</p>
<figure>
<img src="images/material_Alloy.jpg" alt="Rendering of a fictional Alloy material with textured color." style="width:60.0%" /><figcaption>Rendering of a fictional Alloy material with textured color.</figcaption>
</figure>
<h4 id="glass">Glass</h4>
<p>The <a href="#path-tracer">path tracer</a> offers a realistic a glass material, supporting refraction and volumetric attenuation (i.e. the transparency color varies with the geometric thickness). To create a Glass material pass the type string “<code>Glass</code>” to <code>ospNewMaterial2</code>. Its parameters are</p>
<table>
<caption>Parameters of the Glass material.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: right;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">eta</td>
<td style="text-align: right;">1.5</td>
<td style="text-align: left;">index of refraction</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">attenuationColor</td>
<td style="text-align: right;">white</td>
<td style="text-align: left;">resulting color due to attenuation</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">attenuationDistance</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">distance affecting attenuation</td>
</tr>
</tbody>
</table>
<p>For convenience, the rather counterintuitive physical attenuation coefficients will be calculated from the user inputs in such a way, that the <code>attenuationColor</code> will be the result when white light traveled trough a glass of thickness <code>attenuationDistance</code>.</p>
<figure>
<img src="images/material_Glass.jpg" alt="Rendering of a Glass material with orange attenuation." style="width:60.0%" /><figcaption>Rendering of a Glass material with orange attenuation.</figcaption>
</figure>
<h4 id="thinglass">ThinGlass</h4>
<p>The <a href="#path-tracer">path tracer</a> offers a thin glass material useful for objects with just a single surface, most prominently windows. It models a very thin, transparent slab, i.e. it behaves as if a second, virtual surface is parallel to the real geometric surface. The implementation accounts for multiple internal reflections between the interfaces (including attenuation), but neglects parallax effects due to its (virtual) thickness. To create a such a thin glass material pass the type string “<code>ThinGlass</code>” to <code>ospNewMaterial2</code>. Its parameters are</p>
<table>
<caption>Parameters of the ThinGlass material.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: right;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">eta</td>
<td style="text-align: right;">1.5</td>
<td style="text-align: left;">index of refraction</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">attenuationColor</td>
<td style="text-align: right;">white</td>
<td style="text-align: left;">resulting color due to attenuation</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">attenuationDistance</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">distance affecting attenuation</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">thickness</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">virtual thickness</td>
</tr>
</tbody>
</table>
<p>For convenience the attenuation is controlled the same way as with the <a href="#glass">Glass</a> material. Additionally, the color due to attenuation can be modulated with a <a href="#texture">texture</a> <code>map_attenuationColor</code> (<a href="#texture2d-transformations">texture transformations</a> are supported as well). If present, the color component of <a href="#geometries">geometries</a> is also used for the attenuation color. The <code>thickness</code> parameter sets the (virtual) thickness and allows for easy exchange of parameters with the (real) <a href="#glass">Glass</a> material; internally just the ratio between <code>attenuationDistance</code> and <code>thickness</code> is used to calculate the resulting attenuation and thus the material appearance.</p>
<figure>
<img src="images/material_ThinGlass.jpg" alt="Rendering of a ThinGlass material with red attenuation." style="width:60.0%" /><figcaption>Rendering of a ThinGlass material with red attenuation.</figcaption>
</figure>
<figure>
<img src="images/ColoredWindow.jpg" alt="Example image of a colored window made with textured attenuation of the ThinGlass material." style="width:60.0%" /><figcaption>Example image of a colored window made with textured attenuation of the ThinGlass material.</figcaption>
</figure>
<h4 id="metallicpaint">MetallicPaint</h4>
<p>The <a href="#path-tracer">path tracer</a> offers a metallic paint material, consisting of a base coat with optional flakes and a clear coat. To create a MetallicPaint material pass the type string “<code>MetallicPaint</code>” to <code>ospNewMaterial2</code>. Its parameters are listed in the table below.</p>
<table>
<caption>Parameters of the MetallicPaint material.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: right;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">baseColor</td>
<td style="text-align: right;">white 0.8</td>
<td style="text-align: left;">color of base coat</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">flakeAmount</td>
<td style="text-align: right;">0.3</td>
<td style="text-align: left;">amount of flakes, in [0–1]</td>
</tr>
<tr class="odd">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">flakeColor</td>
<td style="text-align: right;">Aluminium</td>
<td style="text-align: left;">color of metallic flakes</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">flakeSpread</td>
<td style="text-align: right;">0.5</td>
<td style="text-align: left;">spread of flakes, in [0–1]</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">eta</td>
<td style="text-align: right;">1.5</td>
<td style="text-align: left;">index of refraction of clear coat</td>
</tr>
</tbody>
</table>
<p>The color of the base coat <code>baseColor</code> can be textured by a <a href="#texture">texture</a> <code>map_baseColor</code>, which also supports <a href="#texture2d-transformations">texture transformations</a>. If present, the color component of <a href="#geometries">geometries</a> is also used for the color of the base coat. parameter <code>flakeAmount</code> controls the proportion of flakes in the base coat, so when setting it to 1 the <code>baseColor</code> will not be visible. The shininess of the metallic component is governed by <code>flakeSpread</code>, which controls the variation of the orientation of the flakes, similar to the <code>roughness</code> parameter of <a href="#metal">Metal</a>. Note that the effect of the metallic flakes is currently only computed on average, thus individual flakes are not visible.</p>
<figure>
<img src="images/material_MetallicPaint.jpg" alt="Rendering of a MetallicPaint material." style="width:60.0%" /><figcaption>Rendering of a MetallicPaint material.</figcaption>
</figure>
<h4 id="luminous">Luminous</h4>
<p>The <a href="#path-tracer">path tracer</a> supports the Luminous material which emits light uniformly in all directions and which can thus be used to turn any geometric object into a light source. It is created by passing the type string “<code>Luminous</code>” to <code>ospNewMaterial2</code>. The amount of constant radiance that is emitted is determined by combining the general parameters of lights: <a href="#lights"><code>color</code> and <code>intensity</code></a>.</p>
<figure>
<img src="images/material_Luminous.jpg" alt="Rendering of a yellow Luminous material." style="width:60.0%" /><figcaption>Rendering of a yellow Luminous material.</figcaption>
</figure>
<h3 id="texture">Texture</h3>
<p>OSPRay currently implements two texture types (<code>texture2d</code> and <code>volume</code>) and is open for extension to other types by applications. More types may be added in future releases.</p>
<p>To create a new texture use</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb35-1" title="1">OSPTexture ospNewTexture(<span class="at">const</span> <span class="dt">char</span> *type);</a></code></pre></div>
<p>The call returns <code>NULL</code> if the texture could not be created with the given parameters, or else an <code>OSPTexture</code> handle to the created texture.</p>
<h4 id="texture2d">Texture2D</h4>
<p>The <code>texture2D</code> texture type implements an image-based texture, where its parameters are as follows</p>
<table>
<caption>Parameters of <code>texture2D</code> texture type</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">vec2i</td>
<td style="text-align: left;">size</td>
<td style="text-align: left;">size of the textures</td>
</tr>
<tr class="even">
<td style="text-align: left;">int</td>
<td style="text-align: left;">type</td>
<td style="text-align: left;"><code>OSPTextureFormat</code> for the texture</td>
</tr>
<tr class="odd">
<td style="text-align: left;">int</td>
<td style="text-align: left;">flags</td>
<td style="text-align: left;">special attribute flags for this</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">texture, currently only responds</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">to <code>OSP_TEXTURE_FILTER_NEAREST</code> or</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">no flags</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSPData</td>
<td style="text-align: left;">data</td>
<td style="text-align: left;">the actual texel data</td>
</tr>
</tbody>
</table>
<p>The supported texture formats for <code>texture2d</code> are:</p>
<table>
<caption>Supported texture formats by <code>texture2D</code>, i.e. valid constants of type <code>OSPTextureFormat</code>.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">OSP_TEXTURE_RGBA8</td>
<td style="text-align: left;">8 bit [0–255] linear components red, green, blue, alpha</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_TEXTURE_SRGBA</td>
<td style="text-align: left;">8 bit sRGB gamma encoded color components, and linear alpha</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_TEXTURE_RGBA32F</td>
<td style="text-align: left;">32 bit float components red, green, blue, alpha</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_TEXTURE_RGB8</td>
<td style="text-align: left;">8 bit [0–255] linear components red, green, blue</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_TEXTURE_SRGB</td>
<td style="text-align: left;">8 bit sRGB gamma encoded components red, green, blue</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_TEXTURE_RGB32F</td>
<td style="text-align: left;">32 bit float components red, green, blue</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_TEXTURE_R8</td>
<td style="text-align: left;">8 bit [0–255] linear single component</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_TEXTURE_R32F</td>
<td style="text-align: left;">32 bit float single component</td>
</tr>
</tbody>
</table>
<p>The texel data addressed by <code>source</code> starts with the texels in the lower left corner of the texture image, like in OpenGL. Per default a texture fetch is filtered by performing bi-linear interpolation of the nearest 2×2 texels; if instead fetching only the nearest texel is desired (i.e. no filtering) then pass the <code>OSP_TEXTURE_FILTER_NEAREST</code> flag.</p>
<h4 id="texturevolume">TextureVolume</h4>
<p>The <code>volume</code> texture type implements texture lookups based on 3D world coordinates of the surface hit point on the associated geometry. If the given hit point is within the attached volume, the volume is sampled and classified with the transfer function attached to the volume. This implements the ability to visualize volume values (as colored by its transfer function) on arbitrary surfaces inside the volume (as opposed to an isosurface showing a particular value in the volume). Its parameters are as follows</p>
<table>
<caption>Parameters of <code>volume</code> texture type</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">OSPVolume</td>
<td style="text-align: left;">volume</td>
<td style="text-align: left;">volume used to generate color lookups</td>
</tr>
</tbody>
</table>
<h3 id="texture2d-transformations">Texture2D Transformations</h3>
<p>All materials with textures also offer to manipulate the placement of these textures with the help of texture transformations. If so, this convention shall be used. The following parameters (prefixed with “<code>texture_name.</code>”) are combined into one transformation matrix:</p>
<table>
<caption>Parameters to define texture coordinate transformations.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">vec4f</td>
<td style="text-align: left;">transform</td>
<td style="text-align: left;">interpreted as 2×2 matrix (linear part), column-major</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">rotation</td>
<td style="text-align: left;">angle in degree, counterclockwise, around center</td>
</tr>
<tr class="odd">
<td style="text-align: left;">vec2f</td>
<td style="text-align: left;">scale</td>
<td style="text-align: left;">enlarge texture, relative to center (0.5, 0.5)</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec2f</td>
<td style="text-align: left;">translation</td>
<td style="text-align: left;">move texture in positive direction (right/up)</td>
</tr>
</tbody>
</table>
<p>The transformations are applied in the given order. Rotation, scale and translation are interpreted “texture centric”, i.e. their effect seen by an user are relative to the texture (although the transformations are applied to the texture coordinates).</p>
<h3 id="cameras">Cameras</h3>
<p>To create a new camera of given type <code>type</code> use</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb36-1" title="1">OSPCamera ospNewCamera(<span class="at">const</span> <span class="dt">char</span> *type);</a></code></pre></div>
<p>The call returns <code>NULL</code> if that type of camera is not known, or else an <code>OSPCamera</code> handle to the created camera. All cameras accept these parameters:</p>
<table>
<caption>Parameters accepted by all cameras.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">vec3f(a)</td>
<td style="text-align: left;">pos</td>
<td style="text-align: left;">position of the camera in world-space</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec3f(a)</td>
<td style="text-align: left;">dir</td>
<td style="text-align: left;">main viewing direction of the camera</td>
</tr>
<tr class="odd">
<td style="text-align: left;">vec3f(a)</td>
<td style="text-align: left;">up</td>
<td style="text-align: left;">up direction of the camera</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">nearClip</td>
<td style="text-align: left;">near clipping distance</td>
</tr>
<tr class="odd">
<td style="text-align: left;">vec2f</td>
<td style="text-align: left;">imageStart</td>
<td style="text-align: left;">start of image region (lower left corner)</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec2f</td>
<td style="text-align: left;">imageEnd</td>
<td style="text-align: left;">end of image region (upper right corner)</td>
</tr>
</tbody>
</table>
<p>The camera is placed and oriented in the world with <code>pos</code>, <code>dir</code> and <code>up</code>. OSPRay uses a right-handed coordinate system. The region of the camera sensor that is rendered to the image can be specified in normalized screen-space coordinates with <code>imageStart</code> (lower left corner) and <code>imageEnd</code> (upper right corner). This can be used, for example, to crop the image, to achieve asymmetrical view frusta, or to horizontally flip the image to view scenes which are specified in a left-handed coordinate system. Note that values outside the default range of [0–1] are valid, which is useful to easily realize overscan or film gate, or to emulate a shifted sensor.</p>
<h4 id="perspective-camera">Perspective Camera</h4>
<p>The perspective camera implements a simple thinlens camera for perspective rendering, supporting optionally depth of field and stereo rendering, but no motion blur. It is created by passing the type string “<code>perspective</code>” to <code>ospNewCamera</code>. In addition to the <a href="#cameras">general parameters</a> understood by all cameras the perspective camera supports the special parameters listed in the table below.</p>
<table style="width:97%;">
<caption>Parameters accepted by the perspective camera.</caption>
<colgroup>
<col style="width: 10%" />
<col style="width: 32%" />
<col style="width: 53%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">fovy</td>
<td style="text-align: left;">the field of view (angle in degree) of the frame’s height</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">aspect</td>
<td style="text-align: left;">ratio of width by height of the frame (and image region)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">apertureRadius</td>
<td style="text-align: left;">size of the aperture, controls the depth of field</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">focusDistance</td>
<td style="text-align: left;">distance at where the image is sharpest when depth of field is enabled</td>
</tr>
<tr class="odd">
<td style="text-align: left;">bool</td>
<td style="text-align: left;">architectural</td>
<td style="text-align: left;">vertical edges are projected to be parallel</td>
</tr>
<tr class="even">
<td style="text-align: left;">int</td>
<td style="text-align: left;">stereoMode</td>
<td style="text-align: left;">0: no stereo (default), 1: left eye, 2: right eye, 3: side-by-side</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">interpupillaryDistance</td>
<td style="text-align: left;">distance between left and right eye when stereo is enabled</td>
</tr>
</tbody>
</table>
<p>Note that when computing the <code>aspect</code> ratio a potentially set image region (using <code>imageStart</code> &amp; <code>imageEnd</code>) needs to be regarded as well.</p>
<p>In architectural photography it is often desired for aesthetic reasons to display the vertical edges of buildings or walls vertically in the image as well, regardless of how the camera is tilted. Enabling the <code>architectural</code> mode achieves this by internally leveling the camera parallel to the ground (based on the <code>up</code> direction) and then shifting the lens such that the objects in direction <code>dir</code> are centered in the image. If finer control of the lens shift is needed use <code>imageStart</code> &amp; <code>imageEnd</code>. Because the camera is now effectively leveled its image plane and thus the plane of focus is oriented parallel to the front of buildings, the whole façade appears sharp, as can be seen in the example images below.</p>
<figure>
<img src="images/camera_perspective.jpg" alt="Example image created with the perspective camera, featuring depth of field." style="width:60.0%" /><figcaption>Example image created with the perspective camera, featuring depth of field.</figcaption>
</figure>
<figure>
<img src="images/camera_architectual.jpg" alt="Enabling the architectural flag corrects the perspective projection distortion, resulting in parallel vertical edges." style="width:60.0%" /><figcaption>Enabling the <code>architectural</code> flag corrects the perspective projection distortion, resulting in parallel vertical edges.</figcaption>
</figure>
<figure>
<img src="images/camera_stereo.jpg" alt="Example 3D stereo image using stereoMode side-by-side." style="width:90.0%" /><figcaption>Example 3D stereo image using <code>stereoMode</code> side-by-side.</figcaption>
</figure>
<h4 id="orthographic-camera">Orthographic Camera</h4>
<p>The orthographic camera implements a simple camera with orthographic projection, without support for depth of field or motion blur. It is created by passing the type string “<code>orthographic</code>” to <code>ospNewCamera</code>. In addition to the <a href="#cameras">general parameters</a> understood by all cameras the orthographic camera supports the following special parameters:</p>
<table>
<caption>Parameters accepted by the orthographic camera.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">height</td>
<td style="text-align: left;">size of the camera’s image plane in y, in world coordinates</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">aspect</td>
<td style="text-align: left;">ratio of width by height of the frame</td>
</tr>
</tbody>
</table>
<p>For convenience the size of the camera sensor, and thus the extent of the scene that is captured in the image, can be controlled with the <code>height</code> parameter. The same effect can be achieved with <code>imageStart</code> and <code>imageEnd</code>, and both methods can be combined. In any case, the <code>aspect</code> ratio needs to be set accordingly to get an undistorted image.</p>
<figure>
<img src="images/camera_orthographic.jpg" alt="Example image created with the orthographic camera." style="width:60.0%" /><figcaption>Example image created with the orthographic camera.</figcaption>
</figure>
<h4 id="panoramic-camera">Panoramic Camera</h4>
<p>The panoramic camera implements a simple camera without support for motion blur. It captures the complete surrounding with a latitude / longitude mapping and thus the rendered images should best have a ratio of 2:1. A panoramic camera is created by passing the type string “<code>panoramic</code>” to <code>ospNewCamera</code>. It is placed and oriented in the scene by using the <a href="#cameras">general parameters</a> understood by all cameras.</p>
<figure>
<img src="images/camera_panoramic.jpg" alt="Latitude / longitude map created with the panoramic camera." style="width:90.0%" /><figcaption>Latitude / longitude map created with the panoramic camera.</figcaption>
</figure>
<h3 id="picking">Picking</h3>
<p>To get the world-space position of the geometry (if any) seen at [0–1] normalized screen-space pixel coordinates <code>screenPos</code> use</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb37-1" title="1"><span class="dt">void</span> ospPick(OSPPickResult*, OSPRenderer, <span class="at">const</span> vec2f &amp;screenPos);</a></code></pre></div>
<p>The result is returned in the provided <code>OSPPickResult</code> struct:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb38-1" title="1"><span class="kw">typedef</span> <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb38-2" title="2">    vec3f position; <span class="co">// the position of the hit point (in world-space)</span></a>
<a class="sourceLine" id="cb38-3" title="3">    <span class="dt">bool</span> hit;       <span class="co">// whether or not a hit actually occurred</span></a>
<a class="sourceLine" id="cb38-4" title="4">} OSPPickResult;</a></code></pre></div>
<p>Note that <code>ospPick</code> considers exactly the same camera of the given renderer that is used to render an image, thus matching results can be expected. If the camera supports depth of field then the center of the lens and thus the center of the circle of confusion is used for picking.</p>
<h2 id="framebuffer">Framebuffer</h2>
<p>The framebuffer holds the rendered 2D image (and optionally auxiliary information associated with pixels). To create a new framebuffer object of given size <code>size</code> (in pixels), color format, and channels use</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb39-1" title="1">OSPFrameBuffer ospNewFrameBuffer(<span class="at">const</span> vec2i &amp;size,</a>
<a class="sourceLine" id="cb39-2" title="2">                                 <span class="at">const</span> OSPFrameBufferFormat format = OSP_FB_SRGBA,</a>
<a class="sourceLine" id="cb39-3" title="3">                                 <span class="at">const</span> <span class="dt">uint32_t</span> frameBufferChannels = OSP_FB_COLOR);</a></code></pre></div>
<p>The parameter <code>format</code> describes the format the color buffer has <em>on the host</em>, and the format that <code>ospMapFrameBuffer</code> will eventually return. Valid values are:</p>
<table>
<caption>Supported color formats of the framebuffer that can be passed to <code>ospNewFrameBuffer</code>, i.e. valid constants of type <code>OSPFrameBufferFormat</code>.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">OSP_FB_NONE</td>
<td style="text-align: left;">framebuffer will not be mapped by the application</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_FB_RGBA8</td>
<td style="text-align: left;">8 bit [0–255] linear component red, green, blue, alpha</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_FB_SRGBA</td>
<td style="text-align: left;">8 bit sRGB gamma encoded color components, and linear alpha</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_FB_RGBA32F</td>
<td style="text-align: left;">32 bit float components red, green, blue, alpha</td>
</tr>
</tbody>
</table>
<p>The parameter <code>frameBufferChannels</code> specifies which channels the framebuffer holds, and can be combined together by bitwise OR from the values of <code>OSPFrameBufferChannel</code> listed in the table below.</p>
<table>
<caption>Framebuffer channels constants (of type <code>OSPFrameBufferChannel</code>), naming optional information the framebuffer can store. These values can be combined by bitwise OR when passed to <code>ospNewFrameBuffer</code> or <code>ospFrameBufferClear</code>.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">OSP_FB_COLOR</td>
<td style="text-align: left;">RGB color including alpha</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_FB_DEPTH</td>
<td style="text-align: left;">euclidean distance to the camera (<em>not</em> to the image plane), as linear 32 bit float</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_FB_ACCUM</td>
<td style="text-align: left;">accumulation buffer for progressive refinement</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_FB_VARIANCE</td>
<td style="text-align: left;">for estimation of the current noise level if OSP_FB_ACCUM is also present, see <a href="#rendering">rendering</a></td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_FB_NORMAL</td>
<td style="text-align: left;">accumulated screen-space normal of the first hit, as vec3f</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_FB_ALBEDO</td>
<td style="text-align: left;">accumulated material albedo (color without illumination) at the first hit, as vec3f</td>
</tr>
</tbody>
</table>
<p>If a certain channel value is <em>not</em> specified, the given buffer channel will not be present. Note that ospray makes a very clear distinction between the <em>external</em> format of the framebuffer and the internal one: The external format is the format the user specifies in the <code>format</code> parameter; it specifies what color format OSPRay will eventually <em>return</em> the framebuffer to the application (when calling <code>ospMapFrameBuffer</code>): no matter what OSPRay uses internally, it will simply return a 2D array of pixels of that format, with possibly all kinds of reformatting, compression/decompression, etc, going on in-between the generation of the <em>internal</em> framebuffer and the mapping of the externally visible one.</p>
<p>In particular, <code>OSP_FB_NONE</code> is a perfectly valid pixel format for a framebuffer that an application will never map. For example, an application driving a display wall may well generate an intermediate framebuffer and eventually transfer its pixel to the individual displays using an <code>OSPPixelOp</code> <a href="#pixel-operation">pixel operation</a>.</p>
<p>The application can map the given channel of a framebuffer – and thus access the stored pixel information – via</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb40-1" title="1"><span class="at">const</span> <span class="dt">void</span> *ospMapFrameBuffer(OSPFrameBuffer,</a>
<a class="sourceLine" id="cb40-2" title="2">                              <span class="at">const</span> OSPFrameBufferChannel = OSP_FB_COLOR);</a></code></pre></div>
<p>Note that <code>OSP_FB_ACCUM</code> or <code>OSP_FB_VARIANCE</code> cannot be mapped. The origin of the screen coordinate system in OSPRay is the lower left corner (as in OpenGL), thus the first pixel addressed by the returned pointer is the lower left pixel of the image.</p>
<p>A previously mapped channel of a framebuffer can be unmapped by passing the received pointer <code>mapped</code> to</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb41-1" title="1"><span class="dt">void</span> ospUnmapFrameBuffer(<span class="at">const</span> <span class="dt">void</span> *mapped, OSPFrameBuffer);</a></code></pre></div>
<p>The individual channels of a framebuffer can be cleared with</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb42-1" title="1"><span class="dt">void</span> ospFrameBufferClear(OSPFrameBuffer, <span class="at">const</span> <span class="dt">uint32_t</span> frameBufferChannels);</a></code></pre></div>
<p>When selected, <code>OSP_FB_COLOR</code> will clear the color buffer to black <code>(0, 0, 0, 0)</code>, <code>OSP_FB_DEPTH</code> will clear the depth buffer to <code>inf</code>. <code>OSP_FB_ACCUM</code> will clear <em>all</em> accumulating buffers (<code>OSP_FB_VARIANCE</code>, <code>OSP_FB_NORMAL</code>, and <code>OSP_FB_ALBEDO</code>, if present) and resets the accumulation counter <code>accumID</code>.</p>
<h3 id="pixel-operation" class="unnumbered">Pixel Operation</h3>
<p>Pixel operations are functions that are applied to every pixel that gets written into a framebuffer. Examples include post-processing, filtering, blending, tone mapping, or sending tiles to a display wall. To create a new pixel operation of given type <code>type</code> use</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb43-1" title="1">OSPPixelOp ospNewPixelOp(<span class="at">const</span> <span class="dt">char</span> *type);</a></code></pre></div>
<p>The call returns <code>NULL</code> if that type is not known, or else an <code>OSPPixelOp</code> handle to the created pixel operation.</p>
<p>To set a pixel operation to the given framebuffer use</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb44-1" title="1"><span class="dt">void</span> ospSetPixelOp(OSPFrameBuffer, OSPPixelOp);</a></code></pre></div>
<h4 id="tone-mapper" class="unnumbered">Tone Mapper</h4>
<p>The tone mapper is a pixel operation which implements a generic filmic tone mapping operator. Using the default parameters it approximates the Academy Color Encoding System (ACES). The tone mapper is created by passing the type string “<code>tonemapper</code>” to <code>ospNewPixelOp</code>. The tone mapping curve can be customized using the parameters listed in the table below.</p>
<table style="width:97%;">
<caption>Parameters accepted by the tone mapper.</caption>
<colgroup>
<col style="width: 10%" />
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 54%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">contrast</td>
<td style="text-align: left;">1.6773</td>
<td style="text-align: left;">contrast (toe of the curve); typically is in [1–2]</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">shoulder</td>
<td style="text-align: left;">0.9714</td>
<td style="text-align: left;">highlight compression (shoulder of the curve); typically is in [0.9–1]</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">midIn</td>
<td style="text-align: left;">0.18</td>
<td style="text-align: left;">mid-level anchor input; default is 18% gray</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">midOut</td>
<td style="text-align: left;">0.18</td>
<td style="text-align: left;">mid-level anchor output; default is 18% gray</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">hdrMax</td>
<td style="text-align: left;">11.0785</td>
<td style="text-align: left;">maximum HDR input that is not clipped</td>
</tr>
<tr class="even">
<td style="text-align: left;">bool</td>
<td style="text-align: left;">acesColor</td>
<td style="text-align: left;">true</td>
<td style="text-align: left;">apply the ACES color transforms</td>
</tr>
</tbody>
</table>
<p>To use the popular “Uncharted 2” filmic tone mapping curve instead, set the parameters to the values listed in the table below.</p>
<table>
<caption>Filmic tone mapping curve parameters. Note that the curve includes an exposure bias to match 18% middle gray.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Value</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">contrast</td>
<td style="text-align: left;">1.1759</td>
</tr>
<tr class="even">
<td style="text-align: left;">shoulder</td>
<td style="text-align: left;">0.9746</td>
</tr>
<tr class="odd">
<td style="text-align: left;">midIn</td>
<td style="text-align: left;">0.18</td>
</tr>
<tr class="even">
<td style="text-align: left;">midOut</td>
<td style="text-align: left;">0.18</td>
</tr>
<tr class="odd">
<td style="text-align: left;">hdrMax</td>
<td style="text-align: left;">6.3704</td>
</tr>
<tr class="even">
<td style="text-align: left;">acesColor</td>
<td style="text-align: left;">false</td>
</tr>
</tbody>
</table>
<h2 id="rendering">Rendering</h2>
<p>To render a frame into the given framebuffer with the given renderer use</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb45-1" title="1"><span class="dt">float</span> ospRenderFrame(OSPFrameBuffer, OSPRenderer,</a>
<a class="sourceLine" id="cb45-2" title="2">                     <span class="at">const</span> <span class="dt">uint32_t</span> frameBufferChannels = OSP_FB_COLOR);</a></code></pre></div>
<p>The third parameter specifies what channel(s) of the framebuffer is written to<a href="#fn6" class="footnote-ref" id="fnref6"><sup>6</sup></a>. What to render and how to render it depends on the renderer’s parameters. If the framebuffer supports accumulation (i.e. it was created with <code>OSP_FB_ACCUM</code>) then successive calls to <code>ospRenderFrame</code> will progressively refine the rendered image. If additionally the framebuffer has an <code>OSP_FB_VARIANCE</code> channel then <code>ospRenderFrame</code> returns an estimate of the current variance of the rendered image, otherwise <code>inf</code> is returned. The estimated variance can be used by the application as a quality indicator and thus to decide whether to stop or to continue progressive rendering.</p>
<h3 id="progress-and-cancel" class="unnumbered">Progress and Cancel</h3>
<p>To be informed about the progress of rendering the current frame the application can register a callback function of type</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb46-1" title="1"><span class="kw">typedef</span> <span class="dt">int</span> (*OSPProgressFunc)(<span class="dt">void</span>* userPtr, <span class="at">const</span> <span class="dt">float</span> progress);</a></code></pre></div>
<p>via</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb47-1" title="1"><span class="dt">void</span> ospSetProgressFunc(OSPProgressFunc, <span class="dt">void</span>* userPtr);</a></code></pre></div>
<p>The provided user pointer <code>userPtr</code> is passed as first argument to the callback function<a href="#fn7" class="footnote-ref" id="fnref7"><sup>7</sup></a> and the reported progress is in (0–1]. If the callback function returns zero than the application requests to cancel rendering, i.e. the current <code>ospRenderFrame</code> will return at the first opportunity and the content of the frambuffer will be undefined. Therefore, better clear the framebuffer with <code>ospFrameBufferClear</code> then before a subsequent call of <code>ospRenderFrame</code>.</p>
<p>Passing <code>NULL</code> as <code>OSPProgressFunc</code> function pointer disables the progress callback.</p>
<h1 id="parallel-rendering-with-mpi">Parallel Rendering with MPI</h1>
<p>OSPRay has the ability to scale to multiple nodes in a cluster via MPI. This enables applications to take advantage of larger compute and memory resources when available.</p>
<h2 id="prerequisites-for-mpi-mode">Prerequisites for MPI Mode</h2>
<p>In addition to the standard build requirements of OSPRay, you must have the following items available in your environment in order to build &amp; run OSPRay in MPI mode:</p>
<ul>
<li>An MPI enabled multi-node environment, such as an HPC cluster</li>
<li>An MPI implementation you can build against (i.e. Intel MPI, MVAPICH2, etc…)</li>
</ul>
<h2 id="enabling-the-mpi-module-in-your-build">Enabling the MPI Module in your Build</h2>
<p>To build the MPI module the CMake option <code>OSPRAY_MODULE_MPI</code> must be enabled, which can be done directly on the command line (with <code>-DOSPRAY_MODULE_MPI=ON</code>) or through a configuration dialog (<code>ccmake</code>, <code>cmake-gui</code>), see also <a href="#compiling-ospray">Compiling OSPRay</a>.</p>
<p>This will trigger CMake to go look for an MPI implementation in your environment. You can then inspect the CMake value of <code>MPI_LIBRARY</code> to make sure that CMake found your MPI build environment correctly.</p>
<p>This will result in an OSPRay module being built. To enable using it, applications will need to either link <code>libospray_module_mpi</code>, or call</p>
<pre><code>ospLoadModule(&quot;mpi&quot;);</code></pre>
<p>before initializing OSPRay.</p>
<h2 id="modes-of-using-osprays-mpi-features">Modes of Using OSPRay’s MPI Features</h2>
<p>OSPRay provides two ways of using MPI to scale up rendering: offload and distributed.</p>
<h3 id="offload-rendering">Offload Rendering</h3>
<p>The “offload” rendering mode is where a single (not-distributed) calling application treats the OSPRay API the same as with local rendering. However, OSPRay uses multiple MPI connected nodes to evenly distribute frame rendering work, where each node contains a full copy of all scene data. This method is most effective for scenes which can fit into memory, but are very expensive to render: for example, path tracing with many samples-per-pixel is very compute heavy, making it a good situation to use the offload feature. This can be done with any application which already uses OSPRay for local rendering without the need for any code changes.</p>
<p>When doing MPI offload rendering, applications can optionally enable dynamic load balancing, which can be beneficial in certain contexts. This load balancing refers to the distribution of tile rendering work across nodes: thread-level load balancing on each node is still dynamic with the thread tasking system. The options for enabling/controlling the dynamic load balacing features on the <code>mpi_offload</code> device are found in the table below, which can be changed while the application is running. Please note that these options will likely only pay off for scenes which have heavy rendering load (e.g. path tracing a non-trivial scene) and have a lot of variance in how expensive each tile is to render.</p>
<table>
<caption>Parameters specific to the <code>mpi_offload</code> device.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: right;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">bool</td>
<td style="text-align: left;">dynamicLoadBalancer</td>
<td style="text-align: right;">false</td>
<td style="text-align: left;">whether to use dynamic load balancing</td>
</tr>
</tbody>
</table>
<h3 id="distributed-rendering">Distributed Rendering</h3>
<p>The “distributed” rendering mode is where a MPI distributed application (such as a scientific simulation) uses OSPRay collectively to render frames. In this case, the API expects all calls (both created objects and parameters) to be the same on every application rank, except each rank can specify arbitrary geometries and volumes. Each renderer will have its own limitations on the topology of the data (i.e. overlapping data regions, concave data, etc.), but the API calls will only differ for scene objects. Thus all other calls (i.e. setting camera, creating framebuffer, rendering frame, etc.) will all be assumed to be identical, but only rendering a frame and committing the model must be in lock-step. This mode targets using all available aggregate memory for very large scenes and for “in-situ” visualization where the data is already distributed by a simulation app.</p>
<h2 id="running-an-application-with-the-offload-device">Running an Application with the “offload” Device</h2>
<p>As an example, our sample viewer can be run as a single application which offloads rendering work to multiple MPI processes running on multiple machines.</p>
<p>The example apps are setup to be launched in two different setups. In either setup, the application must initialize OSPRay with the offload device. This can be done by creating an “<code>mpi_offload</code>” device and setting it as the current device (via the <code>ospSetCurrentDevice()</code> function), or passing either “<code>--osp:mpi</code>” or “<code>--osp:mpi-offload</code>” as a command line parameter to <code>ospInit()</code>. Note that passing a command line parameter will automatically call <code>ospLoadModule(&quot;mpi&quot;)</code> to load the MPI module, while the application will have to load the module explicitly if using <code>ospNewDevice()</code>.</p>
<h3 id="single-mpi-launch">Single MPI Launch</h3>
<p>OSPRay is initialized with the <code>ospInit()</code> function call which takes command line arguments in and configures OSPRay based on what it finds. In this setup, the app is launched across all ranks, but workers will never return from <code>ospInit()</code>, essentially turning the application into a worker process for OSPRay. Here’s an example of running the ospVolumeViewer data-replicated, using <code>c1</code>-<code>c4</code> as compute nodes and <code>localhost</code> the process running the viewer itself:</p>
<pre><code>mpirun -perhost 1 -hosts localhost,c1,c2,c3,c4 ./ospExampleViewer &lt;scene file&gt; --osp:mpi</code></pre>
<h3 id="separate-applicationworker-launches">Separate Application&amp;Worker Launches</h3>
<p>The second option is to explicitly launch the app on rank 0 and worker ranks on the other nodes. This is done by running <code>ospray_mpi_worker</code> on worker nodes and the application on the display node. Here’s the same example above using this syntax:</p>
<pre><code>mpirun -perhost 1 -hosts localhost ./ospExampleViewer &lt;scene file&gt; --osp:mpi \
  : -hosts c1,c2,c3,c4 ./ospray_mpi_worker</code></pre>
<p>This method of launching the application and OSPRay worker separately works best for applications which do not immediately call <code>ospInit()</code> in their <code>main()</code> function, or for environments where application dependencies (such as GUI libraries) may not be available on compute nodes.</p>
<h2 id="running-an-application-with-the-distributed-device">Running an Application with the “distributed” Device</h2>
<p>Applications using the new distributed device should initialize OSPRay by creating (and setting current) an “<code>mpi_distributed</code>” device or pass <code>&quot;--osp:mpi-distributed&quot;</code> as a command line argument to <code>ospInit()</code>. Note that due to the semantic differences the distributed device gives the OSPRay API, it is not expected for applications which can already use the offload device to correctly use the distributed device without changes to the application.</p>
<p>The following additional parameter can be set on the <code>mpi_distributed</code> device.</p>
<table style="width:97%;">
<caption>Parameters for the <code>mpi_distributed</code> device.</caption>
<colgroup>
<col style="width: 10%" />
<col style="width: 24%" />
<col style="width: 62%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">void*</td>
<td style="text-align: left;">worldCommunicator</td>
<td style="text-align: left;">A pointer to the <code>MPI_Comm</code> which should be used as OSPRay’s world communicator. This will set how many ranks OSPRay should expect to participate in rendering. The default is <code>MPI_COMM_WORLD</code> where all ranks are expected to participate in rendering.</td>
</tr>
</tbody>
</table>
<p>By setting the <code>worldCommunicator</code> parameter to a different communicator than <code>MPI_COMM_WORLD</code> the client application can tune how OSPRay is run within its processes. The default uses <code>MPI_COMM_WORLD</code> and thus expects all processes to also participate in rendering, thus if a subset of processes do not call collectives like <code>ospRenderFrame</code> the application would hang.</p>
<p>For example, an MPI parallel application may be run with one process per-core, however OSPRay is multithreaded and will perform best when run with one process per-node. By splitting <code>MPI_COMM_WORLD</code> the application can create a communicator with one rank per-node to then run OSPRay on one process per-node. The remaining ranks on each node can then aggregate their data to the OSPRay process for rendering.</p>
<p>There are also two optional parameters available on the OSPModel created using the distributed device, which can be set to tell OSPRay about your application’s data distribution.</p>
<table style="width:97%;">
<caption>Parameters for the distributed OSPModel</caption>
<colgroup>
<col style="width: 14%" />
<col style="width: 23%" />
<col style="width: 60%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>box3f[]</code></td>
<td style="text-align: left;">regions</td>
<td style="text-align: left;"><a href="#data">data</a> array of boxes which bound the data owned by the current rank, used for sort-last compositing. The global set of regions specified by all ranks must be disjoint for correct compositing.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>box3f[]</code></td>
<td style="text-align: left;">ghostRegions</td>
<td style="text-align: left;">Optional <a href="#data">data</a> array of boxes which bound the ghost data on each rank. Using these shared data between nodes can be used for computing secondary ray effects such as ambient occlusion. If specifying ghostRegions, there should be one ghostRegion for each region.</td>
</tr>
</tbody>
</table>
<p>See the distributed device examples in the MPI module for examples.</p>
<p>The renderer supported when using the distributed device is the <code>mpi_raycast</code> renderer. This renderer is an experimental renderer and currently only supports ambient occlusion (on the local data only). To compute correct ambient occlusion across the distributed data the application is responsible for replicating ghost data and specifying the ghostRegions and regions as described above.</p>
<table style="width:97%;">
<caption>Parameters for the distributed OSPModel</caption>
<colgroup>
<col style="width: 14%" />
<col style="width: 23%" />
<col style="width: 11%" />
<col style="width: 48%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: right;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">int</td>
<td style="text-align: left;">aoSamples</td>
<td style="text-align: right;">0</td>
<td style="text-align: left;">number of rays per sample to compute ambient occlusion</td>
</tr>
</tbody>
</table>
<h1 id="scenegraph">Scenegraph</h1>
<p><strong>WARNING: USE AT YOUR OWN RISK. The Scenegraph is currently in Alpha mode and will change frequently. It is not yet recommended for critical production work.</strong></p>
<p>The scenegraph is the basis of our exampleViewer which consists of a superset of OSPRay objects represented in a graph hierarchy (currently a tree). This graph functions as a hierarchical specification for scene properties and a self-managed update graph. The scenegraph infrastructure includes many convenience functions for templated traversals, queries of state and child state, automated updates, and timestamped modifications to underlying state.</p>
<p>The scenegraph nodes closely follow the dependencies of existing OSPRay API internals, ie a sg::Renderer has a “model” child, which in turn has a “TriangleMesh”, which in turn has a child named “vertex” similar to how you may set the “vertex” parameter on the osp::TriangleMesh which in turn is added to an OSPModel object which is set as the model on the OSPRenderer. The scenegraph is a supserset of OSPRay functionality so there isn’t a direct 1:1 mapping between the scenegraph hierarchy in all cases, however it is kept as close as possible. This makes the scene graph viewer in ospExampleViewer a great way to understand OSPRay state.</p>
<h2 id="hierarchy-structure">Hierarchy Structure</h2>
<p>The root of the scenegraph is based on sg::Renderer. The scenegraph can be created by</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb51-1" title="1"><span class="kw">auto</span> renderer = sg::createNode(<span class="st">&quot;renderer&quot;</span>, <span class="st">&quot;Renderer&quot;</span>);</a></code></pre></div>
<p>which automatically creates child nodes for necessary OSPRay state. To update and commit all state and render a single function is provided which can be called with:</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb52-1" title="1">renderer.renderFrame(renderer[<span class="st">&quot;frameBuffer&quot;</span>].nodeAs&lt;sg::FrameBuffer&gt;);</a></code></pre></div>
<p>Values can be set using:</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb53-1" title="1">renderer[<span class="st">&quot;spp&quot;</span>] = <span class="dv">16</span>;</a></code></pre></div>
<p>The explore the full set of nodes, simply launch the exampleViewer and traverse through the GUI representation of all scenegraph nodes.</p>
<h2 id="traversals">Traversals</h2>
<p>The scenegraph contains a set of builtin traversals as well as modular visitor functors for implementing custom passes over the scenegraph. The required traversals are handled for you by default within the renderFrame function on the renderer. For any given node there are two phases to a traversal operation, pre and post traversal of the nodes children. preTraversal initializes node state and objects and sets the current traversal context with appropriate state. For instance, sg::Model will create a new OSPModel object, set its value to that object, and set sg::RenderContext.currentOSPModel to its own value. After preTraversal is finished, the children of sg::Model are processed in a similar fashion and now use the modified context. In postTraversal, sg::Model will commit the changes that its children have potentially set and it will pop its modifications from the current context. This behavior is replicated for every scenegraph node and enables children to act on parent state without specific implementations from the parent node. An example of this are the sg::NodeParam nodes which are containers for values to be set on OSPObjects, such as a float value. This is put on the scenegraph with a call to:</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb54-1" title="1">renderer[<span class="st">&quot;lights&quot;</span>][<span class="st">&quot;sun&quot;</span>].createChild(<span class="st">&quot;intensity&quot;</span>, <span class="st">&quot;float&quot;</span>, <span class="fl">0.3</span><span class="bu">f</span>);</a></code></pre></div>
<p>This call accesses the child named “lights” on the renderer, and in turn the child named “sun”. This child then gets its own child of a newly created node with the name “intensity” of type “float” with a value of 0.3f. When committed, this node will call ospSet1f with the node value on the current OSPObject on the context which is set by the parent. If you were to create a custom light called “MyLight” and had a float parameter called “flickerFreq”, a similar line would be used without requiring any additional changes in the scenegraph internals beyond registering the new light class. Known parameters such as floats will also show up in the exampleViewerGUI without requiring any additional code beyond adding them to the scenegraph and the internal implementation in OSPRay.</p>
<p>The base passes required to utilize the scenegraph include verification, commit, and render traversals. Every node in the scenegraph has a valid state which needs to be set before operating on the node. Nodes may have custom qualifications for validity, but by default they are set through valid_ flags on the scenegraph Node for things like whitelists and range checks. Once verified, Commit traverses the scenegraph and commits scenegraph state to OSPRay. Commits are timestamped, so re-committing will only have any affect if a dependent child has been modified requiring a new commit. Because of this, each node does not have to track if it is valid or if anything in the scene has been modified, as commit will only be called on that node if those are already true. By default invalid nodes with throw exceptions, however this can be turned off which enables the program to keep running. In the exampleViewer GUI, invalid nodes will be marked in red but the previously committed state will keep rendering until the invalid state is corrected.</p>
<p>For examples of implementing custom traversals, see the sg/visitors folder. Here is an example of a visitor that collects all nodes with a given name:</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb55-1" title="1"><span class="kw">struct</span> GatherNodesByName : <span class="kw">public</span> Visitor</a>
<a class="sourceLine" id="cb55-2" title="2">{</a>
<a class="sourceLine" id="cb55-3" title="3">  GatherNodesByName(<span class="at">const</span> <span class="bu">std::</span>string &amp;_name);</a>
<a class="sourceLine" id="cb55-4" title="4"></a>
<a class="sourceLine" id="cb55-5" title="5">  <span class="dt">bool</span> <span class="kw">operator</span>()(Node &amp;node, TraversalContext &amp;ctx) <span class="kw">override</span>;</a>
<a class="sourceLine" id="cb55-6" title="6"></a>
<a class="sourceLine" id="cb55-7" title="7">  <span class="bu">std::</span>vector&lt;<span class="bu">std::</span>shared_ptr&lt;Node&gt;&gt; results();</a>
<a class="sourceLine" id="cb55-8" title="8"></a>
<a class="sourceLine" id="cb55-9" title="9"><span class="kw">private</span>:</a>
<a class="sourceLine" id="cb55-10" title="10">  <span class="bu">std::</span>string name;</a>
<a class="sourceLine" id="cb55-11" title="11">  <span class="bu">std::</span>vector&lt;<span class="bu">std::</span>shared_ptr&lt;Node&gt;&gt; nodes;</a>
<a class="sourceLine" id="cb55-12" title="12">};</a>
<a class="sourceLine" id="cb55-13" title="13"></a>
<a class="sourceLine" id="cb55-14" title="14"><span class="co">// Inlined definitions ////////////////////////////////////////////////////</span></a>
<a class="sourceLine" id="cb55-15" title="15"></a>
<a class="sourceLine" id="cb55-16" title="16"><span class="kw">inline</span> GatherNodesByName::GatherNodesByName(<span class="at">const</span> <span class="bu">std::</span>string &amp;_name)</a>
<a class="sourceLine" id="cb55-17" title="17">    : name(_name)</a>
<a class="sourceLine" id="cb55-18" title="18">{</a>
<a class="sourceLine" id="cb55-19" title="19">}</a>
<a class="sourceLine" id="cb55-20" title="20"></a>
<a class="sourceLine" id="cb55-21" title="21"><span class="kw">inline</span> <span class="dt">bool</span> GatherNodesByName::<span class="kw">operator</span>()(Node &amp;node, TraversalContext &amp;)</a>
<a class="sourceLine" id="cb55-22" title="22">{</a>
<a class="sourceLine" id="cb55-23" title="23">  <span class="cf">if</span> (utility::longestBeginningMatch(node.name(), <span class="kw">this</span>-&gt;name) == <span class="kw">this</span>-&gt;name) {</a>
<a class="sourceLine" id="cb55-24" title="24">    <span class="kw">auto</span> itr = <span class="bu">std::</span>find_if(</a>
<a class="sourceLine" id="cb55-25" title="25">      nodes.begin(),</a>
<a class="sourceLine" id="cb55-26" title="26">      nodes.end(),</a>
<a class="sourceLine" id="cb55-27" title="27">      [&amp;](<span class="at">const</span> <span class="bu">std::</span>shared_ptr&lt;Node&gt; &amp;nodeInList) {</a>
<a class="sourceLine" id="cb55-28" title="28">        <span class="cf">return</span> nodeInList.get() == &amp;node;</a>
<a class="sourceLine" id="cb55-29" title="29">      }</a>
<a class="sourceLine" id="cb55-30" title="30">    );</a>
<a class="sourceLine" id="cb55-31" title="31"></a>
<a class="sourceLine" id="cb55-32" title="32">    <span class="cf">if</span> (itr == nodes.end())</a>
<a class="sourceLine" id="cb55-33" title="33">      nodes.push_back(node.shared_from_this());</a>
<a class="sourceLine" id="cb55-34" title="34">  }</a>
<a class="sourceLine" id="cb55-35" title="35"></a>
<a class="sourceLine" id="cb55-36" title="36">  <span class="cf">return</span> <span class="kw">true</span>;</a>
<a class="sourceLine" id="cb55-37" title="37">}</a>
<a class="sourceLine" id="cb55-38" title="38"></a>
<a class="sourceLine" id="cb55-39" title="39"><span class="kw">inline</span> <span class="bu">std::</span>vector&lt;<span class="bu">std::</span>shared_ptr&lt;Node&gt;&gt; GatherNodesByName::results()</a>
<a class="sourceLine" id="cb55-40" title="40">{</a>
<a class="sourceLine" id="cb55-41" title="41">  <span class="cf">return</span> nodes;<span class="co">// </span><span class="al">TODO</span><span class="co">: should this be a move (i.e. reader &#39;consumes&#39;)?</span></a>
<a class="sourceLine" id="cb55-42" title="42">}</a></code></pre></div>
<h2 id="thread-safety">Thread Safety</h2>
<p>The scenegraph is only thread safe for accessing and setting values on nodes. More advanced operations like adding or removing nodes are not thread safe. At some point we hope to add transactions to handle these, but for now the scenegraph nodes must be added/removed on the same thread that is committing and rendering.</p>
<h1 id="examples">Examples</h1>
<h2 id="tutorial">Tutorial</h2>
<p>A minimal working example demonstrating how to use OSPRay can be found at <code>apps/ospTutorial.c</code><a href="#fn8" class="footnote-ref" id="fnref8"><sup>8</sup></a>. On Linux build it in the build directory with</p>
<pre><code>gcc -std=c99 ../apps/ospTutorial.c -I ../ospray/include -I .. \
./libospray.so -Wl,-rpath,. -o ospTutorial</code></pre>
<p>On Windows build it in the “build_directory\$Configuration” with</p>
<pre><code>cl ..\..\apps\ospTutorial.c -I ..\..\ospray\include -I ..\.. ospray.lib</code></pre>
<p>Running <code>ospTutorial</code> will create two images of two triangles, rendered with the Scientific Visualization renderer with full Ambient Occlusion. The first image <code>firstFrame.ppm</code> shows the result after one call to <code>ospRenderFrame</code> – jagged edges and noise in the shadow can be seen. Calling <code>ospRenderFrame</code> multiple times enables progressive refinement, resulting in antialiased edges and converged shadows, shown after ten frames in the second image <code>accumulatedFrames.ppm</code>.</p>
<figure>
<img src="images/tutorial_firstframe.png" alt="First frame." /><figcaption>First frame.</figcaption>
</figure>
<figure>
<img src="images/tutorial_accumulatedframe.png" alt="After accumulating ten frames." /><figcaption>After accumulating ten frames.</figcaption>
</figure>
<h2 id="example-viewer">Example Viewer</h2>
<figure>
<img src="images/exampleViewer.jpg" alt="Screenshot of using ospExampleViewer with a scenegraph." /><figcaption>Screenshot of using ospExampleViewer with a scenegraph.</figcaption>
</figure>
<p>OSPRay includes an exemplary viewer application <code>ospExampleViewer</code>, showcasing most features of OSPRay which can be run as <code>./ospExampleViewer [options] &lt;filename&gt;</code>. The Example Viewer uses the ImGui library for user interface controls and is based on a prototype OSPRay <a href="#scenegraph">scenegraph</a> interface where nodes can be viewed and edited interactively. Updates to scenegraph nodes update OSPRay state automatically through the scenegraph viewer which is enabled by pressing ‘g’.</p>
<h3 id="exploring-the-scene">Exploring the Scene</h3>
<p>The GUI shows the entire state of the program under the root scenegraph node. Expanding nodes down to explore and edit the scene is possible, for example a material parameter may be found under renderer→world→mesh→material→Kd. Updates to values will be automatically propagated to the next render. Individual nodes can be easily found using the “Find Node” section, which will find nodes with a given name based on the input string. Scene objects can also be selected with the mouse by shift-left clicking in the viewer.</p>
<p>Click on nodes to expand their children, whose values can be set by dragging or double clicking and typing in values. You can also add new nodes where appropriate: for example, when “lights” is expanded right clicking on “lights” and selecting create new node and typing in a light type, such as “PointLight”, will add it to the scene. Similarly, right clicking on “world” and creating an “Importer” node will add a new scene importer from a file. Changing the filename to an appropriate file will load the scene and propagate the resulting state. Exporting and importing the scenegraph is only partially supported at the moment through “ospsg” files. Currently, any nodes with Data members will break this functionality, however right clicking and selecting export on the camera or lights nodes for instance will save out their respective state which can be imported on the command line. ExampleViewer also functions as an OSPRay state debugger – invalid values will be shown in red up the hierarchy and won’t change the viewer until corrected.</p>
<h3 id="volume-rendering">Volume Rendering</h3>
<p>Volumes are loaded into the viewer just as a mesh is. Volume appearance is modified according to the transfer function, which will show up in a popup window on the GUI after pressing ‘g’. Click and drag across the transfer function to set opacity values, and selecting near the bottom of the editable transfer function widget sets the opacity to zero. The colors themselves can only be modified by selecting from the dropdown menu ‘ColorMap’ or importing and exporting json colors. The range that the transfer function operates on can be modified on the scenegraph viewer.</p>
<h3 id="exampleviewer-controls">ExampleViewer Controls</h3>
<ul>
<li>‘g’ - toggle scenegraph display</li>
<li>‘q’ - quit</li>
<li>Left click and drag to rotate</li>
<li>Right click and drag or mouse wheel to zoom in and out.</li>
<li>Mouse-Wheel click will pan the camera.</li>
<li>Control-Left clicking on an object will select a model and all of its children which will be displayed in the</li>
<li>Shift-Left click on an object will zoom into that part of the scene and set the focal distance.</li>
</ul>
<h3 id="commandline-options">CommandLine Options</h3>
<ul>
<li>Running <code>./ospExampleViewer -help</code> will bring up a list of commandline options. These options allow you to load files, run animations, modify any scenegraph state, and many other functions. See the <a href="#demos">demos</a> page for examples.</li>
<li>Supported file importers currently include: <code>obj</code>, <code>ply</code>, <code>x3d</code>, <code>vtu</code>, <code>osp</code>, <code>ospsg</code>, <code>xml</code> (rivl), <code>points</code>, <code>xyz</code>.</li>
</ul>
<h2 id="distributed-viewer">Distributed Viewer</h2>
<p>The application <code>ospDistribViewerDemo</code> demonstrates how to write a distributed SciVis style interactive renderer using the distributed MPI device. Note that because OSPRay uses sort-last compositing it is up to the user to ensure that the data distribution across the nodes is suitable. Specifically, each nodes’ data must be convex and disjoint. This renderer supports multiple volumes and geometries per node. To ensure they are composited correctly you specify a list of bounding regions to the model, within these regions can be arbitrary volumes/geometries and each rank can have as many regions as needed. As long as the regions are disjoint/convex the data will be rendered correctly. In this demo we either generate a volume, or load a RAW volume file if one is passed on the commandline.</p>
<h3 id="loading-a-raw-volume">Loading a RAW Volume</h3>
<p>To load a RAW volume you must specify the filename (<code>-f &lt;file&gt;</code>), the data type (<code>-dtype &lt;dtype&gt;</code>), the dimensions (<code>-dims &lt;x&gt; &lt;y&gt; &lt;z&gt;</code>) and the value range for the transfer function (<code>-range &lt;min&gt; &lt;max&gt;</code>). For example, to run on the <a href="http://www.ospray.org/demos.html#csafe-heptane-gas-dataset">CSAFE dataset from the demos page</a> you would pass the following arguments:</p>
<pre><code>mpirun -np &lt;n&gt; ./ospDistribViewerDemo \
    -f &lt;path to csafe&gt;/csafe-heptane-302-volume.raw \
    -dtype uchar -dims 302 302 302 -range 0 255</code></pre>
<p>The volume file will then be chunked up into an <code>x×y×z</code> grid such that <span class="math inline"><em>n</em> = <em>x</em><em>y</em><em>z</em></span>. See <code>loadVolume</code> in <a href="https://github.com/ospray/ospray/blob/devel/modules/mpi/apps/gensv/generateSciVis.cpp#L213">gensv/generateSciVis.cpp</a> for an example of how to properly load a volume distributed across ranks with correct specification of brick positions and ghost voxels for interpolation at boundaries. If no volume file data is passed a volume will be generated instead, in that case see <code>makeVolume</code>.</p>
<h3 id="geometry">Geometry</h3>
<p>The viewer can also display some randomly generated sphere geometry if you pass <code>-spheres &lt;n&gt;</code> where <code>n</code> is the number of spheres to generate per-node. These spheres will be generated inside the bounding box of the region’s volume data.</p>
<p>In the case that you have geometry crossing the boundary of nodes and are replicating it on both nodes to render (ghost zones, etc.) the region will be used by the renderer to clip rays against allowing to split the object between the two nodes, with each rendering half. This will keep the regions rendered by each rank disjoint and thus avoid any artifacts. For example, if a sphere center is on the border between two nodes, each would render half the sphere and the halves would be composited to produce the final complete sphere in the image.</p>
<h3 id="app-initialized-mpi">App-initialized MPI</h3>
<p>Passing the <code>-appMPI</code> flag will have the application initialize MPI instead of letting OSPRay do it internally when creating the MPI distributed device. In this case OSPRay will not finalize MPI when cleaning up the device, allowing the application to use OSPRay for some work, shut it down and recreate everything later if needed for additional computation, without accidentally shutting down its MPI communication.</p>
<h3 id="interactive-viewer">Interactive Viewer</h3>
<p>Rank 0 will open an interactive window with GLFW and display the rendered image. When the application state needs to update (e.g. camera or transfer function changes), this information is broadcasted out to the other nodes to update their scene data.</p>
<h2 id="demos">Demos</h2>
<p>Several ready-to-run demos, models and data sets for OSPRay can be found at the <a href="https://www.ospray.org/demos.html">OSPRay Demos and Examples</a> page.</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>For consecutive memory addresses the x-index of the corresponding voxel changes the quickest.<a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p>If there are multiple ambient lights then their contribution is added<a href="#fnref2" class="footnote-back">↩</a></p></li>
<li id="fn3"><p>The <a href="#hdri-light">HDRI light</a> is an exception, it knows about <code>intensity</code>, but not about <code>color</code>.<a href="#fnref3" class="footnote-back">↩</a></p></li>
<li id="fn4"><p>actually a parallelogram<a href="#fnref4" class="footnote-back">↩</a></p></li>
<li id="fn5"><p>respectively <span class="math inline">(127, 127, 255)</span> for 8 bit textures<a href="#fnref5" class="footnote-back">↩</a></p></li>
<li id="fn6"><p>This is currently not implemented, i.e. all channels of the framebuffer are always updated.<a href="#fnref6" class="footnote-back">↩</a></p></li>
<li id="fn7"><p>That way applications can also register a member function of a C++ class together with the <code>this</code> pointer as <code>userPtr</code>.<a href="#fnref7" class="footnote-back">↩</a></p></li>
<li id="fn8"><p>A C++ version that uses the C++ convenience wrappers of OSPRay’s C99 API via <code>include/ospray/ospray_cpp.h</code> is available at <code>apps/ospTutorial.cpp</code>.<a href="#fnref8" class="footnote-back">↩</a></p></li>
</ol>
</section>

      </div>
    </div>

      <div id="footer">
        © 2013–2019 Intel Corporation <a href="legal.html">Disclaimer and Legal Information</a>
        <a href="https://www.intel.com/privacy">Privacy</a>
      </div>
  </body>
</html>
