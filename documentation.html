<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html" charset="utf-8">
    <title>Intel OSPRay Documentation</title>
    <link rel="stylesheet" type="text/css" media="screen" href="stylesheet.css">
    <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
div.sourceCode { overflow-x: initial; }
    </style>

  </head>

  <body>
    <div id="header">
      <div id="header-github">
        <a id="forkme-banner" href="https://github.com/ospray/OSPRay">View on GitHub</a>
      </div>
      <div id="header-title">
        Intel<sup>&reg;</sup> OSPRay
      </div>

      <div id="header-navbar">
        <ul>
          <li><a href="index.html">Overview</a></li>
	  <li><a href="downloads.html">Downloads</a></li>
	  <li id="selected"><a href="documentation.html">Documentation</a></li>
	  <li><a href="tutorials.html">Tutorials</a></li>
	  <li><a href="gallery.html">Gallery</a></li>
	  <li><a href="https://github.com/ospray/OSPRay/issues">Bugs/Issues</a></li>
	  <li><a href="related_projects.html">Related Projects</a></li>
	</ul>
      </div>
      <div id="header-spacing"></div>
    </div>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#documentation">Documentation</a></li>
<li><a href="#ospray-api">OSPRay API</a>
<ul>
<li><a href="#initialization-and-shutdown">Initialization and Shutdown</a>
<ul>
<li><a href="#command-line-arguments">Command Line Arguments</a></li>
<li><a href="#manual-device-instantiation">Manual Device Instantiation</a></li>
<li><a href="#environment-variables">Environment Variables</a></li>
<li><a href="#error-handling-and-status-messages">Error Handling and Status Messages</a></li>
<li><a href="#loading-ospray-extensions-at-runtime">Loading OSPRay Extensions at Runtime</a></li>
<li><a href="#shutting-down-ospray">Shutting Down OSPRay</a></li>
</ul></li>
<li><a href="#objects">Objects</a>
<ul>
<li><a href="#parameters">Parameters</a></li>
<li><a href="#data">Data</a></li>
</ul></li>
<li><a href="#volumes">Volumes</a>
<ul>
<li><a href="#structured-regular-volume">Structured Regular Volume</a></li>
<li><a href="#structured-spherical-volume">Structured Spherical Volume</a></li>
<li><a href="#adaptive-mesh-refinement-amr-volume">Adaptive Mesh Refinement (AMR) Volume</a></li>
<li><a href="#unstructured-volume">Unstructured Volume</a></li>
<li><a href="#vdb-volume">VDB Volume</a></li>
<li><a href="#particle-volume">Particle Volume</a></li>
<li><a href="#transfer-function">Transfer Function</a></li>
<li><a href="#volumetricmodels">VolumetricModels</a></li>
</ul></li>
<li><a href="#geometries">Geometries</a>
<ul>
<li><a href="#mesh">Mesh</a></li>
<li><a href="#subdivision">Subdivision</a></li>
<li><a href="#spheres">Spheres</a></li>
<li><a href="#curves">Curves</a></li>
<li><a href="#boxes">Boxes</a></li>
<li><a href="#planes">Planes</a></li>
<li><a href="#isosurfaces">Isosurfaces</a></li>
<li><a href="#geometricmodels">GeometricModels</a></li>
</ul></li>
<li><a href="#lights">Lights</a>
<ul>
<li><a href="#directional-light-distant-light">Directional Light / Distant Light</a></li>
<li><a href="#point-light-sphere-light">Point Light / Sphere Light</a></li>
<li><a href="#spotlight-photometric-light">Spotlight / Photometric Light</a></li>
<li><a href="#quad-light">Quad Light</a></li>
<li><a href="#hdri-light">HDRI Light</a></li>
<li><a href="#ambient-light">Ambient Light</a></li>
<li><a href="#sun-sky-light">Sun-Sky Light</a></li>
<li><a href="#emissive-objects">Emissive Objects</a></li>
</ul></li>
<li><a href="#scene-hierarchy">Scene Hierarchy</a>
<ul>
<li><a href="#groups">Groups</a></li>
<li><a href="#instances">Instances</a></li>
<li><a href="#world">World</a></li>
</ul></li>
<li><a href="#renderers">Renderers</a>
<ul>
<li><a href="#scivis-renderer">SciVis Renderer</a></li>
<li><a href="#ambient-occlusion-renderer">Ambient Occlusion Renderer</a></li>
<li><a href="#path-tracer">Path Tracer</a></li>
<li><a href="#materials">Materials</a></li>
<li><a href="#texture">Texture</a></li>
<li><a href="#cameras">Cameras</a></li>
<li><a href="#picking">Picking</a></li>
</ul></li>
<li><a href="#framebuffer">Framebuffer</a>
<ul>
<li><a href="#image-operation">Image Operation</a></li>
</ul></li>
<li><a href="#rendering">Rendering</a>
<ul>
<li><a href="#asynchronous-rendering">Asynchronous Rendering</a></li>
<li><a href="#asynchronously-rendering-and-ospcommit">Asynchronously Rendering and ospCommit()</a></li>
<li><a href="#synchronous-rendering">Synchronous Rendering</a></li>
</ul></li>
<li><a href="#distributed-rendering-with-mpi">Distributed rendering with MPI</a></li>
</ul></li>
</ul>
</nav>

    <div id="content-wrap">
      <div id="content-wtoc">

<h1 id="documentation">Documentation</h1>
<p>The following <a href="http://www.sdvis.org/ospray/download/OSPRay_readme.pdf" title="OSPRay Documentation">API documentation</a> of OSPRay can also be found as a <a href="http://www.sdvis.org/ospray/download/OSPRay_readme.pdf" title="OSPRay Documentation">pdf document</a>.</p>
<p>For a deeper explanation of the concepts, design, features and performance of OSPRay also have a look at the IEEE Vis 2016 paper “<a href="http://www.sdvis.org/ospray/download/talks/IEEEVis2016_OSPRay_paper.pdf">OSPRay – A CPU Ray Tracing Framework for Scientific Visualization</a>” (49MB, or get the <a href="http://www.sdvis.org/ospray/download/talks/IEEEVis2016_OSPRay_paper_small.pdf">smaller version</a> 1.8MB). The <a href="http://www.sdvis.org/ospray/download/talks/IEEEVis2016_OSPRay_talk.pdf">slides of the talk</a> (5.2MB) are also available.</p>
<h1 id="ospray-api">OSPRay API</h1>
<p>To access the OSPRay API you first need to include the OSPRay header</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&quot;ospray/ospray.h&quot;</span></span></code></pre></div>
<p>where the API is compatible with C99 and C++.</p>
<h2 id="initialization-and-shutdown">Initialization and Shutdown</h2>
<p>To use the API, OSPRay must be initialized with a “device”. A device is the object which implements the API. Creating and initializing a device can be done in either of two ways: command line arguments using <code>ospInit</code> or manually instantiating a device and setting parameters on it.</p>
<h3 id="command-line-arguments">Command Line Arguments</h3>
<p>The first is to do so by giving OSPRay the command line from <code>main()</code> by calling</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a>OSPError ospInit(<span class="dt">int</span> *argc, <span class="at">const</span> <span class="dt">char</span> **argv);</span></code></pre></div>
<p>OSPRay parses (and removes) its known command line parameters from your application’s <code>main</code> function. For an example see the <a href="tutorials.html#osptutorial">tutorial</a>. For possible error codes see section <a href="#error-handling-and-status-messages">Error Handling and Status Messages</a>. It is important to note that the arguments passed to <code>ospInit()</code> are processed in order they are listed. The following parameters (which are prefixed by convention with “<code>--osp:</code>”) are understood:</p>
<table style="width:98%;">
<caption>Command line parameters accepted by OSPRay’s <code>ospInit</code>.</caption>
<colgroup>
<col style="width: 53%" />
<col style="width: 44%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Parameter</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>--osp:debug</code></td>
<td style="text-align: left;">enables various extra checks and debug output, and disables multi-threading</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>--osp:num-threads=&lt;n&gt;</code></td>
<td style="text-align: left;">use <code>n</code> threads instead of per default using all detected hardware threads</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>--osp:log-level=&lt;str&gt;</code></td>
<td style="text-align: left;">set logging level; valid values (in order of severity) are <code>none</code>, <code>error</code>, <code>warning</code>, <code>info</code>, and <code>debug</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>--osp:warn-as-error</code></td>
<td style="text-align: left;">send <code>warning</code> and <code>error</code> messages through the error callback, otherwise send <code>warning</code> messages through the message callback; must have sufficient <code>logLevel</code> to enable warnings</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>--osp:verbose</code></td>
<td style="text-align: left;">shortcut for <code>--osp:log-level=info</code> and enable debug output on <code>cout</code>, error output on <code>cerr</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>--osp:vv</code></td>
<td style="text-align: left;">shortcut for <code>--osp:log-level=debug</code> and enable debug output on <code>cout</code>, error output on <code>cerr</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>--osp:load-modules=&lt;name&gt;[,...]</code></td>
<td style="text-align: left;">load one or more modules during initialization; equivalent to calling <code>ospLoadModule(name)</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>--osp:log-output=&lt;dst&gt;</code></td>
<td style="text-align: left;">convenience for setting where status messages go; valid values for <code>dst</code> are <code>cerr</code> and <code>cout</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>--osp:error-output=&lt;dst&gt;</code></td>
<td style="text-align: left;">convenience for setting where error messages go; valid values for <code>dst</code> are <code>cerr</code> and <code>cout</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>--osp:device=&lt;name&gt;</code></td>
<td style="text-align: left;">use <code>name</code> as the type of device for OSPRay to create; e.g., <code>--osp:device=cpu</code> gives you the default <code>cpu</code> device; Note if the device to be used is defined in a module, remember to pass <code>--osp:load-modules=&lt;name&gt;</code> first</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>--osp:set-affinity=&lt;n&gt;</code></td>
<td style="text-align: left;">if <code>1</code>, bind software threads to hardware threads; <code>0</code> disables binding; default is <code>1</code> on KNL and <code>0</code> otherwise</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>--osp:device-params=&lt;param&gt;:&lt;value&gt;[,...]</code></td>
<td style="text-align: left;">set one or more other device parameters; equivalent to calling <code>ospDeviceSet*(param, value)</code></td>
</tr>
</tbody>
</table>
<h3 id="manual-device-instantiation">Manual Device Instantiation</h3>
<p>The second method of initialization is to explicitly create the device and possibly set parameters. This method looks almost identical to how other <a href="#objects">objects</a> are created and used by OSPRay (described in later sections). The first step is to create the device with</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a>OSPDevice ospNewDevice(<span class="at">const</span> <span class="dt">char</span> *type);</span></code></pre></div>
<p>where the <code>type</code> string maps to a specific device implementation. OSPRay always provides the “<code>cpu</code>” device, which maps to a fast, local CPU implementation. Other devices can also be added through additional modules, such as distributed MPI device implementations.</p>
<p>Once a device is created, you can call</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="dt">void</span> ospDeviceSetParam(OSPObject, <span class="at">const</span> <span class="dt">char</span> *id, OSPDataType type, <span class="at">const</span> <span class="dt">void</span> *mem);</span></code></pre></div>
<p>to set parameters on the device. The semantics of setting parameters is exactly the same as <code>ospSetParam</code>, which is documented below in the <a href="#parameters">parameters</a> section. The following parameters can be set on all devices:</p>
<table style="width:97%;">
<caption>Parameters shared by all devices.</caption>
<colgroup>
<col style="width: 11%" />
<col style="width: 18%" />
<col style="width: 67%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">int</td>
<td style="text-align: left;">numThreads</td>
<td style="text-align: left;">number of threads which OSPRay should use</td>
</tr>
<tr class="even">
<td style="text-align: left;">int</td>
<td style="text-align: left;">logLevel</td>
<td style="text-align: left;">logging level; valid values (in order of severity) are <code>OSP_LOG_NONE</code>, <code>OSP_LOG_ERROR</code>, <code>OSP_LOG_WARNING</code>, <code>OSP_LOG_INFO</code>, and <code>OSP_LOG_DEBUG</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">string</td>
<td style="text-align: left;">logOutput</td>
<td style="text-align: left;">convenience for setting where status messages go; valid values are <code>cerr</code> and <code>cout</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">string</td>
<td style="text-align: left;">errorOutput</td>
<td style="text-align: left;">convenience for setting where error messages go; valid values are <code>cerr</code> and <code>cout</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">bool</td>
<td style="text-align: left;">debug</td>
<td style="text-align: left;">set debug mode; equivalent to <code>logLevel=debug</code> and <code>numThreads=1</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">bool</td>
<td style="text-align: left;">warnAsError</td>
<td style="text-align: left;">send <code>warning</code> and <code>error</code> messages through the error callback, otherwise send <code>warning</code> messages through the message callback; must have sufficient <code>logLevel</code> to enable warnings</td>
</tr>
<tr class="odd">
<td style="text-align: left;">bool</td>
<td style="text-align: left;">setAffinity</td>
<td style="text-align: left;">bind software threads to hardware threads if set to 1; 0 disables binding omitting the parameter will let OSPRay choose</td>
</tr>
</tbody>
</table>
<p>Once parameters are set on the created device, the device must be committed with</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="dt">void</span> ospDeviceCommit(OSPDevice);</span></code></pre></div>
<p>To use the newly committed device, you must call</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="dt">void</span> ospSetCurrentDevice(OSPDevice);</span></code></pre></div>
<p>This then sets the given device as the object which will respond to all other OSPRay API calls.</p>
<p>Device handle lifetimes are managed with two calls, the first which increments the internal reference count to the given <code>OSPDevice</code></p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="dt">void</span> ospDeviceRetain(OSPDevice)</span></code></pre></div>
<p>and the second which decrements the reference count</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="dt">void</span> ospDeviceRelease(OSPDevice)</span></code></pre></div>
<p>Users can change parameters on the device after initialization (from either method above), by calling</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a>OSPDevice ospGetCurrentDevice();</span></code></pre></div>
<p>This function returns the handle to the device currently used to respond to OSPRay API calls, where users can set/change parameters and recommit the device. If changes are made to the device that is already set as the current device, it does not need to be set as current again. Note this API call will increment the ref count of the returned device handle, so applications must use <code>ospDeviceRelease</code> when finished using the handle to avoid leaking the underlying device object. If there is no current device set, this will return an invalid NULL handle.</p>
<p>When a device is created, its reference count is initially <code>1</code>. When a device is set as the current device, it internally has its reference count incremented. Note that <code>ospDeviceRetain</code> and <code>ospDeviceRelease</code> should only be used with reference counts that the application tracks: removing reference held by the current set device should be handled by <code>ospShutdown</code>. Thus, <code>ospDeviceRelease</code> should only decrement the reference counts that come from <code>ospNewDevice</code>, <code>ospGetCurrentDevice</code>, and the number of explicit calls to <code>ospDeviceRetain</code>.</p>
<p>OSPRay allows applications to query runtime properties of a device in order to do enhanced validation of what device was loaded at runtime. The following function can be used to get these device-specific properties (attributes about the device, not parameter values)</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="dt">int64_t</span> ospDeviceGetProperty(OSPDevice, OSPDeviceProperty);</span></code></pre></div>
<p>It returns an integer value of the queried property and the following properties can be provided as parameter:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a>OSP_DEVICE_VERSION</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a>OSP_DEVICE_VERSION_MAJOR</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a>OSP_DEVICE_VERSION_MINOR</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a>OSP_DEVICE_VERSION_PATCH</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a>OSP_DEVICE_SO_VERSION</span></code></pre></div>
<h3 id="environment-variables">Environment Variables</h3>
<p>OSPRay’s generic device parameters can be overridden via environment variables for easy changes to OSPRay’s behavior without needing to change the application (variables are prefixed by convention with “<code>OSPRAY_</code>”):</p>
<table style="width:97%;">
<caption>Environment variables interpreted by OSPRay.</caption>
<colgroup>
<col style="width: 30%" />
<col style="width: 66%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Variable</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">OSPRAY_NUM_THREADS</td>
<td style="text-align: left;">equivalent to <code>--osp:num-threads</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">OSPRAY_LOG_LEVEL</td>
<td style="text-align: left;">equivalent to <code>--osp:log-level</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSPRAY_LOG_OUTPUT</td>
<td style="text-align: left;">equivalent to <code>--osp:log-output</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">OSPRAY_ERROR_OUTPUT</td>
<td style="text-align: left;">equivalent to <code>--osp:error-output</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSPRAY_DEBUG</td>
<td style="text-align: left;">equivalent to <code>--osp:debug</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">OSPRAY_WARN_AS_ERROR</td>
<td style="text-align: left;">equivalent to <code>--osp:warn-as-error</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSPRAY_SET_AFFINITY</td>
<td style="text-align: left;">equivalent to <code>--osp:set-affinity</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">OSPRAY_LOAD_MODULES</td>
<td style="text-align: left;">equivalent to <code>--osp:load-modules</code>, can be a comma separated list of modules which will be loaded in order</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSPRAY_DEVICE</td>
<td style="text-align: left;">equivalent to <code>--osp:device:</code></td>
</tr>
</tbody>
</table>
<p>Note that these environment variables take precedence over values specified through <code>ospInit</code> or manually set device parameters.</p>
<h3 id="error-handling-and-status-messages">Error Handling and Status Messages</h3>
<p>The following errors are currently used by OSPRay:</p>
<table>
<caption>Possible error codes, i.e., valid named constants of type <code>OSPError</code>.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">OSP_NO_ERROR</td>
<td style="text-align: left;">no error occurred</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_UNKNOWN_ERROR</td>
<td style="text-align: left;">an unknown error occurred</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_INVALID_ARGUMENT</td>
<td style="text-align: left;">an invalid argument was specified</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_INVALID_OPERATION</td>
<td style="text-align: left;">the operation is not allowed for the specified object</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_OUT_OF_MEMORY</td>
<td style="text-align: left;">there is not enough memory to execute the command</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_UNSUPPORTED_CPU</td>
<td style="text-align: left;">the CPU is not supported (minimum ISA is SSE4.1)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_VERSION_MISMATCH</td>
<td style="text-align: left;">a module could not be loaded due to mismatching version</td>
</tr>
</tbody>
</table>
<p>These error codes are either directly return by some API functions, or are recorded to be later queried by the application via</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a>OSPError ospDeviceGetLastErrorCode(OSPDevice);</span></code></pre></div>
<p>A more descriptive error message can be queried by calling</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="at">const</span> <span class="dt">char</span>* ospDeviceGetLastErrorMsg(OSPDevice);</span></code></pre></div>
<p>Alternatively, the application can also register a callback function of type</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a><span class="kw">typedef</span> <span class="dt">void</span> (*OSPErrorCallback)(<span class="dt">void</span> *userData, OSPError, <span class="at">const</span> <span class="dt">char</span>* errorDetails);</span></code></pre></div>
<p>via</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a><span class="dt">void</span> ospDeviceSetErrorCallback(OSPDevice, OSPErrorCallback, <span class="dt">void</span> *userData);</span></code></pre></div>
<p>to get notified when errors occur.</p>
<p>Applications may be interested in messages which OSPRay emits, whether for debugging or logging events. Applications can call</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a><span class="dt">void</span> ospDeviceSetStatusCallback(OSPDevice, OSPStatusCallback, <span class="dt">void</span> *userData);</span></code></pre></div>
<p>in order to register a callback function of type</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a><span class="kw">typedef</span> <span class="dt">void</span> (*OSPStatusCallback)(<span class="dt">void</span> *userData, <span class="at">const</span> <span class="dt">char</span>* messageText);</span></code></pre></div>
<p>which OSPRay will use to emit status messages. By default, OSPRay uses a callback which does nothing, so any output desired by an application will require that a callback is provided. Note that callbacks for C++ <code>std::cout</code> and <code>std::cerr</code> can be alternatively set through <code>ospInit()</code> or the <code>OSPRAY_LOG_OUTPUT</code> environment variable.</p>
<p>Applications can clear either callback by passing <code>nullptr</code> instead of an actual function pointer.</p>
<h3 id="loading-ospray-extensions-at-runtime">Loading OSPRay Extensions at Runtime</h3>
<p>OSPRay’s functionality can be extended via plugins (which we call “modules”), which are implemented in shared libraries. To load module <code>name</code> from <code>libospray_module_&lt;name&gt;.so</code> (on Linux and Mac OS X) or <code>ospray_module_&lt;name&gt;.dll</code> (on Windows) use</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a>OSPError ospLoadModule(<span class="at">const</span> <span class="dt">char</span> *name);</span></code></pre></div>
<p>Modules are searched in OS-dependent paths. <code>ospLoadModule</code> returns <code>OSP_NO_ERROR</code> if the plugin could be successfully loaded.</p>
<h3 id="shutting-down-ospray">Shutting Down OSPRay</h3>
<p>When the application is finished using OSPRay (typically on application exit), the OSPRay API should be finalized with</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a><span class="dt">void</span> ospShutdown();</span></code></pre></div>
<p>This API call ensures that the current device is cleaned up appropriately. Due to static object allocation having non-deterministic ordering, it is recommended that applications call <code>ospShutdown()</code> before the calling application process terminates.</p>
<h2 id="objects">Objects</h2>
<p>All entities of OSPRay (the <a href="documentation.html#renderers">renderer</a>, <a href="#volumes">volumes</a>, <a href="#geometries">geometries</a>, <a href="#lights">lights</a>, <a href="#cameras">cameras</a>, …) are a logical specialization of <code>OSPObject</code> and share common mechanism to deal with parameters and lifetime.</p>
<p>An important aspect of object parameters is that parameters do not get passed to objects immediately. Instead, parameters are not visible at all to objects until they get explicitly committed to a given object via a call to</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a><span class="dt">void</span> ospCommit(OSPObject);</span></code></pre></div>
<p>at which time all previously additions or changes to parameters are visible at the same time. If a user wants to change the state of an existing object (e.g., to change the origin of an already existing camera) it is perfectly valid to do so, as long as the changed parameters are recommitted.</p>
<p>The commit semantic allow for batching up multiple small changes, and specifies exactly when changes to objects will occur. This can impact performance and consistency for devices crossing a PCI bus or across a network.</p>
<p>Note that OSPRay uses reference counting to manage the lifetime of all objects, so one cannot explicitly “delete” any object. Instead, to indicate that the application does not need and does not access the given object anymore, call</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a><span class="dt">void</span> ospRelease(OSPObject);</span></code></pre></div>
<p>This decreases its reference count and if the count reaches <code>0</code> the object will automatically get deleted. Passing <code>NULL</code> is not an error. Note that every handle returned via the API needs to be released when the object is no longer needed, to avoid memory leaks.</p>
<p>Sometimes applications may want to have more than one reference to an object, where it is desirable for the application to increment the reference count of an object. This is done with</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a><span class="dt">void</span> ospRetain(OSPObject);</span></code></pre></div>
<p>It is important to note that this is only necessary if the application wants to call <code>ospRelease</code> on an object more than once: objects which contain other objects as parameters internally increment/decrement ref counts and should not be explicitly done by the application.</p>
<h3 id="parameters">Parameters</h3>
<p>Parameters allow to configure the behavior of and to pass data to objects. However, objects do <em>not</em> have an explicit interface for reasons of high flexibility and a more stable compile-time API. Instead, parameters are passed separately to objects in an arbitrary order, and unknown parameters will simply be ignored (though a warning message will be posted). The following function allows adding various types of parameters with name <code>id</code> to a given object:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true"></a><span class="dt">void</span> ospSetParam(OSPObject, <span class="at">const</span> <span class="dt">char</span> *id, OSPDataType type, <span class="at">const</span> <span class="dt">void</span> *mem);</span></code></pre></div>
<p>The valid parameter names for all <code>OSPObject</code>s and what types are valid are discussed in future sections.</p>
<p>Note that <code>mem</code> must always be a pointer <em>to</em> the object, otherwise accidental type casting can occur. This is especially true for pointer types (<code>OSP_VOID_PTR</code> and <code>OSPObject</code> handles), as they will implicitly cast to <code>void *</code>, but be incorrectly interpreted. To help with some of these issues, there also exist variants of <code>ospSetParam</code> for specific types, such as <code>ospSetInt</code> and <code>ospSetVec3f</code> in the OSPRay utility library (found in <code>ospray_util.h</code>).</p>
<p>Users can also remove parameters that have been explicitly set from <code>ospSetParam</code>. Any parameters which have been removed will go back to their default value during the next commit unless a new parameter was set after the parameter was removed. To remove a parameter, use</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true"></a><span class="dt">void</span> ospRemoveParam(OSPObject, <span class="at">const</span> <span class="dt">char</span> *id);</span></code></pre></div>
<h3 id="data">Data</h3>
<p>OSPRay consumes data arrays from the application using a specific object type, <code>OSPData</code>. There are several components to describing a data array: element type, 1/2/3 dimensional striding, and whether the array is shared with the application or copied into opaque, OSPRay-owned memory.</p>
<p>Shared data arrays require that the application’s array memory outlives the lifetime of the created <code>OSPData</code>, as OSPRay is referring to application memory. Where this is not preferable, applications use opaque arrays to allow the <code>OSPData</code> to own the lifetime of the array memory. However, opaque arrays dictate the cost of copying data into it, which should be kept in mind.</p>
<p>Thus, the most efficient way to specify a data array from the application is to created a shared data array, which is done with</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true"></a>OSPData ospNewSharedData(<span class="at">const</span> <span class="dt">void</span> *sharedData,</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true"></a>    OSPDataType,</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true"></a>    <span class="dt">uint64_t</span> numItems1,</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true"></a>    <span class="dt">int64_t</span> byteStride1 = <span class="dv">0</span>,</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true"></a>    <span class="dt">uint64_t</span> numItems2 = <span class="dv">1</span>,</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true"></a>    <span class="dt">int64_t</span> byteStride2 = <span class="dv">0</span>,</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true"></a>    <span class="dt">uint64_t</span> numItems3 = <span class="dv">1</span>,</span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true"></a>    <span class="dt">int64_t</span> byteStride3 = <span class="dv">0</span>);</span></code></pre></div>
<p>The call returns an <code>OSPData</code> handle to the created array. The calling program guarantees that the <code>sharedData</code> pointer will remain valid for the duration that this data array is being used. The number of elements <code>numItems</code> must be positive (there cannot be an empty data object). The data is arranged in three dimensions, with specializations to two or one dimension (if some <code>numItems</code> are 1). The distance between consecutive elements (per dimension) is given in bytes with <code>byteStride</code> and can also be negative. If <code>byteStride</code> is zero it will be determined automatically (e.g., as <code>sizeof(type)</code>). Strides do not need to be ordered, i.e., <code>byteStride2</code> can be smaller than <code>byteStride1</code>, which is equivalent to a transpose. However, if the stride should be calculated, then an ordering in dimensions is assumed to disambiguate, i.e., <code>byteStride1 &lt; byteStride2 &lt; byteStride3</code>.</p>
<p>The enum type <code>OSPDataType</code> describes the different element types that can be represented in OSPRay; valid constants are listed in the table below.</p>
<table>
<caption>Valid named constants for <code>OSPDataType</code>.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Type/Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">OSP_DEVICE</td>
<td style="text-align: left;">API device object reference</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_DATA</td>
<td style="text-align: left;">data reference</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_OBJECT</td>
<td style="text-align: left;">generic object reference</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_CAMERA</td>
<td style="text-align: left;">camera object reference</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_FRAMEBUFFER</td>
<td style="text-align: left;">framebuffer object reference</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_LIGHT</td>
<td style="text-align: left;">light object reference</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_MATERIAL</td>
<td style="text-align: left;">material object reference</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_TEXTURE</td>
<td style="text-align: left;">texture object reference</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_RENDERER</td>
<td style="text-align: left;">renderer object reference</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_WORLD</td>
<td style="text-align: left;">world object reference</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_GEOMETRY</td>
<td style="text-align: left;">geometry object reference</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_VOLUME</td>
<td style="text-align: left;">volume object reference</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_TRANSFER_FUNCTION</td>
<td style="text-align: left;">transfer function object reference</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_IMAGE_OPERATION</td>
<td style="text-align: left;">image operation object reference</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_STRING</td>
<td style="text-align: left;">C-style zero-terminated character string</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_CHAR</td>
<td style="text-align: left;">8 bit signed character scalar</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_UCHAR</td>
<td style="text-align: left;">8 bit unsigned character scalar</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_VEC[234]UC</td>
<td style="text-align: left;">… and [234]-element vector</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_USHORT</td>
<td style="text-align: left;">16 bit unsigned integer scalar</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_VEC[234]US</td>
<td style="text-align: left;">… and [234]-element vector</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_INT</td>
<td style="text-align: left;">32 bit signed integer scalar</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_VEC[234]I</td>
<td style="text-align: left;">… and [234]-element vector</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_UINT</td>
<td style="text-align: left;">32 bit unsigned integer scalar</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_VEC[234]UI</td>
<td style="text-align: left;">… and [234]-element vector</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_LONG</td>
<td style="text-align: left;">64 bit signed integer scalar</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_VEC[234]L</td>
<td style="text-align: left;">… and [234]-element vector</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_ULONG</td>
<td style="text-align: left;">64 bit unsigned integer scalar</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_VEC[234]UL</td>
<td style="text-align: left;">… and [234]-element vector</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_FLOAT</td>
<td style="text-align: left;">32 bit single precision floating-point scalar</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_VEC[234]F</td>
<td style="text-align: left;">… and [234]-element vector</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_DOUBLE</td>
<td style="text-align: left;">64 bit double precision floating-point scalar</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_BOX[1234]I</td>
<td style="text-align: left;">32 bit integer box (lower + upper bounds)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_BOX[1234]F</td>
<td style="text-align: left;">32 bit single precision floating-point box (lower + upper bounds)</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_LINEAR[23]F</td>
<td style="text-align: left;">32 bit single precision floating-point linear transform ([23] vectors)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_AFFINE[23]F</td>
<td style="text-align: left;">32 bit single precision floating-point affine transform (linear transform plus translation)</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_VOID_PTR</td>
<td style="text-align: left;">raw memory address (only found in module extensions)</td>
</tr>
</tbody>
</table>
<p>If the elements of the array are handles to objects, then their reference counter is incremented.</p>
<p>An opaque <code>OSPData</code> with memory allocated by OSPRay is created with</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true"></a>OSPData ospNewData(OSPDataType,</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true"></a>    <span class="dt">uint32_t</span> numItems1,</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true"></a>    <span class="dt">uint32_t</span> numItems2 = <span class="dv">1</span>,</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true"></a>    <span class="dt">uint32_t</span> numItems3 = <span class="dv">1</span>);</span></code></pre></div>
<p>To allow for (partial) copies or updates of data arrays use</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true"></a><span class="dt">void</span> ospCopyData(<span class="at">const</span> OSPData source,</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true"></a>    OSPData destination,</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true"></a>    <span class="dt">uint32_t</span> destinationIndex1 = <span class="dv">0</span>,</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true"></a>    <span class="dt">uint32_t</span> destinationIndex2 = <span class="dv">0</span>,</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true"></a>    <span class="dt">uint32_t</span> destinationIndex3 = <span class="dv">0</span>);</span></code></pre></div>
<p>which will copy the whole<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> content of the <code>source</code> array into <code>destination</code> at the given location <code>destinationIndex</code>. The <code>OSPDataType</code>s of the data objects must match. The region to be copied must be valid inside the destination, i.e., in all dimensions, <code>destinationIndex + sourceSize &lt;= destinationSize</code>. The affected region <code>[destinationIndex, destinationIndex + sourceSize)</code> is marked as dirty, which may be used by OSPRay to only process or update that sub-region (e.g., updating an acceleration structure). If the destination array is shared with OSPData by the application (created with <code>ospNewSharedData</code>), then</p>
<ul>
<li>the source array must be shared as well (thus <code>ospCopyData</code> cannot be used to read opaque data)</li>
<li>if source and destination memory overlaps (aliasing), then behavior is undefined</li>
<li>except if source and destination regions are identical (including matching strides), which can be used by application to mark that region as dirty (instead of the whole <code>OSPData</code>)</li>
</ul>
<p>To add a data array as parameter named <code>id</code> to another object call also use</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true"></a><span class="dt">void</span> ospSetObject(OSPObject, <span class="at">const</span> <span class="dt">char</span> *id, OSPData);</span></code></pre></div>
<h2 id="volumes">Volumes</h2>
<p>Volumes are volumetric data sets with discretely sampled values in 3D space, typically a 3D scalar field. To create a new volume object of given type <code>type</code> use</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true"></a>OSPVolume ospNewVolume(<span class="at">const</span> <span class="dt">char</span> *type);</span></code></pre></div>
<p>Note that OSPRay’s implementation forwards <code>type</code> directly to Open VKL, allowing new Open VKL volume types to be usable within OSPRay without the need to change (or even recompile) OSPRay.</p>
<h3 id="structured-regular-volume">Structured Regular Volume</h3>
<p>Structured volumes only need to store the values of the samples, because their addresses in memory can be easily computed from a 3D position. A common type of structured volumes are regular grids.</p>
<p>Structured regular volumes are created by passing the type string “<code>structuredRegular</code>” to <code>ospNewVolume</code>. Structured volumes are represented through an <code>OSPData</code> 3D array <code>data</code> (which may or may not be shared with the application). The voxel data must be laid out in xyz-order<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> and can be compact (best for performance) or can have a stride between voxels, specified through the <code>byteStride1</code> parameter when creating the <code>OSPData</code>. Only 1D strides are supported, additional strides between scanlines (2D, <code>byteStride2</code>) and slices (3D, <code>byteStride3</code>) are not.</p>
<p>The parameters understood by structured volumes are summarized in the table below.</p>
<table style="width:98%;">
<caption>Configuration parameters for structured regular volumes.</caption>
<colgroup>
<col style="width: 10%" />
<col style="width: 17%" />
<col style="width: 33%" />
<col style="width: 35%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: right;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">gridOrigin</td>
<td style="text-align: right;"><span class="math inline">(0, 0, 0)</span></td>
<td style="text-align: left;">origin of the grid in object-space</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">gridSpacing</td>
<td style="text-align: right;"><span class="math inline">(1, 1, 1)</span></td>
<td style="text-align: left;">size of the grid cells in object-space</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSPData</td>
<td style="text-align: left;">data</td>
<td style="text-align: right;"></td>
<td style="text-align: left;">the actual voxel 3D <a href="documentation.html#data">data</a></td>
</tr>
<tr class="even">
<td style="text-align: left;">int</td>
<td style="text-align: left;">filter</td>
<td style="text-align: right;"><code>OSP_VOLUME_FILTER_TRILINEAR</code></td>
<td style="text-align: left;">filter used for reconstructing the field, also allowed is <code>OSP_VOLUME_FILTER_NEAREST</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">int</td>
<td style="text-align: left;">gradientFilter</td>
<td style="text-align: right;">same as <code>filter</code></td>
<td style="text-align: left;">filter used during gradient computations</td>
</tr>
</tbody>
</table>
<p>The size of the volume is inferred from the size of the 3D array <code>data</code>, as is the type of the voxel values (currently supported are: <code>OSP_UCHAR</code>, <code>OSP_SHORT</code>, <code>OSP_USHORT</code>, <code>OSP_FLOAT</code>, and <code>OSP_DOUBLE</code>).</p>
<h3 id="structured-spherical-volume">Structured Spherical Volume</h3>
<p>Structured spherical volumes are also supported, which are created by passing a type string of “<code>structuredSpherical</code>” to <code>ospNewVolume</code>. The grid dimensions and parameters are defined in terms of radial distance <span class="math inline"><em>r</em></span>, inclination angle <span class="math inline"><em>θ</em></span>, and azimuthal angle <span class="math inline"><em>ϕ</em></span>, conforming with the ISO convention for spherical coordinate systems. The coordinate system and parameters understood by structured spherical volumes are summarized below.</p>
<figure>
<img src="images/structured_spherical_coords.png" style="width:60.0%" alt="Coordinate system of structured spherical volumes." /><figcaption aria-hidden="true">Coordinate system of structured spherical volumes.</figcaption>
</figure>
<table style="width:98%;">
<caption>Configuration parameters for structured spherical volumes.</caption>
<colgroup>
<col style="width: 10%" />
<col style="width: 17%" />
<col style="width: 33%" />
<col style="width: 35%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: right;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">gridOrigin</td>
<td style="text-align: right;"><span class="math inline">(0, 0, 0)</span></td>
<td style="text-align: left;">origin of the grid in units of <span class="math inline">(<em>r</em>, <em>θ</em>, <em>ϕ</em>)</span>; angles in degrees</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">gridSpacing</td>
<td style="text-align: right;"><span class="math inline">(1, 1, 1)</span></td>
<td style="text-align: left;">size of the grid cells in units of <span class="math inline">(<em>r</em>, <em>θ</em>, <em>ϕ</em>)</span>; angles in degrees</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSPData</td>
<td style="text-align: left;">data</td>
<td style="text-align: right;"></td>
<td style="text-align: left;">the actual voxel 3D <a href="documentation.html#data">data</a></td>
</tr>
<tr class="even">
<td style="text-align: left;">int</td>
<td style="text-align: left;">filter</td>
<td style="text-align: right;"><code>OSP_VOLUME_FILTER_TRILINEAR</code></td>
<td style="text-align: left;">filter used for reconstructing the field, also allowed is <code>OSP_VOLUME_FILTER_NEAREST</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">int</td>
<td style="text-align: left;">gradientFilter</td>
<td style="text-align: right;">same as <code>filter</code></td>
<td style="text-align: left;">filter used during gradient computations</td>
</tr>
</tbody>
</table>
<p>The dimensions <span class="math inline">(<em>r</em>, <em>θ</em>, <em>ϕ</em>)</span> of the volume are inferred from the size of the 3D array <code>data</code>, as is the type of the voxel values (currently supported are: <code>OSP_UCHAR</code>, <code>OSP_SHORT</code>, <code>OSP_USHORT</code>, <code>OSP_FLOAT</code>, and <code>OSP_DOUBLE</code>).</p>
<p>These grid parameters support flexible specification of spheres, hemispheres, spherical shells, spherical wedges, and so forth. The grid extents (computed as <code>[gridOrigin, gridOrigin + (dimensions - 1) * gridSpacing]</code>) however must be constrained such that:</p>
<ul>
<li><span class="math inline"><em>r</em> ≥ 0</span></li>
<li><span class="math inline">0 ≤ <em>θ</em> ≤ 180</span></li>
<li><span class="math inline">0 ≤ <em>ϕ</em> ≤ 360</span></li>
</ul>
<h3 id="adaptive-mesh-refinement-amr-volume">Adaptive Mesh Refinement (AMR) Volume</h3>
<p>OSPRay currently supports block-structured (Berger-Colella) AMR volumes. Volumes are specified as a list of blocks, which exist at levels of refinement in potentially overlapping regions. Blocks exist in a tree structure, with coarser refinement level blocks containing finer blocks. The cell width is equal for all blocks at the same refinement level, though blocks at a coarser level have a larger cell width than finer levels.</p>
<p>There can be any number of refinement levels and any number of blocks at any level of refinement. An AMR volume type is created by passing the type string “<code>amr</code>” to <code>ospNewVolume</code>.</p>
<p>Blocks are defined by three parameters: their bounds, the refinement level in which they reside, and the scalar data contained within each block.</p>
<p>Note that cell widths are defined <em>per refinement level</em>, not per block.</p>
<table style="width:98%;">
<caption>Configuration parameters for AMR volumes.</caption>
<colgroup>
<col style="width: 19%" />
<col style="width: 17%" />
<col style="width: 22%" />
<col style="width: 38%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: right;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>OSPAMRMethod</code></td>
<td style="text-align: left;">method</td>
<td style="text-align: right;"><code>OSP_AMR_CURRENT</code></td>
<td style="text-align: left;"><code>OSPAMRMethod</code> sampling method. Supported methods are:</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: right;"></td>
<td style="text-align: left;"><code>OSP_AMR_CURRENT</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: right;"></td>
<td style="text-align: left;"><code>OSP_AMR_FINEST</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: right;"></td>
<td style="text-align: left;"><code>OSP_AMR_OCTANT</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">float[]</td>
<td style="text-align: left;">cellWidth</td>
<td style="text-align: right;">NULL</td>
<td style="text-align: left;">array of each level’s cell width</td>
</tr>
<tr class="even">
<td style="text-align: left;">box3i[]</td>
<td style="text-align: left;">block.bounds</td>
<td style="text-align: right;">NULL</td>
<td style="text-align: left;"><a href="documentation.html#data">data</a> array of grid sizes (in voxels) for each AMR block</td>
</tr>
<tr class="odd">
<td style="text-align: left;">int[]</td>
<td style="text-align: left;">block.level</td>
<td style="text-align: right;">NULL</td>
<td style="text-align: left;">array of each block’s refinement level</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSPData[]</td>
<td style="text-align: left;">block.data</td>
<td style="text-align: right;">NULL</td>
<td style="text-align: left;"><a href="documentation.html#data">data</a> array of OSPData containing the actual scalar voxel data, only <code>OSP_FLOAT</code> is supported as <code>OSPDataType</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">gridOrigin</td>
<td style="text-align: right;"><span class="math inline">(0, 0, 0)</span></td>
<td style="text-align: left;">origin of the grid in world-space</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">gridSpacing</td>
<td style="text-align: right;"><span class="math inline">(1, 1, 1)</span></td>
<td style="text-align: left;">size of the grid cells in world-space</td>
</tr>
</tbody>
</table>
<p>Lastly, note that the <code>gridOrigin</code> and <code>gridSpacing</code> parameters act just like the structured volume equivalent, but they only modify the root (coarsest level) of refinement.</p>
<p>In particular, OSPRay’s / Open VKL’s AMR implementation was designed to cover Berger-Colella [1] and Chombo [2] AMR data. The <code>method</code> parameter above determines the interpolation method used when sampling the volume.</p>
<dl>
<dt>OSP_AMR_CURRENT</dt>
<dd>finds the finest refinement level at that cell and interpolates through this “current” level
</dd>
<dt>OSP_AMR_FINEST</dt>
<dd>will interpolate at the closest existing cell in the volume-wide finest refinement level regardless of the sample cell’s level
</dd>
<dt>OSP_AMR_OCTANT</dt>
<dd>interpolates through all available refinement levels at that cell. This method avoids discontinuities at refinement level boundaries at the cost of performance
</dd>
</dl>
<p>Details and more information can be found in the publication for the implementation [3].</p>
<ol type="1">
<li>M.J. Berger and P. Colella, “Local adaptive mesh refinement for shock hydrodynamics.” Journal of Computational Physics 82.1 (1989): 64-84. DOI: 10.1016/0021-9991(89)90035-1</li>
<li>M. Adams, P. Colella, D.T. Graves, J.N. Johnson, N.D. Keen, T.J. Ligocki, D.F. Martin. P.W. McCorquodale, D. Modiano. P.O. Schwartz, T.D. Sternberg, and B. Van Straalen, “Chombo Software Package for AMR Applications – Design Document”, Lawrence Berkeley National Laboratory Technical Report LBNL-6616E.</li>
<li>I. Wald, C. Brownlee, W. Usher, and A. Knoll, “CPU volume rendering of adaptive mesh refinement data”. SIGGRAPH Asia 2017 Symposium on Visualization – SA ’17, 18(8), 1–8. DOI: 10.1145/3139295.3139305</li>
</ol>
<h3 id="unstructured-volume">Unstructured Volume</h3>
<p>Unstructured volumes can have their topology and geometry freely defined. Geometry can be composed of tetrahedral, hexahedral, wedge or pyramid cell types. The data format used is compatible with VTK and consists of multiple arrays: vertex positions and values, vertex indices, cell start indices, cell types, and cell values. An unstructured volume type is created by passing the type string “<code>unstructured</code>” to <code>ospNewVolume</code>.</p>
<p>Sampled cell values can be specified either per-vertex (<code>vertex.data</code>) or per-cell (<code>cell.data</code>). If both arrays are set, <code>cell.data</code> takes precedence.</p>
<p>Similar to a mesh, each cell is formed by a group of indices into the vertices. For each vertex, the corresponding (by array index) data value will be used for sampling when rendering, if specified. The index order for a tetrahedron is the same as <code>VTK_TETRA</code>: bottom triangle counterclockwise, then the top vertex.</p>
<p>For hexahedral cells, each hexahedron is formed by a group of eight indices into the vertices and data values. Vertex ordering is the same as <code>VTK_HEXAHEDRON</code>: four bottom vertices counterclockwise, then top four counterclockwise.</p>
<p>For wedge cells, each wedge is formed by a group of six indices into the vertices and data values. Vertex ordering is the same as <code>VTK_WEDGE</code>: three bottom vertices counterclockwise, then top three counterclockwise.</p>
<p>For pyramid cells, each cell is formed by a group of five indices into the vertices and data values. Vertex ordering is the same as <code>VTK_PYRAMID</code>: four bottom vertices counterclockwise, then the top vertex.</p>
<p>To maintain VTK data compatibility, the <code>index</code> array may be specified with cell sizes interleaved with vertex indices in the following format: <span class="math inline"><em>n</em>, <em>i</em><em>d</em><sub>1</sub>, ..., <em>i</em><em>d</em><sub><em>n</em></sub>, <em>m</em>, <em>i</em><em>d</em><sub>1</sub>, ..., <em>i</em><em>d</em><sub><em>m</em></sub></span>. This alternative <code>index</code> array layout can be enabled through the <code>indexPrefixed</code> flag (in which case, the <code>cell.type</code> parameter must be omitted).</p>
<table style="width:98%;">
<caption>Configuration parameters for unstructured volumes.</caption>
<colgroup>
<col style="width: 19%" />
<col style="width: 25%" />
<col style="width: 12%" />
<col style="width: 40%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: right;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">vec3f[]</td>
<td style="text-align: left;">vertex.position</td>
<td style="text-align: right;"></td>
<td style="text-align: left;"><a href="documentation.html#data">data</a> array of vertex positions</td>
</tr>
<tr class="even">
<td style="text-align: left;">float[]</td>
<td style="text-align: left;">vertex.data</td>
<td style="text-align: right;"></td>
<td style="text-align: left;"><a href="documentation.html#data">data</a> array of vertex data values to be sampled</td>
</tr>
<tr class="odd">
<td style="text-align: left;">uint32[] / uint64[]</td>
<td style="text-align: left;">index</td>
<td style="text-align: right;"></td>
<td style="text-align: left;"><a href="documentation.html#data">data</a> array of indices (into the vertex array(s)) that form cells</td>
</tr>
<tr class="even">
<td style="text-align: left;">bool</td>
<td style="text-align: left;">indexPrefixed</td>
<td style="text-align: right;">false</td>
<td style="text-align: left;">indicates that the <code>index</code> array is compatible to VTK, where the indices of each cell are prefixed with the number of vertices</td>
</tr>
<tr class="odd">
<td style="text-align: left;">uint32[] / uint64[]</td>
<td style="text-align: left;">cell.index</td>
<td style="text-align: right;"></td>
<td style="text-align: left;"><a href="documentation.html#data">data</a> array of locations (into the index array), specifying the first index of each cell</td>
</tr>
<tr class="even">
<td style="text-align: left;">float[]</td>
<td style="text-align: left;">cell.data</td>
<td style="text-align: right;"></td>
<td style="text-align: left;"><a href="documentation.html#data">data</a> array of cell data values to be sampled</td>
</tr>
<tr class="odd">
<td style="text-align: left;">uint8[]</td>
<td style="text-align: left;">cell.type</td>
<td style="text-align: right;"></td>
<td style="text-align: left;"><a href="documentation.html#data">data</a> array of cell types (VTK compatible), only set if <code>indexPrefixed = false</code> false. Supported types are:</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: right;"></td>
<td style="text-align: left;"><code>OSP_TETRAHEDRON</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: right;"></td>
<td style="text-align: left;"><code>OSP_HEXAHEDRON</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: right;"></td>
<td style="text-align: left;"><code>OSP_WEDGE</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: right;"></td>
<td style="text-align: left;"><code>OSP_PYRAMID</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">bool</td>
<td style="text-align: left;">hexIterative</td>
<td style="text-align: right;">false</td>
<td style="text-align: left;">hexahedron interpolation method, defaults to fast non-iterative version which could have rendering inaccuracies may appear if hex is not parallelepiped</td>
</tr>
<tr class="odd">
<td style="text-align: left;">bool</td>
<td style="text-align: left;">precomputedNormals</td>
<td style="text-align: right;">false</td>
<td style="text-align: left;">whether to accelerate by precomputing, at a cost of 12 bytes/face</td>
</tr>
<tr class="even">
<td style="text-align: left;">int</td>
<td style="text-align: left;">maxIteratorDepth</td>
<td style="text-align: right;">6</td>
<td style="text-align: left;">do not descend further than to this BVH depth during interval iteration</td>
</tr>
</tbody>
</table>
<h3 id="vdb-volume">VDB Volume</h3>
<p>VDB volumes implement a data structure that is very similar to the data structure outlined in Museth [1], they are created by passing the type string “<code>vdb</code>” to <code>ospNewVolume</code>.</p>
<p>The data structure is a hierarchical regular grid at its core: Nodes are regular grids, and each grid cell may either store a constant value (this is called a tile), or child pointers. Nodes in VDB trees are wide: Nodes on the first level have a resolution of 32<sup>3</sup> voxels, on the next level 16<sup>3</sup>, and on the leaf level 8<sup>3</sup> voxels. All nodes on a given level have the same resolution. This makes it easy to find the node containing a coordinate using shift operations (see [1]). VDB leaf nodes are implicit in OSPRay / Open VKL: they are stored as pointers to user-provided data.</p>
<figure>
<img src="images/vdb_structure.svg" style="width:80.0%" alt="Topology of VDB volumes." /><figcaption aria-hidden="true">Topology of VDB volumes.</figcaption>
</figure>
<p>VDB volumes interpret input data as constant cells (which are then potentially filtered). This is in contrast to <code>structuredRegular</code> volumes, which have a vertex-centered interpretation.</p>
<p>The VDB implementation in OSPRay / Open VKL follows the following goals:</p>
<ul>
<li>Efficient data structure traversal on vector architectures.</li>
<li>Enable the use of industry-standard <code>.vdb</code> files created through the OpenVDB library.</li>
<li>Compatibility with OpenVDB on a leaf data level, so that <code>.vdb</code> file may be loaded with minimal overhead.</li>
</ul>
<p>VDB volumes have the following parameters:</p>
<table style="width:97%;">
<caption>Configuration parameters for VDB volumes.</caption>
<colgroup>
<col style="width: 17%" />
<col style="width: 24%" />
<col style="width: 55%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">int</td>
<td style="text-align: left;">maxIteratorDepth</td>
<td style="text-align: left;">do not descend further than to this depth during interval iteration, the maximum value and the default is 3</td>
</tr>
<tr class="even">
<td style="text-align: left;">int</td>
<td style="text-align: left;">maxSamplingDepth</td>
<td style="text-align: left;">do not descend further than to this depth during sampling, the maximum value and the default is 3</td>
</tr>
<tr class="odd">
<td style="text-align: left;">uint32[]</td>
<td style="text-align: left;">node.level</td>
<td style="text-align: left;">level on which each input node exists, may be 1, 2 or 3 (levels are counted from the root level = 0 down)</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec3i[]</td>
<td style="text-align: left;">node.origin</td>
<td style="text-align: left;">the node origin index (per input node)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSPData[]</td>
<td style="text-align: left;">node.data</td>
<td style="text-align: left;"><a href="documentation.html#data">data</a> arrays with the node data (per input node). Nodes that are tiles are expected to have single-item arrays. Leaf-nodes with grid data expected to have compact 3D arrays in zyx layout (z changes most quickly) with the correct number of voxels for the <code>level</code>. Only <code>OSP_FLOAT</code> is supported as field <code>OSPDataType</code>.</td>
</tr>
<tr class="even">
<td style="text-align: left;">int</td>
<td style="text-align: left;">filter</td>
<td style="text-align: left;">filter used for reconstructing the field, default is <code>OSP_VOLUME_FILTER_TRILINEAR</code>, alternatively <code>OSP_VOLUME_FILTER_NEAREST</code>.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">int</td>
<td style="text-align: left;">gradientFilter</td>
<td style="text-align: left;">filter used for reconstructing the field during gradient computations, default same as <code>filter</code></td>
</tr>
</tbody>
</table>
<ol type="1">
<li>Museth, K. VDB: High-Resolution Sparse Volumes with Dynamic Topology. ACM Transactions on Graphics 32(3), 2013. DOI: 10.1145/2487228.2487235</li>
</ol>
<h3 id="particle-volume">Particle Volume</h3>
<p>Particle volumes consist of a set of points in space. Each point has a position, a radius, and a weight typically associated with an attribute. Particle volumes are created by passing the type string “<code>particle</code>” to <code>ospNewVolume</code>.</p>
<p>A radial basis function defines the contribution of that particle. Currently, we use the Gaussian radial basis function <span class="math display">$$\phi(P) = w \exp\left(-\frac{(P - p)^2}{2 r^2}\right),$$</span> where <span class="math inline"><em>P</em></span> is the particle position, <span class="math inline"><em>p</em></span> is the sample position, <span class="math inline"><em>r</em></span> is the radius and <span class="math inline"><em>w</em></span> is the weight. At each sample, the scalar field value is then computed as the sum of each radial basis function <span class="math inline"><em>ϕ</em></span>, for each particle that overlaps it.</p>
<p>The OSPRay / Open VKL implementation is similar to direct evaluation of samples in Reda et al. [2]. It uses an Embree-built BVH with a custom traversal, similar to the method in [1].</p>
<table style="width:98%;">
<caption>Configuration parameters for particle volumes.</caption>
<colgroup>
<col style="width: 14%" />
<col style="width: 30%" />
<col style="width: 11%" />
<col style="width: 40%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: right;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">vec3f[]</td>
<td style="text-align: left;">particle.position</td>
<td style="text-align: right;"></td>
<td style="text-align: left;"><a href="documentation.html#data">data</a> array of particle positions</td>
</tr>
<tr class="even">
<td style="text-align: left;">float[]</td>
<td style="text-align: left;">particle.radius</td>
<td style="text-align: right;"></td>
<td style="text-align: left;"><a href="documentation.html#data">data</a> array of particle radii</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float[]</td>
<td style="text-align: left;">particle.weight</td>
<td style="text-align: right;">NULL</td>
<td style="text-align: left;">optional <a href="documentation.html#data">data</a> array of particle weights, specifying the height of the kernel.</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">radiusSupportFactor</td>
<td style="text-align: right;">3.0</td>
<td style="text-align: left;">The multiplier of the particle radius required for support. Larger radii ensure smooth results at the cost of performance. In the Gaussian kernel, the radius is one standard deviation (<span class="math inline"><em>σ</em></span>), so a value of 3 corresponds to <span class="math inline">3<em>σ</em></span>.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">clampMaxCumulativeValue</td>
<td style="text-align: right;">0</td>
<td style="text-align: left;">The maximum cumulative value possible, set by user. All cumulative values will be clamped to this, and further traversal (RBF summation) of particle contributions will halt when this value is reached. A value of zero or less turns this off.</td>
</tr>
<tr class="even">
<td style="text-align: left;">bool</td>
<td style="text-align: left;">estimateValueRanges</td>
<td style="text-align: right;">true</td>
<td style="text-align: left;">Enable heuristic estimation of value ranges which are used in internal acceleration structures as well as for determining the volume’s overall value range. When set to <code>false</code>, the user <em>must</em> specify <code>clampMaxCumulativeValue</code>, and all value ranges will be assumed [0, <code>clampMaxCumulativeValue</code>]. Disabling this switch may improve volume commit time, but will make volume rendering less efficient.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">int</td>
<td style="text-align: left;">maxIteratorDepth</td>
<td style="text-align: right;">6</td>
<td style="text-align: left;">do not descend further than to this BVH depth during interval iteration</td>
</tr>
</tbody>
</table>
<ol type="1">
<li><p>A. Knoll, I. Wald, P. Navratil, A. Bowen, K. Reda, M.E., Papka, and K. Gaither, “RBF Volume Ray Casting on Multicore and Manycore CPUs”, 2014, Computer Graphics Forum, 33: 71–80. doi:10.1111/cgf.12363</p></li>
<li><p>K. Reda, A. Knoll, K. Nomura, M. E. Papka, A. E. Johnson and J. Leigh, “Visualizing large-scale atomistic simulations in ultra-resolution immersive environments”, 2013 IEEE Symposium on Large-Scale Data Analysis and Visualization (LDAV), Atlanta, GA, 2013, pp. 59–65.</p></li>
</ol>
<h3 id="transfer-function">Transfer Function</h3>
<p>Transfer functions map the scalar values of volumes to color and opacity and thus they can be used to visually emphasize certain features of the volume. To create a new transfer function of given type <code>type</code> use</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true"></a>OSPTransferFunction ospNewTransferFunction(<span class="at">const</span> <span class="dt">char</span> *type);</span></code></pre></div>
<p>The returned handle can be assigned to a volumetric model (described below) as parameter “<code>transferFunction</code>” using <code>ospSetObject</code>.</p>
<p>One type of transfer function that is supported by OSPRay is the linear transfer function, which interpolates between given equidistant colors and opacities. It is create by passing the string “<code>piecewiseLinear</code>” to <code>ospNewTransferFunction</code> and it is controlled by these parameters:</p>
<table>
<caption>Parameters accepted by the linear transfer function.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">vec3f[]</td>
<td style="text-align: left;">color</td>
<td style="text-align: left;"><a href="documentation.html#data">data</a> array of RGB colors</td>
</tr>
<tr class="even">
<td style="text-align: left;">float[]</td>
<td style="text-align: left;">opacity</td>
<td style="text-align: left;"><a href="documentation.html#data">data</a> array of opacities</td>
</tr>
<tr class="odd">
<td style="text-align: left;">vec2f</td>
<td style="text-align: left;">valueRange</td>
<td style="text-align: left;">domain (scalar range) this function maps from</td>
</tr>
</tbody>
</table>
<p>The arrays <code>color</code> and <code>opacity</code> can be of different length.</p>
<h3 id="volumetricmodels">VolumetricModels</h3>
<p>Volumes in OSPRay are given volume rendering appearance information through VolumetricModels. This decouples the physical representation of the volume (and possible acceleration structures it contains) to rendering-specific parameters (where more than one set may exist concurrently). To create a volume instance, call</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true"></a>OSPVolumetricModel ospNewVolumetricModel(OSPVolume volume);</span></code></pre></div>
<table style="width:98%;">
<caption>Parameters understood by VolumetricModel.</caption>
<colgroup>
<col style="width: 23%" />
<col style="width: 20%" />
<col style="width: 10%" />
<col style="width: 44%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: right;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">OSPTransferFunction</td>
<td style="text-align: left;">transferFunction</td>
<td style="text-align: right;"></td>
<td style="text-align: left;"><a href="#transfer-function">transfer function</a> to use</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">densityScale</td>
<td style="text-align: right;">1.0</td>
<td style="text-align: left;">makes volumes uniformly thinner or thicker</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">anisotropy</td>
<td style="text-align: right;">0.0</td>
<td style="text-align: left;">anisotropy of the (Henyey-Greenstein) phase function in [-1, 1] (<a href="documentation.html#path-tracer">path tracer</a> only), default to isotropic scattering</td>
</tr>
</tbody>
</table>
<h2 id="geometries">Geometries</h2>
<p>Geometries in OSPRay are objects that describe intersectable surfaces. To create a new geometry object of given type <code>type</code> use</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true"></a>OSPGeometry ospNewGeometry(<span class="at">const</span> <span class="dt">char</span> *type);</span></code></pre></div>
<p>Note that in the current implementation geometries are limited to a maximum of 2<sup>32</sup> primitives.</p>
<h3 id="mesh">Mesh</h3>
<p>A mesh consisting of either triangles or quads is created by calling <code>ospNewGeometry</code> with type string “<code>mesh</code>”. Once created, a mesh recognizes the following parameters:</p>
<table>
<caption>Parameters defining a mesh geometry.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">vec3f[]</td>
<td style="text-align: left;">vertex.position</td>
<td style="text-align: left;"><a href="documentation.html#data">data</a> array of vertex positions</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec3f[]</td>
<td style="text-align: left;">vertex.normal</td>
<td style="text-align: left;"><a href="documentation.html#data">data</a> array of vertex normals</td>
</tr>
<tr class="odd">
<td style="text-align: left;">vec4f[] / vec3f[]</td>
<td style="text-align: left;">vertex.color</td>
<td style="text-align: left;"><a href="documentation.html#data">data</a> array of vertex colors (RGBA/RGB)</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec2f[]</td>
<td style="text-align: left;">vertex.texcoord</td>
<td style="text-align: left;"><a href="documentation.html#data">data</a> array of vertex texture coordinates</td>
</tr>
<tr class="odd">
<td style="text-align: left;">vec3ui[] / vec4ui[]</td>
<td style="text-align: left;">index</td>
<td style="text-align: left;"><a href="documentation.html#data">data</a> array of (either triangle or quad) indices (into the vertex array(s))</td>
</tr>
</tbody>
</table>
<p>The data type of index arrays differentiates between the underlying geometry, triangles are used for a index with <code>vec3ui</code> type and quads for <code>vec4ui</code> type. Quads are internally handled as a pair of two triangles, thus mixing triangles and quads is supported by encoding some triangle as a quad with the last two vertex indices being identical (<code>w=z</code>).</p>
<p>The <code>vertex.position</code> and <code>index</code> arrays are mandatory to create a valid mesh.</p>
<h3 id="subdivision">Subdivision</h3>
<p>A mesh consisting of subdivision surfaces, created by specifying a geometry of type “<code>subdivision</code>”. Once created, a subdivision recognizes the following parameters:</p>
<table style="width:98%;">
<caption>Parameters defining a Subdivision geometry.</caption>
<colgroup>
<col style="width: 14%" />
<col style="width: 27%" />
<col style="width: 55%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">vec3f[]</td>
<td style="text-align: left;">vertex.position</td>
<td style="text-align: left;"><a href="documentation.html#data">data</a> array of vertex positions</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec4f[]</td>
<td style="text-align: left;">vertex.color</td>
<td style="text-align: left;">optional <a href="documentation.html#data">data</a> array of vertex colors (RGBA)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">vec2f[]</td>
<td style="text-align: left;">vertex.texcoord</td>
<td style="text-align: left;">optional <a href="documentation.html#data">data</a> array of vertex texture coordinates</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">level</td>
<td style="text-align: left;">global level of tessellation, default 5</td>
</tr>
<tr class="odd">
<td style="text-align: left;">uint[]</td>
<td style="text-align: left;">index</td>
<td style="text-align: left;"><a href="documentation.html#data">data</a> array of indices (into the vertex array(s))</td>
</tr>
<tr class="even">
<td style="text-align: left;">float[]</td>
<td style="text-align: left;">index.level</td>
<td style="text-align: left;">optional <a href="documentation.html#data">data</a> array of per-edge levels of tessellation, overrides global level</td>
</tr>
<tr class="odd">
<td style="text-align: left;">uint[]</td>
<td style="text-align: left;">face</td>
<td style="text-align: left;">optional <a href="documentation.html#data">data</a> array holding the number of indices/edges (3 to 15) per face, defaults to 4 (a pure quad mesh)</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec2i[]</td>
<td style="text-align: left;">edgeCrease.index</td>
<td style="text-align: left;">optional <a href="documentation.html#data">data</a> array of edge crease indices</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float[]</td>
<td style="text-align: left;">edgeCrease.weight</td>
<td style="text-align: left;">optional <a href="documentation.html#data">data</a> array of edge crease weights</td>
</tr>
<tr class="even">
<td style="text-align: left;">uint[]</td>
<td style="text-align: left;">vertexCrease.index</td>
<td style="text-align: left;">optional <a href="documentation.html#data">data</a> array of vertex crease indices</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float[]</td>
<td style="text-align: left;">vertexCrease.weight</td>
<td style="text-align: left;">optional <a href="documentation.html#data">data</a> array of vertex crease weights</td>
</tr>
<tr class="even">
<td style="text-align: left;">uchar</td>
<td style="text-align: left;">mode</td>
<td style="text-align: left;">subdivision edge boundary mode, supported modes are:</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><code>OSP_SUBDIVISION_NO_BOUNDARY</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><code>OSP_SUBDIVISION_SMOOTH_BOUNDARY</code> (default)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><code>OSP_SUBDIVISION_PIN_CORNERS</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><code>OSP_SUBDIVISION_PIN_BOUNDARY</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><code>OSP_SUBDIVISION_PIN_ALL</code></td>
</tr>
</tbody>
</table>
<p>The <code>vertex</code> and <code>index</code> arrays are mandatory to create a valid subdivision surface. If no <code>face</code> array is present then a pure quad mesh is assumed (the number of indices must be a multiple of 4). Optionally supported are edge and vertex creases.</p>
<h3 id="spheres">Spheres</h3>
<p>A geometry consisting of individual spheres, each of which can have an own radius, is created by calling <code>ospNewGeometry</code> with type string “<code>sphere</code>”. The spheres will not be tessellated but rendered procedurally and are thus perfectly round. To allow a variety of sphere representations in the application this geometry allows a flexible way of specifying the data of center position and radius within a <a href="documentation.html#data">data</a> array:</p>
<table style="width:97%;">
<caption>Parameters defining a spheres geometry.</caption>
<colgroup>
<col style="width: 15%" />
<col style="width: 22%" />
<col style="width: 12%" />
<col style="width: 46%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: right;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">vec3f[]</td>
<td style="text-align: left;">sphere.position</td>
<td style="text-align: right;"></td>
<td style="text-align: left;"><a href="documentation.html#data">data</a> array of center positions</td>
</tr>
<tr class="even">
<td style="text-align: left;">float[]</td>
<td style="text-align: left;">sphere.radius</td>
<td style="text-align: right;">NULL</td>
<td style="text-align: left;">optional <a href="documentation.html#data">data</a> array of the per-sphere radius</td>
</tr>
<tr class="odd">
<td style="text-align: left;">vec2f[]</td>
<td style="text-align: left;">sphere.texcoord</td>
<td style="text-align: right;">NULL</td>
<td style="text-align: left;">optional <a href="documentation.html#data">data</a> array of texture coordinates (constant per sphere)</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">radius</td>
<td style="text-align: right;">0.01</td>
<td style="text-align: left;">default radius for all spheres (if <code>sphere.radius</code> is not set)</td>
</tr>
</tbody>
</table>
<h3 id="curves">Curves</h3>
<p>A geometry consisting of multiple curves is created by calling <code>ospNewGeometry</code> with type string “<code>curve</code>”. The parameters defining this geometry are listed in the table below.</p>
<table style="width:97%;">
<caption>Parameters defining a curves geometry.</caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 31%" />
<col style="width: 45%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">vec4f[]</td>
<td style="text-align: left;">vertex.position_radius</td>
<td style="text-align: left;"><a href="documentation.html#data">data</a> array of vertex position and per-vertex radius</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec3f[]</td>
<td style="text-align: left;">vertex.position</td>
<td style="text-align: left;"><a href="documentation.html#data">data</a> array of vertex position</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">radius</td>
<td style="text-align: left;">global radius of all curves (if per-vertex radius is not used), default 0.01</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec2f[]</td>
<td style="text-align: left;">vertex.texcoord</td>
<td style="text-align: left;"><a href="documentation.html#data">data</a> array of per-vertex texture coordinates</td>
</tr>
<tr class="odd">
<td style="text-align: left;">vec4f[]</td>
<td style="text-align: left;">vertex.color</td>
<td style="text-align: left;"><a href="documentation.html#data">data</a> array of corresponding vertex colors (RGBA)</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec3f[]</td>
<td style="text-align: left;">vertex.normal</td>
<td style="text-align: left;"><a href="documentation.html#data">data</a> array of curve normals (only for “ribbon” curves)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">vec4f[]</td>
<td style="text-align: left;">vertex.tangent</td>
<td style="text-align: left;"><a href="documentation.html#data">data</a> array of curve tangents (only for “hermite” curves)</td>
</tr>
<tr class="even">
<td style="text-align: left;">uint32[]</td>
<td style="text-align: left;">index</td>
<td style="text-align: left;"><a href="documentation.html#data">data</a> array of indices to the first vertex or tangent of a curve segment</td>
</tr>
<tr class="odd">
<td style="text-align: left;">uchar</td>
<td style="text-align: left;">type</td>
<td style="text-align: left;"><code>OSPCurveType</code> for rendering the curve. Supported types are:</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><code>OSP_FLAT</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><code>OSP_ROUND</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><code>OSP_RIBBON</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">uchar</td>
<td style="text-align: left;">basis</td>
<td style="text-align: left;"><code>OSPCurveBasis</code> for defining the curve. Supported bases are:</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><code>OSP_LINEAR</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><code>OSP_BEZIER</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><code>OSP_BSPLINE</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><code>OSP_HERMITE</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><code>OSP_CATMULL_ROM</code></td>
</tr>
</tbody>
</table>
<p>Depending upon the specified data type of vertex positions, the curves will be implemented Embree curves or assembled from rounded and linearly-connected segments.</p>
<p>Positions in <code>vertex.position_radius</code> format supports per-vertex varying radii with data type <code>vec4f[]</code> and instantiate Embree curves internally for the relevant type/basis mapping.</p>
<p>If a constant <code>radius</code> is used and positions are specified in a <code>vec3f[]</code> type of <code>vertex.position</code> format, then type/basis defaults to <code>OSP_ROUND</code> and <code>OSP_LINEAR</code> (this is the fastest and most memory efficient mode). Implementation is with round linear segments where each segment corresponds to a link between two vertices.</p>
<p>The following section describes the properties of different curve basis’ and how they use the data provided in data buffers:</p>
<dl>
<dt>OSP_LINEAR</dt>
<dd>The indices point to the first of 2 consecutive control points in the vertex buffer. The first control point is the start and the second control point the end of the line segment. The curve goes through all control points listed in the vertex buffer.
</dd>
<dt>OSP_BEZIER</dt>
<dd>The indices point to the first of 4 consecutive control points in the vertex buffer. The first control point represents the start point of the curve, and the 4th control point the end point of the curve. The Bézier basis is interpolating, thus the curve does go exactly through the first and fourth control vertex.
</dd>
<dt>OSP_BSPLINE</dt>
<dd>The indices point to the first of 4 consecutive control points in the vertex buffer. This basis is not interpolating, thus the curve does in general not go through any of the control points directly. Using this basis, 3 control points can be shared for two continuous neighboring curve segments, e.g., the curves <span class="math inline">(<em>p</em>0, <em>p</em>1, <em>p</em>2, <em>p</em>3)</span> and <span class="math inline">(<em>p</em>1, <em>p</em>2, <em>p</em>3, <em>p</em>4)</span> are C1 continuous. This feature make this basis a good choice to construct continuous multi-segment curves, as memory consumption can be kept minimal.
</dd>
<dt>OSP_HERMITE</dt>
<dd>It is necessary to have both vertex buffer and tangent buffer for using this basis. The indices point to the first of 2 consecutive points in the vertex buffer, and the first of 2 consecutive tangents in the tangent buffer. This basis is interpolating, thus does exactly go through the first and second control point, and the first order derivative at the begin and end matches exactly the value specified in the tangent buffer. When connecting two segments continuously, the end point and tangent of the previous segment can be shared.
</dd>
<dt>OSP_CATMULL_ROM</dt>
<dd>The indices point to the first of 4 consecutive control points in the vertex buffer. If <span class="math inline">(<em>p</em>0, <em>p</em>1, <em>p</em>2, <em>p</em>3)</span> represent the points then this basis goes through <span class="math inline"><em>p</em>1</span> and <span class="math inline"><em>p</em>2</span>, with tangents as <span class="math inline">(<em>p</em>2 − <em>p</em>0)/2</span> and <span class="math inline">(<em>p</em>3 − <em>p</em>1)/2</span>.
</dd>
</dl>
<p>The following section describes the properties of different curve types’ and how they define the geometry of a curve:</p>
<dl>
<dt>OSP_FLAT</dt>
<dd>This type enables faster rendering as the curve is rendered as a connected sequence of ray facing quads.
</dd>
<dt>OSP_ROUND</dt>
<dd>This type enables rendering a real geometric surface for the curve which allows closeup views. This mode renders a sweep surface by sweeping a varying radius circle tangential along the curve.
</dd>
<dt>OSP_RIBBON</dt>
<dd>The type enables normal orientation of the curve and requires a normal buffer be specified along with vertex buffer. The curve is rendered as a flat band whose center approximately follows the provided vertex buffer and whose normal orientation approximately follows the provided normal buffer.
</dd>
</dl>
<h3 id="boxes">Boxes</h3>
<p>OSPRay can directly render axis-aligned bounding boxes without the need to convert them to quads or triangles. To do so create a boxes geometry by calling <code>ospNewGeometry</code> with type string “<code>box</code>”.</p>
<table>
<caption>Parameters defining a boxes geometry.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">box3f[]</td>
<td style="text-align: left;">box</td>
<td style="text-align: left;"><a href="documentation.html#data">data</a> array of boxes</td>
</tr>
</tbody>
</table>
<h3 id="planes">Planes</h3>
<p>OSPRay can directly render planes defined by plane equation coefficients in its implicit form <span class="math inline"><em>a</em><em>x</em> + <em>b</em><em>y</em> + <em>c</em><em>z</em> + <em>d</em> = 0</span>. By default planes are infinite but their extents can be limited by defining optional bounding boxes. A planes geometry can be created by calling <code>ospNewGeometry</code> with type string “<code>plane</code>”.</p>
<table>
<caption>Parameters defining a planes geometry.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name Descript</th>
<th style="text-align: left;">ion</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">vec4f[]</td>
<td style="text-align: left;">plane.coefficients</td>
<td style="text-align: left;"><a href="documentation.html#data">data</a> array of plane coefficients <span class="math inline">(<em>a</em>, <em>b</em>, <em>c</em>, <em>d</em>)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">box3f[]</td>
<td style="text-align: left;">plane.bounds</td>
<td style="text-align: left;">optional <a href="documentation.html#data">data</a> array of bounding boxes</td>
</tr>
</tbody>
</table>
<h3 id="isosurfaces">Isosurfaces</h3>
<p>OSPRay can directly render multiple isosurfaces of a volume without first tessellating them. To do so create an isosurfaces geometry by calling <code>ospNewGeometry</code> with type string “<code>isosurface</code>”. The appearance information of the surfaces is set through the Geometric Model. Per-isosurface colors can be set by passing per-primitive colors to the Geometric Model, in order of the isosurface array.</p>
<table>
<caption>Parameters defining an isosurfaces geometry.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">isovalue</td>
<td style="text-align: left;">single isovalues</td>
</tr>
<tr class="even">
<td style="text-align: left;">float[]</td>
<td style="text-align: left;">isovalue</td>
<td style="text-align: left;"><a href="documentation.html#data">data</a> array of isovalues</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSPVolume</td>
<td style="text-align: left;">volume</td>
<td style="text-align: left;">handle of the <a href="documentation.html#volumes">Volume</a> to be isosurfaced</td>
</tr>
</tbody>
</table>
<h3 id="geometricmodels">GeometricModels</h3>
<p>Geometries are matched with surface appearance information through GeometricModels. These take a geometry, which defines the surface representation, and applies either full-object or per-primitive color and material information. To create a geometric model, call</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true"></a>OSPGeometricModel ospNewGeometricModel(OSPGeometry geometry);</span></code></pre></div>
<p>Color and material are fetched with the primitive ID of the hit (clamped to the valid range, thus a single color or material is fine), or mapped first via the <code>index</code> array (if present). All parameters are optional, however, some renderers (notably the <a href="documentation.html#path-tracer">path tracer</a>) require a material to be set. Materials are either handles of <code>OSPMaterial</code>, or indices into the <code>material</code> array on the <a href="documentation.html#renderers">renderer</a>, which allows to build a <a href="documentation.html#world">world</a> which can be used by different types of renderers.</p>
<p>An <code>invertNormals</code> flag allows to invert (shading) normal vectors of the rendered geometry. That is particularly useful for clipping. By changing normal vectors orientation one can control whether inside or outside of the clipping geometry is being removed. For example, a clipping geometry with normals oriented outside clips everything what’s inside.</p>
<table style="width:98%;">
<caption>Parameters understood by GeometricModel.</caption>
<colgroup>
<col style="width: 23%" />
<col style="width: 20%" />
<col style="width: 53%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">OSPMaterial / uint32</td>
<td style="text-align: left;">material</td>
<td style="text-align: left;">optional <a href="documentation.html#materials">material</a> applied to the geometry, may be an index into the <code>material</code> parameter on the <a href="documentation.html#renderers">renderer</a> (if it exists)</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec4f</td>
<td style="text-align: left;">color</td>
<td style="text-align: left;">optional color assigned to the geometry</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSPMaterial[] / uint32[]</td>
<td style="text-align: left;">material</td>
<td style="text-align: left;">optional <a href="documentation.html#data">data</a> array of (per-primitive) materials, may be an index into the <code>material</code> parameter on the renderer (if it exists)</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec4f[]</td>
<td style="text-align: left;">color</td>
<td style="text-align: left;">optional <a href="documentation.html#data">data</a> array of (per-primitive) colors</td>
</tr>
<tr class="odd">
<td style="text-align: left;">uint8[]</td>
<td style="text-align: left;">index</td>
<td style="text-align: left;">optional <a href="documentation.html#data">data</a> array of per-primitive indices into <code>color</code> and <code>material</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">bool</td>
<td style="text-align: left;">invertNormals</td>
<td style="text-align: left;">inverts all shading normals (Ns), default false</td>
</tr>
</tbody>
</table>
<h2 id="lights">Lights</h2>
<p>To create a new light source of given type <code>type</code> use</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true"></a>OSPLight ospNewLight(<span class="at">const</span> <span class="dt">char</span> *type);</span></code></pre></div>
<p>All light sources accept the following parameters:</p>
<table>
<caption>Parameters accepted by all lights.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: right;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">color</td>
<td style="text-align: right;">white</td>
<td style="text-align: left;">color of the light</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">intensity</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">intensity of the light (a factor)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">bool</td>
<td style="text-align: left;">visible</td>
<td style="text-align: right;">true</td>
<td style="text-align: left;">whether the light can be directly seen</td>
</tr>
</tbody>
</table>
<p>The following light types are supported by most OSPRay renderers.</p>
<h3 id="directional-light-distant-light">Directional Light / Distant Light</h3>
<p>The distant light (or traditionally the directional light) is thought to be far away (outside of the scene), thus its light arrives (almost) as parallel rays. It is created by passing the type string “<code>distant</code>” to <code>ospNewLight</code>. In addition to the <a href="#lights">general parameters</a> understood by all lights the distant light supports the following special parameters:</p>
<table>
<caption>Special parameters accepted by the distant light.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">direction</td>
<td style="text-align: left;">main emission direction of the distant light</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">angularDiameter</td>
<td style="text-align: left;">apparent size (angle in degree) of the light</td>
</tr>
</tbody>
</table>
<p>Setting the angular diameter to a value greater than zero will result in soft shadows when the renderer uses stochastic sampling (like the <a href="documentation.html#path-tracer">path tracer</a>). For instance, the apparent size of the sun is about 0.53°.</p>
<h3 id="point-light-sphere-light">Point Light / Sphere Light</h3>
<p>The sphere light (or the special case point light) is a light emitting uniformly in all directions from the surface toward the outside. It does not emit any light toward the inside of the sphere. It is created by passing the type string “<code>sphere</code>” to <code>ospNewLight</code>. In addition to the <a href="#lights">general parameters</a> understood by all lights the sphere light supports the following special parameters:</p>
<table>
<caption>Special parameters accepted by the sphere light.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">position</td>
<td style="text-align: left;">the center of the sphere light, in world-space</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">radius</td>
<td style="text-align: left;">the size of the sphere light</td>
</tr>
</tbody>
</table>
<p>Setting the radius to a value greater than zero will result in soft shadows when the renderer uses stochastic sampling (like the <a href="documentation.html#path-tracer">path tracer</a>).</p>
<h3 id="spotlight-photometric-light">Spotlight / Photometric Light</h3>
<p>The spotlight is a light emitting into a cone of directions. It is created by passing the type string “<code>spot</code>” to <code>ospNewLight</code>. In addition to the <a href="#lights">general parameters</a> understood by all lights the spotlight supports the special parameters listed in the table.</p>
<table style="width:98%;">
<caption>Special parameters accepted by the spotlight.</caption>
<colgroup>
<col style="width: 14%" />
<col style="width: 29%" />
<col style="width: 17%" />
<col style="width: 36%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: right;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">position</td>
<td style="text-align: right;"><span class="math inline">(0, 0, 0)</span></td>
<td style="text-align: left;">the center of the spotlight, in world-space</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">direction</td>
<td style="text-align: right;"><span class="math inline">(0, 0, 1)</span></td>
<td style="text-align: left;">main emission direction of the spot</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">openingAngle</td>
<td style="text-align: right;">180</td>
<td style="text-align: left;">full opening angle (in degree) of the spot; outside of this cone is no illumination</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">penumbraAngle</td>
<td style="text-align: right;">5</td>
<td style="text-align: left;">size (angle in degree) of the “penumbra”, the region between the rim (of the illumination cone) and full intensity of the spot; should be smaller than half of <code>openingAngle</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">radius</td>
<td style="text-align: right;">0</td>
<td style="text-align: left;">the size of the spotlight, the radius of a disk with normal <code>direction</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">innerRadius</td>
<td style="text-align: right;">0</td>
<td style="text-align: left;">in combination with <code>radius</code> turns the disk into a ring</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float[]</td>
<td style="text-align: left;">intensityDistribution</td>
<td style="text-align: right;"></td>
<td style="text-align: left;">luminous intensity distribution for photometric lights; can be 2D for asymmetric illumination; values are assumed to be uniformly distributed</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">c0</td>
<td style="text-align: right;"></td>
<td style="text-align: left;">orientation, i.e., direction of the C0-(half)plane (only needed if illumination via <code>intensityDistribution</code> is asymmetric)</td>
</tr>
</tbody>
</table>
<figure>
<img src="images/spot_light.png" alt="Angles used by the spotlight." /><figcaption aria-hidden="true">Angles used by the spotlight.</figcaption>
</figure>
<p>Setting the radius to a value greater than zero will result in soft shadows when the renderer uses stochastic sampling (like the <a href="documentation.html#path-tracer">path tracer</a>). Additionally setting the inner radius will result in a ring instead of a disk emitting the light.</p>
<p>Measured light sources (IES, EULUMDAT, …) are supported by providing an <code>intensityDistribution</code> <a href="documentation.html#data">data</a> array to modulate the intensity per direction. The mapping is using the C-γ coordinate system (see also below figure): the values of the first (or only) dimension of <code>intensityDistribution</code> are uniformly mapped to γ in [0–π]; the first intensity value to 0, the last value to π, thus at least two values need to be present. If the array has a second dimension then the intensities are not rotational symmetric around <code>direction</code>, but are accordingly mapped to the C-halfplanes in [0–2π]; the first “row” of values to 0 and 2π, the other rows such that they have uniform distance to its neighbors. The orientation of the C0-plane is specified via <code>c0</code>.</p>
<figure>
<img src="images/spot_coords.png" alt="C-γ coordinate system for the mapping of intensityDistribution to the spotlight." /><figcaption aria-hidden="true">C-γ coordinate system for the mapping of <code>intensityDistribution</code> to the spotlight.</figcaption>
</figure>
<h3 id="quad-light">Quad Light</h3>
<p>The quad<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> light is a planar, procedural area light source emitting uniformly on one side into the half-space. It is created by passing the type string “<code>quad</code>” to <code>ospNewLight</code>. In addition to the <a href="#lights">general parameters</a> understood by all lights the quad light supports the following special parameters:</p>
<table>
<caption>Special parameters accepted by the quad light.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">position</td>
<td style="text-align: left;">world-space position of one vertex of the quad light</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">edge1</td>
<td style="text-align: left;">vector to one adjacent vertex</td>
</tr>
<tr class="odd">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">edge2</td>
<td style="text-align: left;">vector to the other adjacent vertex</td>
</tr>
</tbody>
</table>
<figure>
<img src="images/quad_light.png" alt="Defining a quad light which emits toward the reader." /><figcaption aria-hidden="true">Defining a quad light which emits toward the reader.</figcaption>
</figure>
<p>The emission side is determined by the cross product of <code>edge1</code>×<code>edge2</code>. Note that only renderers that use stochastic sampling (like the path tracer) will compute soft shadows from the quad light. Other renderers will just sample the center of the quad light, which results in hard shadows.</p>
<h3 id="hdri-light">HDRI Light</h3>
<p>The HDRI light is a textured light source surrounding the scene and illuminating it from infinity. It is created by passing the type string “<code>hdri</code>” to <code>ospNewLight</code>. In addition to the <a href="#lights">general parameters</a> the HDRI light supports the following special parameters:</p>
<table style="width:97%;">
<caption>Special parameters accepted by the HDRI light.</caption>
<colgroup>
<col style="width: 17%" />
<col style="width: 16%" />
<col style="width: 64%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">up</td>
<td style="text-align: left;">up direction of the light in world-space</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">direction</td>
<td style="text-align: left;">direction to which the center of the texture will be mapped to (analog to <a href="#panoramic-camera">panoramic camera</a>)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSPTexture</td>
<td style="text-align: left;">map</td>
<td style="text-align: left;">environment map in latitude / longitude format</td>
</tr>
</tbody>
</table>
<figure>
<img src="images/hdri_light.png" alt="Orientation and Mapping of an HDRI Light." /><figcaption aria-hidden="true">Orientation and Mapping of an HDRI Light.</figcaption>
</figure>
<p>Note that the currently only the <a href="documentation.html#path-tracer">path tracer</a> supports the HDRI light.</p>
<h3 id="ambient-light">Ambient Light</h3>
<p>The ambient light surrounds the scene and illuminates it from infinity with constant radiance (determined by combining the <a href="#lights">parameters <code>color</code> and <code>intensity</code></a>). It is created by passing the type string “<code>ambient</code>” to <code>ospNewLight</code>.</p>
<p>Note that the <a href="documentation.html#scivis-renderer">SciVis renderer</a> uses ambient lights to control the color and intensity of the computed ambient occlusion (AO).</p>
<h3 id="sun-sky-light">Sun-Sky Light</h3>
<p>The sun-sky light is a combination of a <code>distant</code> light for the sun and a procedural <code>hdri</code> light for the sky. It is created by passing the type string “<code>sunSky</code>” to <code>ospNewLight</code>. The sun-sky light surrounds the scene and illuminates it from infinity and can be used for rendering outdoor scenes. The radiance values are calculated using the Hošek-Wilkie sky model and solar radiance function. In addition to the <a href="#lights">general parameters</a> the following special parameters are supported:</p>
<table style="width:97%;">
<caption>Special parameters accepted by the <code>sunSky</code> light.</caption>
<colgroup>
<col style="width: 11%" />
<col style="width: 24%" />
<col style="width: 18%" />
<col style="width: 43%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: right;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">up</td>
<td style="text-align: right;"><span class="math inline">(0, 1, 0)</span></td>
<td style="text-align: left;">zenith of sky in world-space</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">direction</td>
<td style="text-align: right;"><span class="math inline">(0,  − 1, 0)</span></td>
<td style="text-align: left;">main emission direction of the sun</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">turbidity</td>
<td style="text-align: right;">3</td>
<td style="text-align: left;">atmospheric turbidity due to particles, in [1–10]</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">albedo</td>
<td style="text-align: right;">0.3</td>
<td style="text-align: left;">ground reflectance, in [0–1]</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">horizonExtension</td>
<td style="text-align: right;">0.01</td>
<td style="text-align: left;">extend the sky dome by stretching the horizon, fraction of the lower hemisphere to cover, in [0–1]</td>
</tr>
</tbody>
</table>
<p>The lowest elevation for the sun is restricted to the horizon.</p>
<h3 id="emissive-objects">Emissive Objects</h3>
<p>The <a href="documentation.html#path-tracer">path tracer</a> will consider illumination by <a href="#geometries">geometries</a> which have a light emitting material assigned (for example the <a href="#luminous">Luminous</a> material).</p>
<h2 id="scene-hierarchy">Scene Hierarchy</h2>
<h3 id="groups">Groups</h3>
<p>Groups in OSPRay represent collections of GeometricModels and VolumetricModels which share a common local-space coordinate system. To create a group call</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true"></a>OSPGroup ospNewGroup();</span></code></pre></div>
<p>Groups take arrays of geometric models, volumetric models and clipping geometric models, but they are optional. In other words, there is no need to create empty arrays if there are no geometries or volumes in the group.</p>
<p>By adding <code>OSPGeometricModel</code>s to the <code>clippingGeometry</code> array a clipping geometry feature is enabled. Geometries assigned to this parameter will be used as clipping geometries. Any supported geometry can be used for clipping. The only requirement is that it has to distinctly partition space into clipping and non-clipping one. These include: spheres, boxes, infinite planes, closed meshes, closed subdivisions and curves. All geometries and volumes assigned to <code>geometry</code> or <code>volume</code> will be clipped. Use of clipping geometry that is not closed (or infinite) will result in rendering artifacts. User can decide which part of space is clipped by changing shading normals orientation with the <code>invertNormals</code> flag of the <a href="documentation.html#geometricmodels">GeometricModel</a>. When more than single clipping geometry is defined all clipping areas will be “added” together – an union of these areas will be applied.</p>
<table style="width:98%;">
<caption>Parameters understood by groups.</caption>
<colgroup>
<col style="width: 26%" />
<col style="width: 19%" />
<col style="width: 10%" />
<col style="width: 41%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: right;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">OSPGeometricModel[]</td>
<td style="text-align: left;">geometry</td>
<td style="text-align: right;">NULL</td>
<td style="text-align: left;"><a href="documentation.html#data">data</a> array of <a href="#geometricmodels">GeometricModels</a></td>
</tr>
<tr class="even">
<td style="text-align: left;">OSPVolumetricModel[]</td>
<td style="text-align: left;">volume</td>
<td style="text-align: right;">NULL</td>
<td style="text-align: left;"><a href="documentation.html#data">data</a> array of <a href="#volumetricmodels">VolumetricModels</a></td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSPGeometricModel[]</td>
<td style="text-align: left;">clippingGeometry</td>
<td style="text-align: right;">NULL</td>
<td style="text-align: left;"><a href="documentation.html#data">data</a> array of <a href="#geometricmodels">GeometricModels</a> used for clipping</td>
</tr>
<tr class="even">
<td style="text-align: left;">bool</td>
<td style="text-align: left;">dynamicScene</td>
<td style="text-align: right;">false</td>
<td style="text-align: left;">use RTC_SCENE_DYNAMIC flag (faster BVH build, slower ray traversal), otherwise uses RTC_SCENE_STATIC flag (faster ray traversal, slightly slower BVH build)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">bool</td>
<td style="text-align: left;">compactMode</td>
<td style="text-align: right;">false</td>
<td style="text-align: left;">tell Embree to use a more compact BVH in memory by trading ray traversal performance</td>
</tr>
<tr class="even">
<td style="text-align: left;">bool</td>
<td style="text-align: left;">robustMode</td>
<td style="text-align: right;">false</td>
<td style="text-align: left;">tell Embree to enable more robust ray intersection code paths (slightly slower)</td>
</tr>
</tbody>
</table>
<p>Note that groups only need to re re-committed if a geometry or volume changes (surface/scalar field representation). Appearance information on <code>OSPGeometricModel</code> and <code>OSPVolumetricModel</code> can be changed freely, as internal acceleration structures do not need to be reconstructed.</p>
<h3 id="instances">Instances</h3>
<p>Instances in OSPRay represent a single group’s placement into the world via a transform. To create and instance call</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true"></a>OSPInstance ospNewInstance(OSPGroup);</span></code></pre></div>
<table style="width:97%;">
<caption>Parameters understood by instances.</caption>
<colgroup>
<col style="width: 18%" />
<col style="width: 9%" />
<col style="width: 15%" />
<col style="width: 54%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: right;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">affine3f</td>
<td style="text-align: left;">xfm</td>
<td style="text-align: right;">identity</td>
<td style="text-align: left;">world-space transform for all attached geometries and volumes</td>
</tr>
</tbody>
</table>
<h3 id="world">World</h3>
<p>Worlds are a container of scene data represented by <a href="#instances">instances</a>. To create an (empty) world call</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true"></a>OSPWorld ospNewWorld();</span></code></pre></div>
<p>Objects are placed in the world through an array of instances. Similar to <a href="#groups">groups</a>, the array of instances is optional: there is no need to create empty arrays if there are no instances (though there will be nothing to render).</p>
<p>Applications can query the world (axis-aligned) bounding box after the world has been committed. To get this information, call</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true"></a>OSPBounds ospGetBounds(OSPObject);</span></code></pre></div>
<p>The result is returned in the provided <code>OSPBounds</code><a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> struct:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true"></a><span class="kw">typedef</span> <span class="kw">struct</span> {</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true"></a>    <span class="dt">float</span> lower[<span class="dv">3</span>];</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true"></a>    <span class="dt">float</span> upper[<span class="dv">3</span>];</span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true"></a>} OSPBounds;</span></code></pre></div>
<p>This call can also take <code>OSPGroup</code> and <code>OSPInstance</code> as well: all other object types will return an empty bounding box.</p>
<p>Finally, Worlds can be configured with parameters for making various feature/performance trade-offs (similar to groups).</p>
<table style="width:97%;">
<caption>Parameters understood by worlds.</caption>
<colgroup>
<col style="width: 22%" />
<col style="width: 18%" />
<col style="width: 12%" />
<col style="width: 43%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: right;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">OSPInstance[]</td>
<td style="text-align: left;">instance</td>
<td style="text-align: right;">NULL</td>
<td style="text-align: left;"><a href="documentation.html#data">data</a> array with handles of the <a href="#instances">instances</a></td>
</tr>
<tr class="even">
<td style="text-align: left;">OSPLight[]</td>
<td style="text-align: left;">light</td>
<td style="text-align: right;">NULL</td>
<td style="text-align: left;"><a href="documentation.html#data">data</a> array with handles of the <a href="#lights">lights</a></td>
</tr>
<tr class="odd">
<td style="text-align: left;">bool</td>
<td style="text-align: left;">dynamicScene</td>
<td style="text-align: right;">false</td>
<td style="text-align: left;">use RTC_SCENE_DYNAMIC flag (faster BVH build, slower ray traversal), otherwise uses RTC_SCENE_STATIC flag (faster ray traversal, slightly slower BVH build)</td>
</tr>
<tr class="even">
<td style="text-align: left;">bool</td>
<td style="text-align: left;">compactMode</td>
<td style="text-align: right;">false</td>
<td style="text-align: left;">tell Embree to use a more compact BVH in memory by trading ray traversal performance</td>
</tr>
<tr class="odd">
<td style="text-align: left;">bool</td>
<td style="text-align: left;">robustMode</td>
<td style="text-align: right;">false</td>
<td style="text-align: left;">tell Embree to enable more robust ray intersection code paths (slightly slower)</td>
</tr>
</tbody>
</table>
<h2 id="renderers">Renderers</h2>
<p>A renderer is the central object for rendering in OSPRay. Different renderers implement different features and support different materials. To create a new renderer of given type <code>type</code> use</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true"></a>OSPRenderer ospNewRenderer(<span class="at">const</span> <span class="dt">char</span> *type);</span></code></pre></div>
<p>General parameters of all renderers are</p>
<table style="width:98%;">
<caption>Parameters understood by all renderers.</caption>
<colgroup>
<col style="width: 14%" />
<col style="width: 16%" />
<col style="width: 21%" />
<col style="width: 46%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: right;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">int</td>
<td style="text-align: left;">pixelSamples</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">samples per pixel</td>
</tr>
<tr class="even">
<td style="text-align: left;">int</td>
<td style="text-align: left;">maxPathLength</td>
<td style="text-align: right;">20</td>
<td style="text-align: left;">maximum ray recursion depth</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">minContribution</td>
<td style="text-align: right;">0.001</td>
<td style="text-align: left;">sample contributions below this value will be neglected to speedup rendering</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">varianceThreshold</td>
<td style="text-align: right;">0</td>
<td style="text-align: left;">threshold for adaptive accumulation</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float / vec3f / vec4f</td>
<td style="text-align: left;">backgroundColor</td>
<td style="text-align: right;">black, transparent</td>
<td style="text-align: left;">background color and alpha (RGBA), if no <code>map_backplate</code> is set</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSPTexture</td>
<td style="text-align: left;">map_backplate</td>
<td style="text-align: right;"></td>
<td style="text-align: left;">optional <a href="#texture">texture</a> image used as background (use texture type <code>texture2d</code>)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSPTexture</td>
<td style="text-align: left;">map_maxDepth</td>
<td style="text-align: right;"></td>
<td style="text-align: left;">optional screen-sized float <a href="#texture">texture</a> with maximum far distance per pixel (use texture type <code>texture2d</code>)</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSPMaterial[]</td>
<td style="text-align: left;">material</td>
<td style="text-align: right;"></td>
<td style="text-align: left;">optional <a href="documentation.html#data">data</a> array of <a href="#materials">materials</a> which can be indexed by a <a href="documentation.html#geometricmodels">GeometricModel</a>’s <code>material</code> parameter</td>
</tr>
<tr class="odd">
<td style="text-align: left;">uchar</td>
<td style="text-align: left;">pixelFilter</td>
<td style="text-align: right;"><code>OSP_PIXELFILTER_GAUSS</code></td>
<td style="text-align: left;"><code>OSPPixelFilterType</code> to select the pixel filter used by the renderer for antialiasing. Possible pixel filters are listed below.</td>
</tr>
</tbody>
</table>
<p>OSPRay’s renderers support a feature called adaptive accumulation, which accelerates progressive <a href="#rendering">rendering</a> by stopping the rendering and refinement of image regions that have an estimated variance below the <code>varianceThreshold</code>. This feature requires a <a href="#framebuffer">framebuffer</a> with an <code>OSP_FB_VARIANCE</code> channel.</p>
<p>Per default the background of the rendered image will be transparent black, i.e., the alpha channel holds the opacity of the rendered objects. This eases transparency-aware blending of the image with an arbitrary background image by the application. The parameter <code>backgroundColor</code> or <code>map_backplate</code> can be used to already blend with a constant background color or backplate texture, respectively, (and alpha) during rendering.</p>
<p>OSPRay renderers support depth composition with images of other renderers, for example to incorporate help geometries of a 3D UI that were rendered with OpenGL. The screen-sized <a href="#texture">texture</a> <code>map_maxDepth</code> must have format <code>OSP_TEXTURE_R32F</code> and flag <code>OSP_TEXTURE_FILTER_NEAREST</code>. The fetched values are used to limit the distance of primary rays, thus objects of other renderers can hide objects rendered by OSPRay.</p>
<p>OSPRay supports antialiasing in image space by using pixel filters, which are centered around the center of a pixel. The size <span class="math inline"><em>w</em> × <em>w</em></span> of the filter depends on the selected filter type. The types of supported pixel filters are defined by the <code>OSPPixelFilterType</code> enum and can be set using the <code>pixelFilter</code> parameter.</p>
<table style="width:97%;">
<caption>Pixel filter types supported by OSPRay for antialiasing in image space.</caption>
<colgroup>
<col style="width: 44%" />
<col style="width: 53%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">OSP_PIXELFILTER_POINT</td>
<td style="text-align: left;">a point filter only samples the center of the pixel, therefore the filter width is <span class="math inline"><em>w</em> = 0</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_PIXELFILTER_BOX</td>
<td style="text-align: left;">a uniform box filter with a width of <span class="math inline"><em>w</em> = 1</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_PIXELFILTER_GAUSS</td>
<td style="text-align: left;">a truncated, smooth Gaussian filter with a standard deviation of <span class="math inline"><em>σ</em> = 0.5</span> and a filter width of <span class="math inline"><em>w</em> = 3</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_PIXELFILTER_MITCHELL</td>
<td style="text-align: left;">the Mitchell-Netravali filter with a width of <span class="math inline"><em>w</em> = 4</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_PIXELFILTER_BLACKMAN_HARRIS</td>
<td style="text-align: left;">the Blackman-Harris filter with a width of <span class="math inline"><em>w</em> = 3</span></td>
</tr>
</tbody>
</table>
<h3 id="scivis-renderer">SciVis Renderer</h3>
<p>The SciVis renderer is a fast ray tracer for scientific visualization which supports volume rendering and ambient occlusion (AO). It is created by passing the type string “<code>scivis</code>” to <code>ospNewRenderer</code>. In addition to the <a href="#renderer">general parameters</a> understood by all renderers, the SciVis renderer supports the following parameters:</p>
<table style="width:97%;">
<caption>Special parameters understood by the SciVis renderer.</caption>
<colgroup>
<col style="width: 17%" />
<col style="width: 28%" />
<col style="width: 17%" />
<col style="width: 34%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: right;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">bool</td>
<td style="text-align: left;">shadows</td>
<td style="text-align: right;">false</td>
<td style="text-align: left;">whether to compute (hard) shadows</td>
</tr>
<tr class="even">
<td style="text-align: left;">int</td>
<td style="text-align: left;">aoSamples</td>
<td style="text-align: right;">0</td>
<td style="text-align: left;">number of rays per sample to compute ambient occlusion</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">aoDistance</td>
<td style="text-align: right;">10<sup>20</sup></td>
<td style="text-align: left;">maximum distance to consider for ambient occlusion</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">volumeSamplingRate</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">sampling rate for volumes</td>
</tr>
</tbody>
</table>
<p>Note that the intensity (and color) of AO is deduced from an <a href="#ambient-light">ambient light</a> in the <code>lights</code> array.<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a> If <code>aoSamples</code> is zero (the default) then ambient lights cause ambient illumination (without occlusion).</p>
<h3 id="ambient-occlusion-renderer">Ambient Occlusion Renderer</h3>
<p>This renderer supports only a subset of the features of the <a href="documentation.html#scivis-renderer">SciVis renderer</a> to gain performance. As the name suggest its main shading method is ambient occlusion (AO), <a href="#lights">lights</a> are <em>not</em> considered at all and , Volume rendering is supported. The Ambient Occlusion renderer is created by passing the type string “<code>ao</code>” to <code>ospNewRenderer</code>. In addition to the <a href="#renderer">general parameters</a> understood by all renderers the following parameters are supported as well:</p>
<table style="width:97%;">
<caption>Special parameters understood by the Ambient Occlusion renderer.</caption>
<colgroup>
<col style="width: 17%" />
<col style="width: 28%" />
<col style="width: 17%" />
<col style="width: 34%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: right;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">int</td>
<td style="text-align: left;">aoSamples</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">number of rays per sample to compute ambient occlusion</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">aoDistance</td>
<td style="text-align: right;">10<sup>20</sup></td>
<td style="text-align: left;">maximum distance to consider for ambient occlusion</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">aoIntensity</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">ambient occlusion strength</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">volumeSamplingRate</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">sampling rate for volumes</td>
</tr>
</tbody>
</table>
<h3 id="path-tracer">Path Tracer</h3>
<p>The path tracer supports soft shadows, indirect illumination and realistic materials. This renderer is created by passing the type string “<code>pathtracer</code>” to <code>ospNewRenderer</code>. In addition to the <a href="#renderer">general parameters</a> understood by all renderers the path tracer supports the following special parameters:</p>
<table style="width:97%;">
<caption>Special parameters understood by the path tracer.</caption>
<colgroup>
<col style="width: 12%" />
<col style="width: 29%" />
<col style="width: 12%" />
<col style="width: 42%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: right;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">int</td>
<td style="text-align: left;">lightSamples</td>
<td style="text-align: right;">all</td>
<td style="text-align: left;">number of random light samples per path vertex, per default all light sources are sampled</td>
</tr>
<tr class="even">
<td style="text-align: left;">int</td>
<td style="text-align: left;">roulettePathLength</td>
<td style="text-align: right;">5</td>
<td style="text-align: left;">ray recursion depth at which to start Russian roulette termination</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">maxContribution</td>
<td style="text-align: right;">∞</td>
<td style="text-align: left;">samples are clamped to this value before they are accumulated into the framebuffer</td>
</tr>
<tr class="even">
<td style="text-align: left;">bool</td>
<td style="text-align: left;">backgroundRefraction</td>
<td style="text-align: right;">false</td>
<td style="text-align: left;">allow for alpha blending even if background is seen through refractive objects like glass</td>
</tr>
</tbody>
</table>
<p>The path tracer requires that <a href="#materials">materials</a> are assigned to <a href="#geometries">geometries</a>, otherwise surfaces are treated as completely black.</p>
<p>The path tracer supports <a href="#volumes">volumes</a> with multiple scattering. The scattering albedo can be specified using the <a href="#transfer-function">transfer function</a>. Extinction is assumed to be spectrally constant.</p>
<h3 id="materials">Materials</h3>
<p>Materials describe how light interacts with surfaces, they give objects their distinctive look. To let the given renderer create a new material of given type <code>type</code> call</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true"></a>OSPMaterial ospNewMaterial(<span class="at">const</span> <span class="dt">char</span> *<span class="dt">renderer_type</span>, <span class="at">const</span> <span class="dt">char</span> *<span class="dt">material_type</span>);</span></code></pre></div>
<p>The returned handle can then be used to assign the material to a given geometry with</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true"></a><span class="dt">void</span> ospSetObject(OSPGeometricModel, <span class="st">&quot;material&quot;</span>, OSPMaterial);</span></code></pre></div>
<h4 id="obj-material">OBJ Material</h4>
<p>The OBJ material is the workhorse material supported by both the <a href="documentation.html#scivis-renderer">SciVis renderer</a> and the <a href="documentation.html#path-tracer">path tracer</a> (the <a href="#ambient-occlusion-renderer">Ambient Occlusion renderer</a> only uses the <code>kd</code> and <code>d</code> parameter). It offers widely used common properties like diffuse and specular reflection and is based on the <a href="http://paulbourke.net/dataformats/mtl/">MTL material format</a> of Lightwave’s OBJ scene files. To create an OBJ material pass the type string “<code>obj</code>” to <code>ospNewMaterial</code>. Its main parameters are</p>
<table>
<caption>Main parameters of the OBJ material.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: right;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">kd</td>
<td style="text-align: right;">white 0.8</td>
<td style="text-align: left;">diffuse color</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">ks</td>
<td style="text-align: right;">black</td>
<td style="text-align: left;">specular color</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">ns</td>
<td style="text-align: right;">10</td>
<td style="text-align: left;">shininess (Phong exponent), usually in [2–10<sup>4</sup>]</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">d</td>
<td style="text-align: right;">opaque</td>
<td style="text-align: left;">opacity</td>
</tr>
<tr class="odd">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">tf</td>
<td style="text-align: right;">black</td>
<td style="text-align: left;">transparency filter color</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSPTexture</td>
<td style="text-align: left;">map_bump</td>
<td style="text-align: right;">NULL</td>
<td style="text-align: left;">normal map</td>
</tr>
</tbody>
</table>
<p>In particular when using the path tracer it is important to adhere to the principle of energy conservation, i.e., that the amount of light reflected by a surface is not larger than the light arriving. Therefore the path tracer issues a warning and renormalizes the color parameters if the sum of <code>Kd</code>, <code>Ks</code>, and <code>Tf</code> is larger than one in any color channel. Similarly important to mention is that almost all materials of the real world reflect at most only about 80% of the incoming light. So even for a white sheet of paper or white wall paint do better not set <code>Kd</code> larger than 0.8; otherwise rendering times are unnecessary long and the contrast in the final images is low (for example, the corners of a white room would hardly be discernible, as can be seen in the figure below).</p>
<figure>
<img src="images/diffuse_rooms.png" style="width:80.0%" alt="Comparison of diffuse rooms with 100% reflecting white paint (left) and realistic 80% reflecting white paint (right), which leads to higher overall contrast. Note that exposure has been adjusted to achieve similar brightness levels." /><figcaption aria-hidden="true">Comparison of diffuse rooms with 100% reflecting white paint (left) and realistic 80% reflecting white paint (right), which leads to higher overall contrast. Note that exposure has been adjusted to achieve similar brightness levels.</figcaption>
</figure>
<p>If present, the color component of <a href="#geometries">geometries</a> is also used for the diffuse color <code>Kd</code> and the alpha component is also used for the opacity <code>d</code>.</p>
<p>Normal mapping can simulate small geometric features via the texture <code>map_Bump</code>. The normals <span class="math inline"><em>n</em></span> in the normal map are with respect to the local tangential shading coordinate system and are encoded as <span class="math inline">½(<em>n</em> + 1)</span>, thus a texel <span class="math inline">(0.5, 0.5, 1)</span><a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a> represents the unperturbed shading normal <span class="math inline">(0, 0, 1)</span>. Because of this encoding an sRGB gamma <a href="#texture">texture</a> format is ignored and normals are always fetched as linear from a normal map. Note that the orientation of normal maps is important for a visually consistent look: by convention OSPRay uses a coordinate system with the origin in the lower left corner; thus a convexity will look green toward the top of the texture image (see also the example image of a normal map). If this is not the case flip the normal map vertically or invert its green channel.</p>
<figure>
<img src="images/normalmap_frustum.png" style="width:60.0%" alt="Normal map representing an exalted square pyramidal frustum." /><figcaption aria-hidden="true">Normal map representing an exalted square pyramidal frustum.</figcaption>
</figure>
<p>Note that currently only the path tracer implements colored transparency with <code>Tf</code> and normal mapping with <code>map_Bump</code>.</p>
<p>All parameters (except <code>Tf</code>) can be textured by passing a <a href="#texture">texture</a> handle, prefixed with “<code>map_</code>”. The fetched texels are multiplied by the respective parameter value. If only the texture is given (but not the corresponding parameter), only the texture is used (the default value of the parameter is <em>not</em> multiplied). The color textures <code>map_Kd</code> and <code>map_Ks</code> are typically in one of the sRGB gamma encoded formats, whereas textures <code>map_Ns</code> and <code>map_d</code> are usually in a linear format (and only the first component is used). Additionally, all textures support <a href="documentation.html#texture-transformations">texture transformations</a>.</p>
<figure>
<img src="images/material_OBJ.jpg" style="width:60.0%" alt="Rendering of a OBJ material with wood textures." /><figcaption aria-hidden="true">Rendering of a OBJ material with wood textures.</figcaption>
</figure>
<h4 id="principled">Principled</h4>
<p>The Principled material is the most complex material offered by the <a href="documentation.html#path-tracer">path tracer</a>, which is capable of producing a wide variety of materials (e.g., plastic, metal, wood, glass) by combining multiple different layers and lobes. It uses the GGX microfacet distribution with approximate multiple scattering for dielectrics and metals, uses the Oren-Nayar model for diffuse reflection, and is energy conserving. To create a Principled material, pass the type string “<code>principled</code>” to <code>ospNewMaterial</code>. Its parameters are listed in the table below.</p>
<table style="width:98%;">
<caption>Parameters of the Principled material.</caption>
<colgroup>
<col style="width: 9%" />
<col style="width: 24%" />
<col style="width: 12%" />
<col style="width: 51%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: right;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">baseColor</td>
<td style="text-align: right;">white 0.8</td>
<td style="text-align: left;">base reflectivity (diffuse and/or metallic)</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">edgeColor</td>
<td style="text-align: right;">white</td>
<td style="text-align: left;">edge tint (metallic only)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">metallic</td>
<td style="text-align: right;">0</td>
<td style="text-align: left;">mix between dielectric (diffuse and/or specular) and metallic (specular only with complex IOR) in [0–1]</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">diffuse</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">diffuse reflection weight in [0–1]</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">specular</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">specular reflection/transmission weight in [0–1]</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">ior</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">dielectric index of refraction</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">transmission</td>
<td style="text-align: right;">0</td>
<td style="text-align: left;">specular transmission weight in [0–1]</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">transmissionColor</td>
<td style="text-align: right;">white</td>
<td style="text-align: left;">attenuated color due to transmission (Beer’s law)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">transmissionDepth</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">distance at which color attenuation is equal to transmissionColor</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">roughness</td>
<td style="text-align: right;">0</td>
<td style="text-align: left;">diffuse and specular roughness in [0–1], 0 is perfectly smooth</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">anisotropy</td>
<td style="text-align: right;">0</td>
<td style="text-align: left;">amount of specular anisotropy in [0–1]</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">rotation</td>
<td style="text-align: right;">0</td>
<td style="text-align: left;">rotation of the direction of anisotropy in [0–1], 1 is going full circle</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">normal</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">default normal map/scale for all layers</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">baseNormal</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">base normal map/scale (overrides default normal)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">bool</td>
<td style="text-align: left;">thin</td>
<td style="text-align: right;">false</td>
<td style="text-align: left;">flag specifying whether the material is thin or solid</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">thickness</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">thickness of the material (thin only), affects the amount of color attenuation due to specular transmission</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">backlight</td>
<td style="text-align: right;">0</td>
<td style="text-align: left;">amount of diffuse transmission (thin only) in [0–2], 1 is 50% reflection and 50% transmission, 2 is transmission only</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">coat</td>
<td style="text-align: right;">0</td>
<td style="text-align: left;">clear coat layer weight in [0–1]</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">coatIor</td>
<td style="text-align: right;">1.5</td>
<td style="text-align: left;">clear coat index of refraction</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">coatColor</td>
<td style="text-align: right;">white</td>
<td style="text-align: left;">clear coat color tint</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">coatThickness</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">clear coat thickness, affects the amount of color attenuation</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">coatRoughness</td>
<td style="text-align: right;">0</td>
<td style="text-align: left;">clear coat roughness in [0–1], 0 is perfectly smooth</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">coatNormal</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">clear coat normal map/scale (overrides default normal)</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">sheen</td>
<td style="text-align: right;">0</td>
<td style="text-align: left;">sheen layer weight in [0–1]</td>
</tr>
<tr class="odd">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">sheenColor</td>
<td style="text-align: right;">white</td>
<td style="text-align: left;">sheen color tint</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">sheenTint</td>
<td style="text-align: right;">0</td>
<td style="text-align: left;">how much sheen is tinted from sheenColor toward baseColor</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">sheenRoughness</td>
<td style="text-align: right;">0.2</td>
<td style="text-align: left;">sheen roughness in [0–1], 0 is perfectly smooth</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">opacity</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">cut-out opacity/transparency, 1 is fully opaque</td>
</tr>
</tbody>
</table>
<p>All parameters can be textured by passing a <a href="#texture">texture</a> handle, prefixed with “<code>map_</code>” (e.g., “<code>map_baseColor</code>”). <a href="documentation.html#texture-transformations">texture transformations</a> are supported as well.</p>
<figure>
<img src="images/material_Principled.jpg" style="width:60.0%" alt="Rendering of a Principled coated brushed metal material with textured anisotropic rotation and a dust layer (sheen) on top." /><figcaption aria-hidden="true">Rendering of a Principled coated brushed metal material with textured anisotropic rotation and a dust layer (sheen) on top.</figcaption>
</figure>
<h4 id="carpaint">CarPaint</h4>
<p>The CarPaint material is a specialized version of the Principled material for rendering different types of car paints. To create a CarPaint material, pass the type string “<code>carPaint</code>” to <code>ospNewMaterial</code>. Its parameters are listed in the table below.</p>
<table style="width:98%;">
<caption>Parameters of the CarPaint material.</caption>
<colgroup>
<col style="width: 9%" />
<col style="width: 21%" />
<col style="width: 14%" />
<col style="width: 51%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: right;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">baseColor</td>
<td style="text-align: right;">white 0.8</td>
<td style="text-align: left;">diffuse base reflectivity</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">roughness</td>
<td style="text-align: right;">0</td>
<td style="text-align: left;">diffuse roughness in [0–1], 0 is perfectly smooth</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">normal</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">normal map/scale</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec3f float</td>
<td style="text-align: left;">flakeColor flakeDensity</td>
<td style="text-align: right;">Aluminium 0</td>
<td style="text-align: left;">color of metallic flakes density of metallic flakes in [0–1], 0 disables flakes, 1 fully covers the surface with flakes</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">flakeScale</td>
<td style="text-align: right;">100</td>
<td style="text-align: left;">scale of the flake structure, higher values increase the amount of flakes</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">flakeSpread</td>
<td style="text-align: right;">0.3</td>
<td style="text-align: left;">flake spread in [0–1]</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">flakeJitter</td>
<td style="text-align: right;">0.75</td>
<td style="text-align: left;">flake randomness in [0–1]</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">flakeRoughness</td>
<td style="text-align: right;">0.3</td>
<td style="text-align: left;">flake roughness in [0–1], 0 is perfectly smooth</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">coat</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">clear coat layer weight in [0–1]</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">coatIor</td>
<td style="text-align: right;">1.5</td>
<td style="text-align: left;">clear coat index of refraction</td>
</tr>
<tr class="odd">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">coatColor</td>
<td style="text-align: right;">white</td>
<td style="text-align: left;">clear coat color tint</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">coatThickness</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">clear coat thickness, affects the amount of color attenuation</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">coatRoughness</td>
<td style="text-align: right;">0</td>
<td style="text-align: left;">clear coat roughness in [0–1], 0 is perfectly smooth</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">coatNormal</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">clear coat normal map/scale</td>
</tr>
<tr class="odd">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">flipflopColor</td>
<td style="text-align: right;">white</td>
<td style="text-align: left;">reflectivity of coated flakes at grazing angle, used together with coatColor produces a pearlescent paint</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">flipflopFalloff</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">flip flop color falloff, 1 disables the flip flop effect</td>
</tr>
</tbody>
</table>
<p>All parameters can be textured by passing a <a href="#texture">texture</a> handle, prefixed with “<code>map_</code>” (e.g., “<code>map_baseColor</code>”). <a href="documentation.html#texture-transformations">texture transformations</a> are supported as well.</p>
<figure>
<img src="images/material_CarPaint.jpg" style="width:60.0%" alt="Rendering of a pearlescent CarPaint material." /><figcaption aria-hidden="true">Rendering of a pearlescent CarPaint material.</figcaption>
</figure>
<h4 id="metal">Metal</h4>
<p>The <a href="documentation.html#path-tracer">path tracer</a> offers a physical metal, supporting changing roughness and realistic color shifts at edges. To create a Metal material pass the type string “<code>metal</code>” to <code>ospNewMaterial</code>. Its parameters are</p>
<table style="width:97%;">
<caption>Parameters of the Metal material.</caption>
<colgroup>
<col style="width: 15%" />
<col style="width: 15%" />
<col style="width: 15%" />
<col style="width: 51%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: right;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">vec3f[]</td>
<td style="text-align: left;">ior</td>
<td style="text-align: right;">Aluminium</td>
<td style="text-align: left;"><a href="documentation.html#data">data</a> array of spectral samples of complex refractive index, each entry in the form (wavelength, eta, k), ordered by wavelength (which is in nm)</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">eta</td>
<td style="text-align: right;"></td>
<td style="text-align: left;">RGB complex refractive index, real part</td>
</tr>
<tr class="odd">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">k</td>
<td style="text-align: right;"></td>
<td style="text-align: left;">RGB complex refractive index, imaginary part</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">roughness</td>
<td style="text-align: right;">0.1</td>
<td style="text-align: left;">roughness in [0–1], 0 is perfect mirror</td>
</tr>
</tbody>
</table>
<p>The main appearance (mostly the color) of the Metal material is controlled by the physical parameters <code>eta</code> and <code>k</code>, the wavelength-dependent, complex index of refraction. These coefficients are quite counter-intuitive but can be found in <a href="https://refractiveindex.info/">published measurements</a>. For accuracy the index of refraction can be given as an array of spectral samples in <code>ior</code>, each sample a triplet of wavelength (in nm), eta, and k, ordered monotonically increasing by wavelength; OSPRay will then calculate the Fresnel in the spectral domain. Alternatively, <code>eta</code> and <code>k</code> can also be specified as approximated RGB coefficients; some examples are given in below table.</p>
<table>
<caption>Index of refraction of selected metals as approximated RGB coefficients, based on data from https://refractiveindex.info/.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Metal</th>
<th style="text-align: center;">eta</th>
<th style="text-align: center;">k</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Ag, Silver</td>
<td style="text-align: center;">(0.051, 0.043, 0.041)</td>
<td style="text-align: center;">(5.3, 3.6, 2.3)</td>
</tr>
<tr class="even">
<td style="text-align: left;">Al, Aluminium</td>
<td style="text-align: center;">(1.5, 0.98, 0.6)</td>
<td style="text-align: center;">(7.6, 6.6, 5.4)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Au, Gold</td>
<td style="text-align: center;">(0.07, 0.37, 1.5)</td>
<td style="text-align: center;">(3.7, 2.3, 1.7)</td>
</tr>
<tr class="even">
<td style="text-align: left;">Cr, Chromium</td>
<td style="text-align: center;">(3.2, 3.1, 2.3)</td>
<td style="text-align: center;">(3.3, 3.3, 3.1)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Cu, Copper</td>
<td style="text-align: center;">(0.1, 0.8, 1.1)</td>
<td style="text-align: center;">(3.5, 2.5, 2.4)</td>
</tr>
</tbody>
</table>
<p>The <code>roughness</code> parameter controls the variation of microfacets and thus how polished the metal will look. The roughness can be modified by a <a href="#texture">texture</a> <code>map_roughness</code> (<a href="documentation.html#texture-transformations">texture transformations</a> are supported as well) to create notable edging effects.</p>
<figure>
<img src="images/material_Metal.jpg" style="width:60.0%" alt="Rendering of golden Metal material with textured roughness." /><figcaption aria-hidden="true">Rendering of golden Metal material with textured roughness.</figcaption>
</figure>
<h4 id="alloy">Alloy</h4>
<p>The <a href="documentation.html#path-tracer">path tracer</a> offers an alloy material, which behaves similar to <a href="#metal">Metal</a>, but allows for more intuitive and flexible control of the color. To create an Alloy material pass the type string “<code>alloy</code>” to <code>ospNewMaterial</code>. Its parameters are</p>
<table>
<caption>Parameters of the Alloy material.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: right;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">color</td>
<td style="text-align: right;">white 0.9</td>
<td style="text-align: left;">reflectivity at normal incidence (0 degree)</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">edgeColor</td>
<td style="text-align: right;">white</td>
<td style="text-align: left;">reflectivity at grazing angle (90 degree)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">roughness</td>
<td style="text-align: right;">0.1</td>
<td style="text-align: left;">roughness, in [0–1], 0 is perfect mirror</td>
</tr>
</tbody>
</table>
<p>The main appearance of the Alloy material is controlled by the parameter <code>color</code>, while <code>edgeColor</code> influences the tint of reflections when seen at grazing angles (for real metals this is always 100% white). If present, the color component of <a href="#geometries">geometries</a> is also used for reflectivity at normal incidence <code>color</code>. As in <a href="#metal">Metal</a> the <code>roughness</code> parameter controls the variation of microfacets and thus how polished the alloy will look. All parameters can be textured by passing a <a href="#texture">texture</a> handle, prefixed with “<code>map_</code>”; <a href="documentation.html#texture-transformations">texture transformations</a> are supported as well.</p>
<figure>
<img src="images/material_Alloy.jpg" style="width:60.0%" alt="Rendering of a fictional Alloy material with textured color." /><figcaption aria-hidden="true">Rendering of a fictional Alloy material with textured color.</figcaption>
</figure>
<h4 id="glass">Glass</h4>
<p>The <a href="documentation.html#path-tracer">path tracer</a> offers a realistic a glass material, supporting refraction and volumetric attenuation (i.e., the transparency color varies with the geometric thickness). To create a Glass material pass the type string “<code>glass</code>” to <code>ospNewMaterial</code>. Its parameters are</p>
<table>
<caption>Parameters of the Glass material.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: right;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">eta</td>
<td style="text-align: right;">1.5</td>
<td style="text-align: left;">index of refraction</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">attenuationColor</td>
<td style="text-align: right;">white</td>
<td style="text-align: left;">resulting color due to attenuation</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">attenuationDistance</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">distance affecting attenuation</td>
</tr>
</tbody>
</table>
<p>For convenience, the rather counter-intuitive physical attenuation coefficients will be calculated from the user inputs in such a way, that the <code>attenuationColor</code> will be the result when white light traveled trough a glass of thickness <code>attenuationDistance</code>.</p>
<figure>
<img src="images/material_Glass.jpg" style="width:60.0%" alt="Rendering of a Glass material with orange attenuation." /><figcaption aria-hidden="true">Rendering of a Glass material with orange attenuation.</figcaption>
</figure>
<h4 id="thinglass">ThinGlass</h4>
<p>The <a href="documentation.html#path-tracer">path tracer</a> offers a thin glass material useful for objects with just a single surface, most prominently windows. It models a thin, transparent slab, i.e., it behaves as if a second, virtual surface is parallel to the real geometric surface. The implementation accounts for multiple internal reflections between the interfaces (including attenuation), but neglects parallax effects due to its (virtual) thickness. To create a such a thin glass material pass the type string “<code>thinGlass</code>” to <code>ospNewMaterial</code>. Its parameters are</p>
<table>
<caption>Parameters of the ThinGlass material.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: right;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">eta</td>
<td style="text-align: right;">1.5</td>
<td style="text-align: left;">index of refraction</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">attenuationColor</td>
<td style="text-align: right;">white</td>
<td style="text-align: left;">resulting color due to attenuation</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">attenuationDistance</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">distance affecting attenuation</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">thickness</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">virtual thickness</td>
</tr>
</tbody>
</table>
<p>For convenience the attenuation is controlled the same way as with the <a href="#glass">Glass</a> material. Additionally, the color due to attenuation can be modulated with a <a href="#texture">texture</a> <code>map_attenuationColor</code> (<a href="documentation.html#texture-transformations">texture transformations</a> are supported as well). If present, the color component of <a href="#geometries">geometries</a> is also used for the attenuation color. The <code>thickness</code> parameter sets the (virtual) thickness and allows for easy exchange of parameters with the (real) <a href="#glass">Glass</a> material; internally just the ratio between <code>attenuationDistance</code> and <code>thickness</code> is used to calculate the resulting attenuation and thus the material appearance.</p>
<figure>
<img src="images/material_ThinGlass.jpg" style="width:60.0%" alt="Rendering of a ThinGlass material with red attenuation." /><figcaption aria-hidden="true">Rendering of a ThinGlass material with red attenuation.</figcaption>
</figure>
<figure>
<img src="images/ColoredWindow.jpg" style="width:60.0%" alt="Example image of a colored window made with textured attenuation of the ThinGlass material." /><figcaption aria-hidden="true">Example image of a colored window made with textured attenuation of the ThinGlass material.</figcaption>
</figure>
<h4 id="metallicpaint">MetallicPaint</h4>
<p>The <a href="documentation.html#path-tracer">path tracer</a> offers a metallic paint material, consisting of a base coat with optional flakes and a clear coat. To create a MetallicPaint material pass the type string “<code>metallicPaint</code>” to <code>ospNewMaterial</code>. Its parameters are listed in the table below.</p>
<table>
<caption>Parameters of the MetallicPaint material.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: right;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">baseColor</td>
<td style="text-align: right;">white 0.8</td>
<td style="text-align: left;">color of base coat</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">flakeAmount</td>
<td style="text-align: right;">0.3</td>
<td style="text-align: left;">amount of flakes, in [0–1]</td>
</tr>
<tr class="odd">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">flakeColor</td>
<td style="text-align: right;">Aluminium</td>
<td style="text-align: left;">color of metallic flakes</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">flakeSpread</td>
<td style="text-align: right;">0.5</td>
<td style="text-align: left;">spread of flakes, in [0–1]</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">eta</td>
<td style="text-align: right;">1.5</td>
<td style="text-align: left;">index of refraction of clear coat</td>
</tr>
</tbody>
</table>
<p>The color of the base coat <code>baseColor</code> can be textured by a <a href="#texture">texture</a> <code>map_baseColor</code>, which also supports <a href="documentation.html#texture-transformations">texture transformations</a>. If present, the color component of <a href="#geometries">geometries</a> is also used for the color of the base coat. Parameter <code>flakeAmount</code> controls the proportion of flakes in the base coat, so when setting it to 1 the <code>baseColor</code> will not be visible. The shininess of the metallic component is governed by <code>flakeSpread</code>, which controls the variation of the orientation of the flakes, similar to the <code>roughness</code> parameter of <a href="#metal">Metal</a>. Note that the effect of the metallic flakes is currently only computed on average, thus individual flakes are not visible.</p>
<figure>
<img src="images/material_MetallicPaint.jpg" style="width:60.0%" alt="Rendering of a MetallicPaint material." /><figcaption aria-hidden="true">Rendering of a MetallicPaint material.</figcaption>
</figure>
<h4 id="luminous">Luminous</h4>
<p>The <a href="documentation.html#path-tracer">path tracer</a> supports the Luminous material which emits light uniformly in all directions and which can thus be used to turn any geometric object into a light source<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a>. It is created by passing the type string “<code>luminous</code>” to <code>ospNewMaterial</code>. The amount of constant radiance that is emitted is determined by combining the general parameters of lights: <a href="#lights"><code>color</code> and <code>intensity</code></a>.</p>
<table>
<caption>Parameters accepted by the Luminous material.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: right;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">color</td>
<td style="text-align: right;">white</td>
<td style="text-align: left;">color of the emitted light</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">intensity</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">intensity of the light (a factor)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">transparency</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">material transparency</td>
</tr>
</tbody>
</table>
<figure>
<img src="images/material_Luminous.jpg" style="width:60.0%" alt="Rendering of a yellow Luminous material." /><figcaption aria-hidden="true">Rendering of a yellow Luminous material.</figcaption>
</figure>
<h3 id="texture">Texture</h3>
<p>OSPRay currently implements two texture types (<code>texture2d</code> and <code>volume</code>) and is open for extension to other types by applications. More types may be added in future releases.</p>
<p>To create a new texture use</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true"></a>OSPTexture ospNewTexture(<span class="at">const</span> <span class="dt">char</span> *type);</span></code></pre></div>
<h4 id="texture2d">Texture2D</h4>
<p>The <code>texture2d</code> texture type implements an image-based texture, where its parameters are as follows</p>
<table>
<caption>Parameters of <code>texture2d</code> texture type.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">int</td>
<td style="text-align: left;">format</td>
<td style="text-align: left;"><code>OSPTextureFormat</code> for the texture</td>
</tr>
<tr class="even">
<td style="text-align: left;">int</td>
<td style="text-align: left;">filter</td>
<td style="text-align: left;">default <code>OSP_TEXTURE_FILTER_BILINEAR</code>, alternatively <code>OSP_TEXTURE_FILTER_NEAREST</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSPData</td>
<td style="text-align: left;">data</td>
<td style="text-align: left;">the actual texel 2D <a href="documentation.html#data">data</a></td>
</tr>
</tbody>
</table>
<p>The supported texture formats for <code>texture2d</code> are:</p>
<table>
<caption>Supported texture formats by <code>texture2d</code>, i.e., valid constants of type <code>OSPTextureFormat</code>.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">OSP_TEXTURE_RGBA8</td>
<td style="text-align: left;">8 bit [0–255] linear components red, green, blue, alpha</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_TEXTURE_SRGBA</td>
<td style="text-align: left;">8 bit sRGB gamma encoded color components, and linear alpha</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_TEXTURE_RGBA32F</td>
<td style="text-align: left;">32 bit float components red, green, blue, alpha</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_TEXTURE_RGB8</td>
<td style="text-align: left;">8 bit [0–255] linear components red, green, blue</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_TEXTURE_SRGB</td>
<td style="text-align: left;">8 bit sRGB gamma encoded components red, green, blue</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_TEXTURE_RGB32F</td>
<td style="text-align: left;">32 bit float components red, green, blue</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_TEXTURE_R8</td>
<td style="text-align: left;">8 bit [0–255] linear single component red</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_TEXTURE_RA8</td>
<td style="text-align: left;">8 bit [0–255] linear two components red, alpha</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_TEXTURE_L8</td>
<td style="text-align: left;">8 bit [0–255] gamma encoded luminance (replicated into red, green, blue)</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_TEXTURE_LA8</td>
<td style="text-align: left;">8 bit [0–255] gamma encoded luminance, and linear alpha</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_TEXTURE_R32F</td>
<td style="text-align: left;">32 bit float single component red</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_TEXTURE_RGBA16</td>
<td style="text-align: left;">16 bit [0–65535] linear components red, green, blue, alpha</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_TEXTURE_RGB16</td>
<td style="text-align: left;">16 bit [0–65535] linear components red, green, blue</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_TEXTURE_RA16</td>
<td style="text-align: left;">16 bit [0–65535] linear two components red, alpha</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_TEXTURE_R16</td>
<td style="text-align: left;">16 bit [0–65535] linear single component red</td>
</tr>
</tbody>
</table>
<p>The size of the texture is inferred from the size of the 2D array <code>data</code>, which also needs have a compatible type to <code>format</code>. The texel data in <code>data</code> starts with the texels in the lower left corner of the texture image, like in OpenGL. Per default a texture fetch is filtered by performing bi-linear interpolation of the nearest 2×2 texels; if instead fetching only the nearest texel is desired (i.e., no filtering) then pass the <code>OSP_TEXTURE_FILTER_NEAREST</code> flag.</p>
<p>Texturing with <code>texture2d</code> image textures requires <a href="#geometries">geometries</a> with texture coordinates, e.g., a <a href="#mesh">mesh</a> with <code>vertex.texcoord</code> provided.</p>
<h4 id="volume-texture">Volume Texture</h4>
<p>The <code>volume</code> texture type implements texture lookups based on 3D object coordinates of the surface hit point on the associated geometry. If the given hit point is within the attached volume, the volume is sampled and classified with the transfer function attached to the volume. This implements the ability to visualize volume values (as colored by a transfer function) on arbitrary surfaces inside the volume (as opposed to an isosurface showing a particular value in the volume). Its parameters are as follows</p>
<table>
<caption>Parameters of <code>volume</code> texture type.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">OSPVolume</td>
<td style="text-align: left;">volume</td>
<td style="text-align: left;"><a href="documentation.html#volumes">Volume</a> used to generate color lookups</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSPTransferFunction</td>
<td style="text-align: left;">transferFunction</td>
<td style="text-align: left;">[TransferFunction] applied to <code>volume</code></td>
</tr>
</tbody>
</table>
<p>TextureVolume can be used for implementing slicing of volumes with any geometry type. It enables coloring of the slicing geometry with a different transfer function than that of the sliced volume.</p>
<h4 id="texture-transformations">Texture Transformations</h4>
<p>All materials with textures also offer to manipulate the placement of these textures with the help of texture transformations. If so, this convention shall be used: the following parameters are prefixed with “<code>texture_name.</code>”).</p>
<table>
<caption>Parameters to define 2D texture coordinate transformations.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">linear2f</td>
<td style="text-align: left;">transform</td>
<td style="text-align: left;">linear transformation (rotation, scale)</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">rotation</td>
<td style="text-align: left;">angle in degree, counterclockwise, around center</td>
</tr>
<tr class="odd">
<td style="text-align: left;">vec2f</td>
<td style="text-align: left;">scale</td>
<td style="text-align: left;">enlarge texture, relative to center (0.5, 0.5)</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec2f</td>
<td style="text-align: left;">translation</td>
<td style="text-align: left;">move texture in positive direction (right/up)</td>
</tr>
</tbody>
</table>
<p>Above parameters are combined into a single <code>affine2d</code> transformation matrix and the transformations are applied in the given order. Rotation, scale and translation are interpreted “texture centric”, i.e., their effect seen by an user are relative to the texture (although the transformations are applied to the texture coordinates).</p>
<table>
<caption>Parameter to define 3D volume texture transformations.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">affine3f</td>
<td style="text-align: left;">transform</td>
<td style="text-align: left;">linear transformation (rotation, scale) plus translation</td>
</tr>
</tbody>
</table>
<p>Similarly, volume texture placement can also be modified by an <code>affine3f</code> transformation matrix.</p>
<h3 id="cameras">Cameras</h3>
<p>To create a new camera of given type <code>type</code> use</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true"></a>OSPCamera ospNewCamera(<span class="at">const</span> <span class="dt">char</span> *type);</span></code></pre></div>
<p>All cameras accept these parameters:</p>
<table>
<caption>Parameters accepted by all cameras.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">position</td>
<td style="text-align: left;">position of the camera in world-space</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">direction</td>
<td style="text-align: left;">main viewing direction of the camera</td>
</tr>
<tr class="odd">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">up</td>
<td style="text-align: left;">up direction of the camera</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">nearClip</td>
<td style="text-align: left;">near clipping distance</td>
</tr>
<tr class="odd">
<td style="text-align: left;">vec2f</td>
<td style="text-align: left;">imageStart</td>
<td style="text-align: left;">start of image region (lower left corner)</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec2f</td>
<td style="text-align: left;">imageEnd</td>
<td style="text-align: left;">end of image region (upper right corner)</td>
</tr>
</tbody>
</table>
<p>The camera is placed and oriented in the world with <code>position</code>, <code>direction</code> and <code>up</code>. OSPRay uses a right-handed coordinate system. The region of the camera sensor that is rendered to the image can be specified in normalized screen-space coordinates with <code>imageStart</code> (lower left corner) and <code>imageEnd</code> (upper right corner). This can be used, for example, to crop the image, to achieve asymmetrical view frusta, or to horizontally flip the image to view scenes which are specified in a left-handed coordinate system. Note that values outside the default range of [0–1] are valid, which is useful to easily realize overscan or film gate, or to emulate a shifted sensor.</p>
<h4 id="perspective-camera">Perspective Camera</h4>
<p>The perspective camera implements a simple thin lens camera for perspective rendering, supporting optionally depth of field and stereo rendering, but no motion blur. It is created by passing the type string “<code>perspective</code>” to <code>ospNewCamera</code>. In addition to the <a href="#cameras">general parameters</a> understood by all cameras the perspective camera supports the special parameters listed in the table below.</p>
<table style="width:97%;">
<caption>Additional parameters accepted by the perspective camera.</caption>
<colgroup>
<col style="width: 10%" />
<col style="width: 32%" />
<col style="width: 53%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">fovy</td>
<td style="text-align: left;">the field of view (angle in degree) of the frame’s height</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">aspect</td>
<td style="text-align: left;">ratio of width by height of the frame (and image region)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">apertureRadius</td>
<td style="text-align: left;">size of the aperture, controls the depth of field</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">focusDistance</td>
<td style="text-align: left;">distance at where the image is sharpest when depth of field is enabled</td>
</tr>
<tr class="odd">
<td style="text-align: left;">bool</td>
<td style="text-align: left;">architectural</td>
<td style="text-align: left;">vertical edges are projected to be parallel</td>
</tr>
<tr class="even">
<td style="text-align: left;">uchar</td>
<td style="text-align: left;">stereoMode</td>
<td style="text-align: left;"><code>OSPStereoMode</code> for stereo rendering, possible values are:</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><code>OSP_STEREO_NONE</code> (default)</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><code>OSP_STEREO_LEFT</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><code>OSP_STEREO_RIGHT</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><code>OSP_STEREO_SIDE_BY_SIDE</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><code>OSP_STEREO_TOP_BOTTOM</code> (left eye at top half)</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">interpupillaryDistance</td>
<td style="text-align: left;">distance between left and right eye when stereo is enabled, default 0.0635</td>
</tr>
</tbody>
</table>
<p>Note that when computing the <code>aspect</code> ratio a potentially set image region (using <code>imageStart</code> &amp; <code>imageEnd</code>) needs to be regarded as well.</p>
<p>In architectural photography it is often desired for aesthetic reasons to display the vertical edges of buildings or walls vertically in the image as well, regardless of how the camera is tilted. Enabling the <code>architectural</code> mode achieves this by internally leveling the camera parallel to the ground (based on the <code>up</code> direction) and then shifting the lens such that the objects in direction <code>dir</code> are centered in the image. If finer control of the lens shift is needed use <code>imageStart</code> &amp; <code>imageEnd</code>. Because the camera is now effectively leveled its image plane and thus the plane of focus is oriented parallel to the front of buildings, the whole façade appears sharp, as can be seen in the example images below. The resolution of the <a href="#framebuffer">framebuffer</a> is not altered by <code>imageStart</code>/<code>imageEnd</code>.</p>
<figure>
<img src="images/camera_perspective.jpg" style="width:60.0%" alt="Example image created with the perspective camera, featuring depth of field." /><figcaption aria-hidden="true">Example image created with the perspective camera, featuring depth of field.</figcaption>
</figure>
<figure>
<img src="images/camera_architectural.jpg" style="width:60.0%" alt="Enabling the architectural flag corrects the perspective projection distortion, resulting in parallel vertical edges." /><figcaption aria-hidden="true">Enabling the <code>architectural</code> flag corrects the perspective projection distortion, resulting in parallel vertical edges.</figcaption>
</figure>
<figure>
<img src="images/camera_stereo.jpg" style="width:90.0%" alt="Example 3D stereo image using stereoMode = OSP_STEREO_SIDE_BY_SIDE." /><figcaption aria-hidden="true">Example 3D stereo image using <code>stereoMode = OSP_STEREO_SIDE_BY_SIDE</code>.</figcaption>
</figure>
<h4 id="orthographic-camera">Orthographic Camera</h4>
<p>The orthographic camera implements a simple camera with orthographic projection, without support for depth of field or motion blur. It is created by passing the type string “<code>orthographic</code>” to <code>ospNewCamera</code>. In addition to the <a href="#cameras">general parameters</a> understood by all cameras the orthographic camera supports the following special parameters:</p>
<table>
<caption>Additional parameters accepted by the orthographic camera.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">height</td>
<td style="text-align: left;">size of the camera’s image plane in y, in world coordinates</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">aspect</td>
<td style="text-align: left;">ratio of width by height of the frame</td>
</tr>
</tbody>
</table>
<p>For convenience the size of the camera sensor, and thus the extent of the scene that is captured in the image, can be controlled with the <code>height</code> parameter. The same effect can be achieved with <code>imageStart</code> and <code>imageEnd</code>, and both methods can be combined. In any case, the <code>aspect</code> ratio needs to be set accordingly to get an undistorted image.</p>
<figure>
<img src="images/camera_orthographic.jpg" style="width:60.0%" alt="Example image created with the orthographic camera." /><figcaption aria-hidden="true">Example image created with the orthographic camera.</figcaption>
</figure>
<h4 id="panoramic-camera">Panoramic Camera</h4>
<p>The panoramic camera implements a simple camera with support for stereo rendering. It captures the complete surrounding with a latitude / longitude mapping and thus the rendered images should best have a ratio of 2:1. A panoramic camera is created by passing the type string “<code>panoramic</code>” to <code>ospNewCamera</code>. It is placed and oriented in the scene by using the <a href="#cameras">general parameters</a> understood by all cameras.</p>
<table style="width:97%;">
<caption>Additional parameters accepted by the panoramic camera.</caption>
<colgroup>
<col style="width: 10%" />
<col style="width: 32%" />
<col style="width: 53%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">uchar</td>
<td style="text-align: left;">stereoMode</td>
<td style="text-align: left;"><code>OSPStereoMode</code> for stereo rendering, possible values are:</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><code>OSP_STEREO_NONE</code> (default)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><code>OSP_STEREO_LEFT</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><code>OSP_STEREO_RIGHT</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><code>OSP_STEREO_SIDE_BY_SIDE</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><code>OSP_STEREO_TOP_BOTTOM</code> (left eye at top half)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">interpupillaryDistance</td>
<td style="text-align: left;">distance between left and right eye when stereo is enabled, default 0.0635</td>
</tr>
</tbody>
</table>
<figure>
<img src="images/camera_panoramic.jpg" style="width:90.0%" alt="Latitude / longitude map created with the panoramic camera." /><figcaption aria-hidden="true">Latitude / longitude map created with the panoramic camera.</figcaption>
</figure>
<h3 id="picking">Picking</h3>
<p>To get the world-space position of the geometry (if any) seen at [0–1] normalized screen-space pixel coordinates <code>screenPos_x</code> and <code>screenPos_y</code> use</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true"></a><span class="dt">void</span> ospPick(OSPPickResult *,</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true"></a>    OSPFrameBuffer,</span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true"></a>    OSPRenderer,</span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true"></a>    OSPCamera,</span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true"></a>    OSPWorld,</span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true"></a>    <span class="dt">float</span> screenPos_x,</span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true"></a>    <span class="dt">float</span> screenPos_y);</span></code></pre></div>
<p>The result is returned in the provided <code>OSPPickResult</code> struct:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true"></a><span class="kw">typedef</span> <span class="kw">struct</span> {</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true"></a>    <span class="dt">int</span> hasHit;</span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true"></a>    <span class="dt">float</span> worldPosition[<span class="dv">3</span>];</span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true"></a>    OSPInstance instance;</span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true"></a>    OSPGeometricModel model;</span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true"></a>    <span class="dt">uint32_t</span> primID;</span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true"></a>} OSPPickResult;</span></code></pre></div>
<p>Note that <code>ospPick</code> considers exactly the same camera of the given renderer that is used to render an image, thus matching results can be expected. If the camera supports depth of field then the center of the lens and thus the center of the circle of confusion is used for picking. Note that the caller needs to <code>ospRelease</code> the <code>instance</code> and <code>model</code> handles of <code>OSPPickResult</code> once the information is not needed anymore.</p>
<h2 id="framebuffer">Framebuffer</h2>
<p>The framebuffer holds the rendered 2D image (and optionally auxiliary information associated with pixels). To create a new framebuffer object of given size <code>size</code> (in pixels), color format, and channels use</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true"></a>OSPFrameBuffer ospNewFrameBuffer(<span class="dt">int</span> size_x, <span class="dt">int</span> size_y,</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true"></a>    OSPFrameBufferFormat format = OSP_FB_SRGBA,</span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true"></a>    <span class="dt">uint32_t</span> frameBufferChannels = OSP_FB_COLOR);</span></code></pre></div>
<p>The parameter <code>format</code> describes the format the color buffer has <em>on the host</em>, and the format that <code>ospMapFrameBuffer</code> will eventually return. Valid values are:</p>
<table>
<caption>Supported color formats of the framebuffer that can be passed to <code>ospNewFrameBuffer</code>, i.e., valid constants of type <code>OSPFrameBufferFormat</code>.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">OSP_FB_NONE</td>
<td style="text-align: left;">framebuffer will not be mapped by the application</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_FB_RGBA8</td>
<td style="text-align: left;">8 bit [0–255] linear component red, green, blue, alpha</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_FB_SRGBA</td>
<td style="text-align: left;">8 bit sRGB gamma encoded color components, and linear alpha</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_FB_RGBA32F</td>
<td style="text-align: left;">32 bit float components red, green, blue, alpha</td>
</tr>
</tbody>
</table>
<p>The parameter <code>frameBufferChannels</code> specifies which channels the framebuffer holds, and can be combined together by bitwise OR from the values of <code>OSPFrameBufferChannel</code> listed in the table below.</p>
<table>
<caption>Framebuffer channels constants (of type <code>OSPFrameBufferChannel</code>), naming optional information the framebuffer can store. These values can be combined by bitwise OR when passed to <code>ospNewFrameBuffer</code>.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">OSP_FB_COLOR</td>
<td style="text-align: left;">RGB color including alpha</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_FB_DEPTH</td>
<td style="text-align: left;">euclidean distance to the camera (<em>not</em> to the image plane), as linear 32 bit float; for multiple samples per pixel their minimum is taken</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_FB_ACCUM</td>
<td style="text-align: left;">accumulation buffer for progressive refinement</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_FB_VARIANCE</td>
<td style="text-align: left;">for estimation of the current noise level if OSP_FB_ACCUM is also present, see <a href="#rendering">rendering</a></td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_FB_NORMAL</td>
<td style="text-align: left;">accumulated world-space normal of the first hit, as vec3f</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_FB_ALBEDO</td>
<td style="text-align: left;">accumulated material albedo (color without illumination) at the first hit, as vec3f</td>
</tr>
</tbody>
</table>
<p>If a certain channel value is <em>not</em> specified, the given buffer channel will not be present. Note that OSPRay makes a clear distinction between the <em>external</em> format of the framebuffer and the internal one: The external format is the format the user specifies in the <code>format</code> parameter; it specifies what color format OSPRay will eventually <em>return</em> the framebuffer to the application (when calling <code>ospMapFrameBuffer</code>): no matter what OSPRay uses internally, it will simply return a 2D array of pixels of that format, with possibly all kinds of reformatting, compression/decompression, etc., going on in-between the generation of the <em>internal</em> framebuffer and the mapping of the externally visible one.</p>
<p>In particular, <code>OSP_FB_NONE</code> is a perfectly valid pixel format for a framebuffer that an application will never map. For example, an application driving a display wall may well generate an intermediate framebuffer and eventually transfer its pixel to the individual displays using an <code>OSPImageOperation</code> <a href="#image-operation">image operation</a>.</p>
<p>The application can map the given channel of a framebuffer – and thus access the stored pixel information – via</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true"></a><span class="at">const</span> <span class="dt">void</span> *ospMapFrameBuffer(OSPFrameBuffer, OSPFrameBufferChannel = OSP_FB_COLOR);</span></code></pre></div>
<p>Note that <code>OSP_FB_ACCUM</code> or <code>OSP_FB_VARIANCE</code> cannot be mapped. The origin of the screen coordinate system in OSPRay is the lower left corner (as in OpenGL), thus the first pixel addressed by the returned pointer is the lower left pixel of the image.</p>
<p>A previously mapped channel of a framebuffer can be unmapped by passing the received pointer <code>mapped</code> to</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true"></a><span class="dt">void</span> ospUnmapFrameBuffer(<span class="at">const</span> <span class="dt">void</span> *mapped, OSPFrameBuffer);</span></code></pre></div>
<p>The individual channels of a framebuffer can be cleared with</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true"></a><span class="dt">void</span> ospResetAccumulation(OSPFrameBuffer);</span></code></pre></div>
<p>This function will clear <em>all</em> accumulating buffers (<code>OSP_FB_VARIANCE</code>, <code>OSP_FB_NORMAL</code>, and <code>OSP_FB_ALBEDO</code>, if present) and resets the accumulation counter <code>accumID</code>. It is unspecified if the existing color and depth buffers are physically cleared when <code>ospResetAccumulation</code> is called.</p>
<p>If <code>OSP_FB_VARIANCE</code> is specified, an estimate of the variance of the last accumulated frame can be queried with</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true"></a><span class="dt">float</span> ospGetVariance(OSPFrameBuffer);</span></code></pre></div>
<p>Note this value is only updated after synchronizing with <code>OSP_FRAME_FINISHED</code>, as further described in <a href="#asynchronous-rendering">asynchronous rendering</a>. The estimated variance can be used by the application as a quality indicator and thus to decide whether to stop or to continue progressive rendering.</p>
<p>The framebuffer takes a list of pixel operations to be applied to the image in sequence as an <code>OSPData</code>. The pixel operations will be run in the order they are in the array.</p>
<table>
<caption>Parameters accepted by the framebuffer.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">OSPImageOperation[]</td>
<td style="text-align: left;">imageOperation</td>
<td style="text-align: left;">ordered sequence of image operations</td>
</tr>
</tbody>
</table>
<h3 id="image-operation">Image Operation</h3>
<p>Image operations are functions that are applied to every pixel of a frame. Examples include post-processing, filtering, blending, tone mapping, or sending tiles to a display wall. To create a new pixel operation of given type <code>type</code> use</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true"></a>OSPImageOperation ospNewImageOperation(<span class="at">const</span> <span class="dt">char</span> *type);</span></code></pre></div>
<h4 id="tone-mapper">Tone Mapper</h4>
<p>The tone mapper is a pixel operation which implements a generic filmic tone mapping operator. Using the default parameters it approximates the Academy Color Encoding System (ACES). The tone mapper is created by passing the type string “<code>tonemapper</code>” to <code>ospNewImageOperation</code>. The tone mapping curve can be customized using the parameters listed in the table below.</p>
<table style="width:97%;">
<caption>Parameters accepted by the tone mapper.</caption>
<colgroup>
<col style="width: 10%" />
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 54%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">exposure</td>
<td style="text-align: left;">1.0</td>
<td style="text-align: left;">amount of light per unit area</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">contrast</td>
<td style="text-align: left;">1.6773</td>
<td style="text-align: left;">contrast (toe of the curve); typically is in [1–2]</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">shoulder</td>
<td style="text-align: left;">0.9714</td>
<td style="text-align: left;">highlight compression (shoulder of the curve); typically is in [0.9–1]</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">midIn</td>
<td style="text-align: left;">0.18</td>
<td style="text-align: left;">mid-level anchor input; default is 18% gray</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">midOut</td>
<td style="text-align: left;">0.18</td>
<td style="text-align: left;">mid-level anchor output; default is 18% gray</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">hdrMax</td>
<td style="text-align: left;">11.0785</td>
<td style="text-align: left;">maximum HDR input that is not clipped</td>
</tr>
<tr class="odd">
<td style="text-align: left;">bool</td>
<td style="text-align: left;">acesColor</td>
<td style="text-align: left;">true</td>
<td style="text-align: left;">apply the ACES color transforms</td>
</tr>
</tbody>
</table>
<p>To use the popular “Uncharted 2” filmic tone mapping curve instead, set the parameters to the values listed in the table below.</p>
<table>
<caption>Filmic tone mapping curve parameters. Note that the curve includes an exposure bias to match 18% middle gray.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Value</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">contrast</td>
<td style="text-align: left;">1.1759</td>
</tr>
<tr class="even">
<td style="text-align: left;">shoulder</td>
<td style="text-align: left;">0.9746</td>
</tr>
<tr class="odd">
<td style="text-align: left;">midIn</td>
<td style="text-align: left;">0.18</td>
</tr>
<tr class="even">
<td style="text-align: left;">midOut</td>
<td style="text-align: left;">0.18</td>
</tr>
<tr class="odd">
<td style="text-align: left;">hdrMax</td>
<td style="text-align: left;">6.3704</td>
</tr>
<tr class="even">
<td style="text-align: left;">acesColor</td>
<td style="text-align: left;">false</td>
</tr>
</tbody>
</table>
<h4 id="denoiser">Denoiser</h4>
<p>OSPRay comes with a module that adds support for Intel® Open Image Denoise. This is provided as an optional module as it creates an additional project dependency at compile time. The module implements a “<code>denoiser</code>” frame operation, which denoises the entire frame before the frame is completed.</p>
<h2 id="rendering">Rendering</h2>
<h3 id="asynchronous-rendering">Asynchronous Rendering</h3>
<p>Rendering is by default asynchronous (non-blocking), and is done by combining a framebuffer, renderer, camera, and world.</p>
<p>What to render and how to render it depends on the renderer’s parameters. If the framebuffer supports accumulation (i.e., it was created with <code>OSP_FB_ACCUM</code>) then successive calls to <code>ospRenderFrame</code> will progressively refine the rendered image.</p>
<p>To start an render task, use</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true"></a>OSPFuture ospRenderFrame(OSPFrameBuffer, OSPRenderer, OSPCamera, OSPWorld);</span></code></pre></div>
<p>This returns an <code>OSPFuture</code> handle, which can be used to synchronize with the application, cancel, or query for progress of the running task. When <code>ospRenderFrame</code> is called, there is no guarantee when the associated task will begin execution.</p>
<p>Progress of a running frame can be queried with the following API function</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true"></a><span class="dt">float</span> ospGetProgress(OSPFuture);</span></code></pre></div>
<p>This returns the progress of the task in [0-1].</p>
<p>Applications can wait on the result of an asynchronous operation, or choose to only synchronize with a specific event. To synchronize with an <code>OSPFuture</code> use</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true"></a><span class="dt">void</span> ospWait(OSPFuture, OSPSyncEvent = OSP_TASK_FINISHED);</span></code></pre></div>
<p>The following are values which can be synchronized with the application</p>
<table style="width:97%;">
<caption>Supported events that can be passed to <code>ospWait</code>.</caption>
<colgroup>
<col style="width: 29%" />
<col style="width: 68%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">OSP_NONE_FINISHED</td>
<td style="text-align: left;">Do not wait for anything to be finished (immediately return from <code>ospWait</code>)</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_WORLD_COMMITTED</td>
<td style="text-align: left;">Wait for the world to be committed (not yet implemented)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_WORLD_RENDERED</td>
<td style="text-align: left;">Wait for the world to be rendered, but not post-processing operations (Pixel/Tile/Frame Op)</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_FRAME_FINISHED</td>
<td style="text-align: left;">Wait for all rendering operations to complete</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_TASK_FINISHED</td>
<td style="text-align: left;">Wait on full completion of the task associated with the future. The underlying task may involve one or more of the above synchronization events</td>
</tr>
</tbody>
</table>
<p>Currently only rendering can be invoked asynchronously. However, future releases of OSPRay may add more asynchronous versions of API calls (and thus return <code>OSPFuture</code>).</p>
<p>Applications can query whether particular events are complete with</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true"></a><span class="dt">int</span> ospIsReady(OSPFuture, OSPSyncEvent = OSP_TASK_FINISHED);</span></code></pre></div>
<p>As the given running task runs (as tracked by the <code>OSPFuture</code>), applications can query a boolean [0,1] result if the passed event has been completed.</p>
<p>Applications can query how long an async task ran with</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true"></a><span class="dt">float</span> ospGetTaskDuration(OSPFuture);</span></code></pre></div>
<p>This returns the wall clock execution time of the task in seconds. If the task is still running, this will block until the task is completed. This is useful for applications to query exactly how long an asynchronous task executed without the overhead of measuring both task execution + synchronization by the calling application.</p>
<h3 id="asynchronously-rendering-and-ospcommit">Asynchronously Rendering and ospCommit()</h3>
<p>The use of either <code>ospRenderFrame</code> or <code>ospRenderFrame</code> requires that all objects in the scene being rendered have been committed before rendering occurs. If a call to <code>ospCommit()</code> happens while a frame is rendered, the result is undefined behavior and should be avoided.</p>
<h3 id="synchronous-rendering">Synchronous Rendering</h3>
<p>For convenience in certain use cases, <code>ospray_util.h</code> provides a synchronous version of <code>ospRenderFrame</code>:</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true"></a><span class="dt">float</span> ospRenderFrameBlocking(OSPFrameBuffer, OSPRenderer, OSPCamera, OSPWorld);</span></code></pre></div>
<p>This version is the equivalent of:</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true"></a>ospRenderFrame</span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true"></a>ospWait(f, OSP_TASK_FINISHED)</span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true"></a><span class="cf">return</span> ospGetVariance(fb)</span></code></pre></div>
<p>This version is closest to <code>ospRenderFrame</code> from OSPRay v1.x.</p>
<h2 id="distributed-rendering-with-mpi">Distributed rendering with MPI</h2>
<p>The OSPRay MPI module is now a stand alone repository. It can be found on GitHub <a href="https://github.com/ospray/module_mpi">here</a>, where all code and documentation can be found.</p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>The number of items to be copied is defined by the size of the source array<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>For consecutive memory addresses the x-index of the corresponding voxel changes the quickest.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>actually a parallelogram<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p><code>OSPBounds</code> has essentially the same layout as the <code>OSP_BOX3F</code> <a href="documentation.html#data"><code>OSPDataType</code></a>.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p>If there are multiple ambient lights then their contribution is added<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6" role="doc-endnote"><p>respectively <span class="math inline">(127, 127, 255)</span> for 8 bit textures and <span class="math inline">(32767, 32767, 65535)</span> for 16 bit textures<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7" role="doc-endnote"><p>If <code>geometryLights</code> is enabled in the <a href="documentation.html#path-tracer">path tracer</a>.<a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

      </div>
    </div>

      <div id="footer">
        © 2013–2020 Intel Corporation <a href="legal.html">Disclaimer and Legal Information</a>
        <a href="https://www.intel.com/privacy">Privacy</a>
      </div>
  </body>
</html>
