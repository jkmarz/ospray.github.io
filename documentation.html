<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html" charset="utf-8">
    <title>OSPRay Documentation</title>
    <script type="text/javascript">
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-57290480-1', 'auto');
      ga('send', 'pageview');
    </script>
    <link rel="stylesheet" type="text/css" media="screen" href="stylesheet.css">
    <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
div.sourceCode { overflow-x: initial; }
    </style>
  </head>

  <body>
    <div id="header">
      <div id="header-github">
        <a id="forkme-banner" href="https://github.com/ospray/OSPRay">View on GitHub</a>
      </div>
      <div id="header-title">
        OSPRay
              <div id="header-subtitle">
        A Ray Tracing Based Rendering Engine for High-Fidelity Visualization
      </div>
      </div>

      <div id="header-navbar">
        <ul>
          <li><a href="index.html">Overview</a></li>
	  <li><a href="news.html">News</a></li>
	  <li><a href="demos.html">Demos</a></li>
	  <li id="selected"><a href="documentation.html">Documentation</a></li>
	  <li><a href="gallery.html">Gallery</a></li>
	  <li><a href="downloads.html">Downloads</a></li>
	  <li><a href="https://github.com/ospray/OSPRay/wiki">Wiki</a></li>
	  <li><a href="https://github.com/ospray/OSPRay/issues">Bugs/Issues</a></li>
	  <li><a href="related_projects.html">Related Projects</a></li>
	</ul>
      </div>
      <div id="header-spacing"></div>
    </div>

    <div id="content-wrap">
      <div id="content">

<h1 id="documentation">Documentation</h1>
<p>The following <a href="http://www.sdvis.org/ospray/download/OSPRay_readme.pdf" title="OSPRay Documentation">API documentation</a> of OSPRay can also be found as a <a href="http://www.sdvis.org/ospray/download/OSPRay_readme.pdf" title="OSPRay Documentation">pdf document</a> (2.1MB).</p>
<p>For a deeper explanation of the concepts, design, features and performance of OSPRay also have a look at the IEEE Vis 2016 paper “<a href="http://www.sdvis.org/ospray/download/talks/IEEEVis2016_OSPRay_paper.pdf">OSPRay – A CPU Ray Tracing Framework for Scientific Visualization</a>” (49MB, or get the <a href="http://www.sdvis.org/ospray/download/talks/IEEEVis2016_OSPRay_paper_small.pdf">smaller version</a> 1.8MB). Also available are the <a href="http://www.sdvis.org/ospray/download/talks/IEEEVis2016_OSPRay_talk.pdf">slides of the talk</a> (5.2MB).</p>
<h1 id="ospray-api">OSPRay API</h1>
<p>To access the OSPRay API you first need to include the OSPRay header</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&quot;ospray/ospray.h&quot;</span></code></pre></div>
<p>where the API is compatible with C99 and C++.</p>
<h2 id="initialization">Initialization</h2>
<p>In order to use the API, OSPRay must be initialized with a “device”. A device is the object which implements the API. Creating and initializing a device can be done in either of two ways: command line arguments or manually instantiating a device.</p>
<h3 id="command-line-arguments">Command Line Arguments</h3>
<p>The first is to do so by giving OSPRay the command line from <code>main()</code> by calling</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">OSPError ospInit(<span class="dt">int</span> *argc, <span class="at">const</span> <span class="dt">char</span> **argv);</code></pre></div>
<p>OSPRay parses (and removes) its known command line parameters from your application’s <code>main</code> function. For an example see the <a href="documentation.html#tutorial">tutorial</a>. For possible error codes see section <a href="#error-handling-and-status-messages">Error Handling and Status Messages</a>. It is important to note that the arguments passed to <code>ospInit()</code> are processed in order they are listed. The following parameters (which are prefixed by convention with “<code>--osp:</code>”) are understood:</p>
<table style="width:98%;">
<caption>Command line parameters accepted by OSPRay’s <code>ospInit</code>.</caption>
<colgroup>
<col width="31%" />
<col width="66%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Parameter</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>--osp:debug</code></td>
<td align="left">enables various extra checks and debug output, and disables multi-threading</td>
</tr>
<tr class="even">
<td align="left"><code>--osp:numthreads &lt;n&gt;</code></td>
<td align="left">use <code>n</code> threads instead of per default using all detected hardware threads</td>
</tr>
<tr class="odd">
<td align="left"><code>--osp:loglevel &lt;n&gt;</code></td>
<td align="left">set logging level, default <code>0</code>; increasing <code>n</code> means increasingly verbose log messages</td>
</tr>
<tr class="even">
<td align="left"><code>--osp:verbose</code></td>
<td align="left">shortcut for <code>--osp:loglevel 1</code></td>
</tr>
<tr class="odd">
<td align="left"><code>--osp:vv</code></td>
<td align="left">shortcut for <code>--osp:loglevel 2</code></td>
</tr>
<tr class="even">
<td align="left"><code>--osp:module:&lt;name&gt;</code></td>
<td align="left">load a module during initialization; equivalent to calling <code>ospLoadModule(name)</code></td>
</tr>
<tr class="odd">
<td align="left"><code>--osp:mpi</code></td>
<td align="left">enables MPI mode for parallel rendering with the <code>mpi_offload</code> device, to be used in conjunction with <code>mpirun</code>; this will automatically load the “mpi” module if it is not yet loaded or linked</td>
</tr>
<tr class="even">
<td align="left"><code>--osp:mpi-offload</code></td>
<td align="left">same as <code>--osp:mpi</code></td>
</tr>
<tr class="odd">
<td align="left"><code>--osp:mpi-distributed</code></td>
<td align="left">same as <code>--osp:mpi</code>, but will create an <code>mpi_distributed</code> device instead; Note that this will likely require application changes to work properly</td>
</tr>
<tr class="even">
<td align="left"><code>--osp:logoutput &lt;dst&gt;</code></td>
<td align="left">convenience for setting where error/status messages go; valid values for <code>dst</code> are <code>cerr</code> and <code>cout</code></td>
</tr>
<tr class="odd">
<td align="left"><code>--osp:device:&lt;name&gt;</code></td>
<td align="left">use <code>name</code> as the type of device for OSPRay to create; e.g. <code>--osp:device:default</code> gives you the default local device; Note if the device to be used is defined in a module, remember to pass <code>--osp:module:&lt;name&gt;</code> first</td>
</tr>
<tr class="even">
<td align="left"><code>--osp:setaffinity &lt;n&gt;</code></td>
<td align="left">if <code>1</code>, bind software threads to hardware threads; <code>0</code> disables binding; default is <code>1</code> on KNL and <code>0</code> otherwise</td>
</tr>
</tbody>
</table>
<h3 id="manual-device-instantiation">Manual Device Instantiation</h3>
<p>The second method of initialization is to explicitly create the device yourself, and possibly set parameters. This method looks almost identical to how other <a href="#objects">objects</a> are created and used by OSPRay (described in later sections). The first step is to create the device with</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">OSPDevice ospNewDevice(<span class="at">const</span> <span class="dt">char</span> *type);</code></pre></div>
<p>where the <code>type</code> string maps to a specific device implementation. OSPRay always provides the “<code>default</code>” device, which maps to a local CPU rendering device. If it is enabled in the build, you can also use “<code>mpi</code>” to access the MPI multi-node rendering device (see <a href="#parallel-rendering-with-mpi">Parallel Rendering with MPI</a> section for more information). Once a device is created, you can call</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> ospDeviceSet1i(OSPDevice, <span class="at">const</span> <span class="dt">char</span> *id, <span class="dt">int</span> val);</code></pre></div>
<p>or</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> ospDeviceSetString(OSPDevice, <span class="at">const</span> <span class="dt">char</span> *id, <span class="at">const</span> <span class="dt">char</span> *val);</code></pre></div>
<p>to set parameters on the device. The following parameters can be set on all devices:</p>
<table style="width:97%;">
<caption>Parameters shared by all devices.</caption>
<colgroup>
<col width="6%" />
<col width="16%" />
<col width="74%" />
</colgroup>
<thead>
<tr class="header">
<th>Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>int</td>
<td align="left">numThreads</td>
<td align="left">number of threads which OSPRay should use</td>
</tr>
<tr class="even">
<td>int</td>
<td align="left">logLevel</td>
<td align="left">logging level</td>
</tr>
<tr class="odd">
<td>int</td>
<td align="left">debug</td>
<td align="left">set debug mode; equivalent to logLevel=2 and numThreads=1</td>
</tr>
<tr class="even">
<td>int</td>
<td align="left">setAffinity</td>
<td align="left">bind software threads to hardware threads if set to 1; 0 disables binding omitting the parameter will let OSPRay choose</td>
</tr>
</tbody>
</table>
<p>Once parameters are set on the created device, the device must be committed with</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> ospDeviceCommit(OSPDevice);</code></pre></div>
<p>To use the newly committed device, you must call</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> ospSetCurrentDevice(OSPDevice);</code></pre></div>
<p>This then sets the given device as the object which will respond to all other OSPRay API calls.</p>
<p>Users can change parameters on the device after initialization (from either method above), by calling</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">OSPDevice ospGetCurrentDevice();</code></pre></div>
<p>This function returns the handle to the device currently used to respond to OSPRay API calls, where users can set/change parameters and recommit the device. If changes are made to the device that is already set as the current device, it does not need to be set as current again.</p>
<h3 id="environment-variables">Environment Variables</h3>
<p>Finally, OSPRay’s generic device parameters can be overridden via environment variables for easy changes to OSPRay’s behavior without needing to change the application (variables are prefixed by convention with “<code>OSPRAY_</code>”):</p>
<table>
<caption>Environment variables interpreted by OSPRay.</caption>
<thead>
<tr class="header">
<th align="left">Variable</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">OSPRAY_THREADS</td>
<td align="left">equivalent to <code>--osp:numthreads</code></td>
</tr>
<tr class="even">
<td align="left">OSPRAY_LOG_LEVEL</td>
<td align="left">equivalent to <code>--osp:loglevel</code></td>
</tr>
<tr class="odd">
<td align="left">OSPRAY_LOG_OUTPUT</td>
<td align="left">equivalent to <code>--osp:logoutput</code></td>
</tr>
<tr class="even">
<td align="left">OSPRAY_DEBUG</td>
<td align="left">equivalent to <code>--osp:debug</code></td>
</tr>
<tr class="odd">
<td align="left">OSPRAY_SET_AFFINITY</td>
<td align="left">equivalent to <code>--osp:setaffinity</code></td>
</tr>
</tbody>
</table>
<h3 id="error-handling-and-status-messages">Error Handling and Status Messages</h3>
<p>The following errors are currently used by OSPRay:</p>
<table>
<caption>Possible error codes, i.e. valid named constants of type <code>OSPError</code>.</caption>
<thead>
<tr class="header">
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">OSP_NO_ERROR</td>
<td align="left">no error occurred</td>
</tr>
<tr class="even">
<td align="left">OSP_UNKNOWN_ERROR</td>
<td align="left">an unknown error occurred</td>
</tr>
<tr class="odd">
<td align="left">OSP_INVALID_ARGUMENT</td>
<td align="left">an invalid argument was specified</td>
</tr>
<tr class="even">
<td align="left">OSP_INVALID_OPERATION</td>
<td align="left">the operation is not allowed for the specified object</td>
</tr>
<tr class="odd">
<td align="left">OSP_OUT_OF_MEMORY</td>
<td align="left">there is not enough memory to execute the command</td>
</tr>
<tr class="even">
<td align="left">OSP_UNSUPPORTED_CPU</td>
<td align="left">the CPU is not supported (minimum ISA is SSE4.1)</td>
</tr>
</tbody>
</table>
<p>These error codes are either directly return by some API functions, or are recorded to be later queried by the application via</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">OSPError ospDeviceGetLastErrorCode(OSPDevice);</code></pre></div>
<p>A more descriptive error message can be queried by calling</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="at">const</span> <span class="dt">char</span>* ospDeviceGetLastErrorMsg(OSPDevice);</code></pre></div>
<p>Alternatively, the application can also register a callback function of type</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">typedef</span> <span class="dt">void</span> (*OSPErrorFunc)(OSPError, <span class="at">const</span> <span class="dt">char</span>* errorDetails);</code></pre></div>
<p>via</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> ospDeviceSetErrorFunc(OSPDevice, OSPErrorFunc);</code></pre></div>
<p>to get notified when errors occur.</p>
<p>Applications may be interested in messages which OSPRay emits, whether for debugging or logging events. Applications can call</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> ospDeviceSetStatusFunc(OSPDevice, OSPStatusFunc);</code></pre></div>
<p>in order to register a callback function of type</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">typedef</span> <span class="dt">void</span> (*OSPStatusFunc)(<span class="at">const</span> <span class="dt">char</span>* messageText);</code></pre></div>
<p>which OSPRay will use to emit status messages. By default, OSPRay uses a callback which does nothing, so any output desired by an application will require that a callback is provided. Note that callbacks for C++ <code>std::cout</code> and <code>std::cerr</code> can be alternatively set through <code>ospInit()</code> or the <code>OSPRAY_LOG_OUTPUT</code> environment variable.</p>
<h3 id="loading-ospray-extensions-at-runtime">Loading OSPRay Extensions at Runtime</h3>
<p>OSPRay’s functionality can be extended via plugins, which are implemented in shared libraries. To load plugin <code>name</code> from <code>libospray_module_&lt;name&gt;.so</code> (on Linux and Mac OS X) or <code>ospray_module_&lt;name&gt;.dll</code> (on Windows) use</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">OSPError ospLoadModule(<span class="at">const</span> <span class="dt">char</span> *name);</code></pre></div>
<p>Modules are searched in OS-dependent paths, which include the application directory. <code>ospLoadModule</code> returns <code>OSP_NO_ERROR</code> if the plugin could be successfully loaded.</p>
<h2 id="objects">Objects</h2>
<p>All entities of OSPRay (the renderer, volumes, geometries, lights, cameras, …) are a specialization of <code>OSPObject</code> and share common mechanism to deal with parameters and lifetime.</p>
<p>An important aspect of object parameters is that parameters do not get passed to objects immediately. Instead, parameters are not visible at all to objects until they get explicitly committed to a given object via a call to</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> ospCommit(OSPObject);</code></pre></div>
<p>at which time all previously additions or changes to parameters are visible at the same time. If a user wants to change the state of an existing object (e.g., to change the origin of an already existing camera) it is perfectly valid to do so, as long as the changed parameters are recommitted.</p>
<p>The commit semantic allow for batching up multiple small changes, and specifies exactly when changes to objects will occur. This is important to ensure performance and consistency for devices crossing a PCI bus, or across a network. In our MPI implementation, for example, we can easily guarantee consistency among different nodes by MPI barrier’ing on every commit.</p>
<p>Note that OSPRay uses reference counting to manage the lifetime of all objects, so one cannot explicitly “delete” any object. Instead, to indicate that the application does not need and does not access the given object anymore, call</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> ospRelease(OSPObject);</code></pre></div>
<p>This decreases its reference count and if the count reaches <code>0</code> the object will automatically get deleted.</p>
<h3 id="parameters">Parameters</h3>
<p>Parameters allow to configure the behavior of and to pass data to objects. However, objects do <em>not</em> have an explicit interface for reasons of high flexibility and a more stable compile-time API. Instead, parameters are passed separately to objects in an arbitrary order, and unknown parameters will simply be ignored. The following functions allow adding various types of parameters with name <code>id</code> to a given object:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// add a C-string (zero-terminated char *) parameter</span>
<span class="dt">void</span> ospSetString(OSPObject, <span class="at">const</span> <span class="dt">char</span> *id, <span class="at">const</span> <span class="dt">char</span> *s);

<span class="co">// add an object handle parameter to another object</span>
<span class="dt">void</span> ospSetObject(OSPObject, <span class="at">const</span> <span class="dt">char</span> *id, OSPObject object);

<span class="co">// add an untyped pointer -- this will *ONLY* work in local rendering!</span>
<span class="dt">void</span> ospSetVoidPtr(OSPObject, <span class="at">const</span> <span class="dt">char</span> *id, <span class="dt">void</span> *v);

<span class="co">// add scalar and vector integer and float parameters</span>
<span class="dt">void</span> ospSetf  (OSPObject, <span class="at">const</span> <span class="dt">char</span> *id, <span class="dt">float</span> x);
<span class="dt">void</span> ospSet1f (OSPObject, <span class="at">const</span> <span class="dt">char</span> *id, <span class="dt">float</span> x);
<span class="dt">void</span> ospSet1i (OSPObject, <span class="at">const</span> <span class="dt">char</span> *id, <span class="dt">int32_t</span> x);
<span class="dt">void</span> ospSet2f (OSPObject, <span class="at">const</span> <span class="dt">char</span> *id, <span class="dt">float</span> x, <span class="dt">float</span> y);
<span class="dt">void</span> ospSet2fv(OSPObject, <span class="at">const</span> <span class="dt">char</span> *id, <span class="at">const</span> <span class="dt">float</span> *xy);
<span class="dt">void</span> ospSet2i (OSPObject, <span class="at">const</span> <span class="dt">char</span> *id, <span class="dt">int</span> x, <span class="dt">int</span> y);
<span class="dt">void</span> ospSet2iv(OSPObject, <span class="at">const</span> <span class="dt">char</span> *id, <span class="at">const</span> <span class="dt">int</span> *xy);
<span class="dt">void</span> ospSet3f (OSPObject, <span class="at">const</span> <span class="dt">char</span> *id, <span class="dt">float</span> x, <span class="dt">float</span> y, <span class="dt">float</span> z);
<span class="dt">void</span> ospSet3fv(OSPObject, <span class="at">const</span> <span class="dt">char</span> *id, <span class="at">const</span> <span class="dt">float</span> *xyz);
<span class="dt">void</span> ospSet3i (OSPObject, <span class="at">const</span> <span class="dt">char</span> *id, <span class="dt">int</span> x, <span class="dt">int</span> y, <span class="dt">int</span> z);
<span class="dt">void</span> ospSet3iv(OSPObject, <span class="at">const</span> <span class="dt">char</span> *id, <span class="at">const</span> <span class="dt">int</span> *xyz);
<span class="dt">void</span> ospSet4f (OSPObject, <span class="at">const</span> <span class="dt">char</span> *id, <span class="dt">float</span> x, <span class="dt">float</span> y, <span class="dt">float</span> z, <span class="dt">float</span> w);
<span class="dt">void</span> ospSet4fv(OSPObject, <span class="at">const</span> <span class="dt">char</span> *id, <span class="at">const</span> <span class="dt">float</span> *xyzw);

<span class="co">// additional functions to pass vector integer and float parameters in C++</span>
<span class="dt">void</span> ospSetVec2f(OSPObject, <span class="at">const</span> <span class="dt">char</span> *id, <span class="at">const</span> vec2f &amp;v);
<span class="dt">void</span> ospSetVec2i(OSPObject, <span class="at">const</span> <span class="dt">char</span> *id, <span class="at">const</span> vec2i &amp;v);
<span class="dt">void</span> ospSetVec3f(OSPObject, <span class="at">const</span> <span class="dt">char</span> *id, <span class="at">const</span> vec3f &amp;v);
<span class="dt">void</span> ospSetVec3i(OSPObject, <span class="at">const</span> <span class="dt">char</span> *id, <span class="at">const</span> vec3i &amp;v);
<span class="dt">void</span> ospSetVec4f(OSPObject, <span class="at">const</span> <span class="dt">char</span> *id, <span class="at">const</span> vec4f &amp;v);</code></pre></div>
<p>Users can also remove parameters that have been explicitly set via an ospSet call. Any parameters which have been removed will go back to their default value during the next commit unless a new parameter was set after the parameter was removed. The following API function removes the named parameter from the given object:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> ospRemoveParam(OSPObject, <span class="at">const</span> <span class="dt">char</span> *id);</code></pre></div>
<h3 id="data">Data</h3>
<p>There is also the possibility to aggregate many values of the same type into an array, which then itself can be used as a parameter to objects. To create such a new data buffer, holding <code>numItems</code> elements of the given type, from the initialization data pointed to by <code>source</code> and optional creation flags, use</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">OSPData ospNewData(<span class="dt">size_t</span> numItems,
                   OSPDataType,
                   <span class="at">const</span> <span class="dt">void</span> *source,
                   <span class="at">const</span> <span class="dt">uint32_t</span> dataCreationFlags = <span class="dv">0</span>);</code></pre></div>
<p>The call returns an <code>OSPData</code> handle to the created array. The flag <code>OSP_DATA_SHARED_BUFFER</code> indicates that the buffer can be shared with the application. In this case the calling program guarantees that the <code>source</code> pointer will remain valid for the duration that this data array is being used. The enum type <code>OSPDataType</code> describes the different data types that can be represented in OSPRay; valid constants are listed in the table below.</p>
<table>
<caption>Valid named constants for <code>OSPDataType</code>.</caption>
<thead>
<tr class="header">
<th align="left">Type/Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">OSP_DEVICE</td>
<td align="left">API device object reference</td>
</tr>
<tr class="even">
<td align="left">OSP_VOID_PTR</td>
<td align="left">void pointer</td>
</tr>
<tr class="odd">
<td align="left">OSP_DATA</td>
<td align="left">data reference</td>
</tr>
<tr class="even">
<td align="left">OSP_OBJECT</td>
<td align="left">generic object reference</td>
</tr>
<tr class="odd">
<td align="left">OSP_CAMERA</td>
<td align="left">camera object reference</td>
</tr>
<tr class="even">
<td align="left">OSP_FRAMEBUFFER</td>
<td align="left">framebuffer object reference</td>
</tr>
<tr class="odd">
<td align="left">OSP_LIGHT</td>
<td align="left">light object reference</td>
</tr>
<tr class="even">
<td align="left">OSP_MATERIAL</td>
<td align="left">material object reference</td>
</tr>
<tr class="odd">
<td align="left">OSP_TEXTURE</td>
<td align="left">texture object reference</td>
</tr>
<tr class="even">
<td align="left">OSP_RENDERER</td>
<td align="left">renderer object reference</td>
</tr>
<tr class="odd">
<td align="left">OSP_MODEL</td>
<td align="left">model object reference</td>
</tr>
<tr class="even">
<td align="left">OSP_GEOMETRY</td>
<td align="left">geometry object reference</td>
</tr>
<tr class="odd">
<td align="left">OSP_VOLUME</td>
<td align="left">volume object reference</td>
</tr>
<tr class="even">
<td align="left">OSP_TRANSFER_FUNCTION</td>
<td align="left">transfer function object reference</td>
</tr>
<tr class="odd">
<td align="left">OSP_PIXEL_OP</td>
<td align="left">pixel operation object reference</td>
</tr>
<tr class="even">
<td align="left">OSP_STRING</td>
<td align="left">C-style zero-terminated character string</td>
</tr>
<tr class="odd">
<td align="left">OSP_CHAR</td>
<td align="left">8 bit signed character scalar</td>
</tr>
<tr class="even">
<td align="left">OSP_UCHAR</td>
<td align="left">8 bit unsigned character scalar</td>
</tr>
<tr class="odd">
<td align="left">OSP_UCHAR[234]</td>
<td align="left">… and [234]-element vector</td>
</tr>
<tr class="even">
<td align="left">OSP_USHORT</td>
<td align="left">16 bit unsigned integer scalar</td>
</tr>
<tr class="odd">
<td align="left">OSP_INT</td>
<td align="left">32 bit signed integer scalar</td>
</tr>
<tr class="even">
<td align="left">OSP_INT[234]</td>
<td align="left">… and [234]-element vector</td>
</tr>
<tr class="odd">
<td align="left">OSP_UINT</td>
<td align="left">32 bit unsigned integer scalar</td>
</tr>
<tr class="even">
<td align="left">OSP_UINT[234]</td>
<td align="left">… and [234]-element vector</td>
</tr>
<tr class="odd">
<td align="left">OSP_LONG</td>
<td align="left">64 bit signed integer scalar</td>
</tr>
<tr class="even">
<td align="left">OSP_LONG[234]</td>
<td align="left">… and [234]-element vector</td>
</tr>
<tr class="odd">
<td align="left">OSP_ULONG</td>
<td align="left">64 bit unsigned integer scalar</td>
</tr>
<tr class="even">
<td align="left">OSP_ULONG[234]</td>
<td align="left">… and [234]-element vector</td>
</tr>
<tr class="odd">
<td align="left">OSP_FLOAT</td>
<td align="left">32 bit single precision floating point scalar</td>
</tr>
<tr class="even">
<td align="left">OSP_FLOAT[234]</td>
<td align="left">… and [234]-element vector</td>
</tr>
<tr class="odd">
<td align="left">OSP_FLOAT3A</td>
<td align="left">… and aligned 3-element vector</td>
</tr>
<tr class="even">
<td align="left">OSP_DOUBLE</td>
<td align="left">64 bit double precision floating point scalar</td>
</tr>
</tbody>
</table>
<p>To add a data array as parameter named <code>id</code> to another object call</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> ospSetData(OSPObject, <span class="at">const</span> <span class="dt">char</span> *id, OSPData);</code></pre></div>
<h2 id="volumes">Volumes</h2>
<p>Volumes are volumetric datasets with discretely sampled values in 3D space, typically a 3D scalar field. To create a new volume object of given type <code>type</code> use</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">OSPVolume ospNewVolume(<span class="at">const</span> <span class="dt">char</span> *type);</code></pre></div>
<p>The call returns <code>NULL</code> if that type of volume is not known by OSPRay, or else an <code>OSPVolume</code> handle.</p>
<h3 id="structured-volume">Structured Volume</h3>
<p>Structured volumes only need to store the values of the samples, because their addresses in memory can be easily computed from a 3D position. A common type of structured volumes are regular grids. OSPRay supports two variants that differ in how the volumetric data for the regular grids is specified.</p>
<p>The first variant shares the voxel data with the application. Such a volume type is created by passing the type string “<code>shared_structured_volume</code>” to <code>ospNewVolume</code>. The voxel data is laid out in memory in XYZ order and provided to the volume via a <a href="#data">data</a> buffer parameter named “<code>voxelData</code>”.</p>
<p>The second regular grid variant is optimized for rendering performance: data locality in memory is increased by arranging the voxel data in smaller blocks. This volume type is created by passing the type string “<code>block_bricked_volume</code>” to <code>ospNewVolume</code>. Because of this rearrangement of voxel data it cannot be shared the with the application anymore, but has to be transferred to OSPRay via</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">OSPError ospSetRegion(OSPVolume, <span class="dt">void</span> *source,
                      <span class="at">const</span> vec3i &amp;regionCoords,
                      <span class="at">const</span> vec3i &amp;regionSize);</code></pre></div>
<p>The voxel data pointed to by <code>source</code> is copied into the given volume starting at position <code>regionCoords</code>, must be of size <code>regionSize</code> and be placed in memory in XYZ order. Note that OSPRay distinguishes between volume data and volume parameters. This function must be called only after all volume parameters (in particular <code>dimensions</code> and <code>voxelType</code>, see below) have been set and <em>before</em> <code>ospCommit(volume)</code> is called. If necessary then memory for the volume is allocated on the first call to this function.</p>
<p>The common parameters understood by both structured volume variants are summarized in the table below. If <code>voxelRange</code> is not provided for a volume OSPRay will compute it based on the voxel data, which may result in slower data updates.</p>
<table style="width:98%;">
<caption>Parameters to configure a structured volume.</caption>
<colgroup>
<col width="8%" />
<col width="29%" />
<col width="16%" />
<col width="43%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="right">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">vec3i</td>
<td align="left">dimensions</td>
<td align="right"></td>
<td align="left">number of voxels in each dimension <span class="math inline">(<em>x</em>, <em>y</em>, <em>z</em>)</span></td>
</tr>
<tr class="even">
<td align="left">string</td>
<td align="left">voxelType</td>
<td align="right"></td>
<td align="left">data type of each voxel, currently supported are:</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left"></td>
<td align="right"></td>
<td align="left">“uchar” (8 bit unsigned integer)</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left"></td>
<td align="right"></td>
<td align="left">“short” (16 bit signed integer)</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left"></td>
<td align="right"></td>
<td align="left">“ushort” (16 bit unsigned integer)</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left"></td>
<td align="right"></td>
<td align="left">“float” (32 bit single precision floating point)</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left"></td>
<td align="right"></td>
<td align="left">“double” (64 bit double precision floating point)</td>
</tr>
<tr class="even">
<td align="left">vec2f</td>
<td align="left">voxelRange</td>
<td align="right"></td>
<td align="left">minimum and maximum of the scalar values</td>
</tr>
<tr class="odd">
<td align="left">vec3f</td>
<td align="left">gridOrigin</td>
<td align="right"><span class="math inline">(0, 0, 0)</span></td>
<td align="left">origin of the grid in world-space</td>
</tr>
<tr class="even">
<td align="left">vec3f</td>
<td align="left">gridSpacing</td>
<td align="right"><span class="math inline">(1, 1, 1)</span></td>
<td align="left">size of the grid cells in world-space</td>
</tr>
<tr class="odd">
<td align="left">bool</td>
<td align="left">gradientShadingEnabled</td>
<td align="right">false</td>
<td align="left">volume is rendered with surface shading wrt. to normalized gradient</td>
</tr>
<tr class="even">
<td align="left">bool</td>
<td align="left">preIntegration</td>
<td align="right">false</td>
<td align="left">use pre-integration for <a href="#transfer-function">transfer function</a> lookups</td>
</tr>
<tr class="odd">
<td align="left">bool</td>
<td align="left">singleShade</td>
<td align="right">true</td>
<td align="left">shade only at the point of maximum intensity</td>
</tr>
<tr class="even">
<td align="left">bool</td>
<td align="left">adaptiveSampling</td>
<td align="right">true</td>
<td align="left">adapt ray step size based on opacity</td>
</tr>
<tr class="odd">
<td align="left">float</td>
<td align="left">adaptiveScalar</td>
<td align="right">15</td>
<td align="left">modifier for adaptive step size</td>
</tr>
<tr class="even">
<td align="left">float</td>
<td align="left">adaptiveMaxSamplingRate</td>
<td align="right">2</td>
<td align="left">maximum sampling rate for adaptive sampling</td>
</tr>
<tr class="odd">
<td align="left">float</td>
<td align="left">samplingRate</td>
<td align="right">0.125</td>
<td align="left">sampling rate of the volume (this is the minimum step size for adaptive sampling)</td>
</tr>
<tr class="even">
<td align="left">vec3f</td>
<td align="left">specular</td>
<td align="right">gray 0.3</td>
<td align="left">specular color for shading</td>
</tr>
<tr class="odd">
<td align="left">vec3f</td>
<td align="left">volumeClippingBoxLower</td>
<td align="right">disabled</td>
<td align="left">lower coordinate (in object-space) to clip the volume values</td>
</tr>
<tr class="even">
<td align="left">vec3f</td>
<td align="left">volumeClippingBoxUpper</td>
<td align="right">disabled</td>
<td align="left">upper coordinate (in object-space) to clip the volume values</td>
</tr>
</tbody>
</table>
<h3 id="transfer-function">Transfer Function</h3>
<p>Transfer functions map the scalar values of volumes to color and opacity and thus they can be used to visually emphasize certain features of the volume. To create a new transfer function of given type <code>type</code> use</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">OSPTransferFunction ospNewTransferFunction(<span class="at">const</span> <span class="dt">char</span> *type);</code></pre></div>
<p>The call returns <code>NULL</code> if that type of transfer functions is not known by OSPRay, or else an <code>OSPTransferFunction</code> handle to the created transfer function. That handle can be assigned to a volume as parameter “<code>transferFunction</code>” using <code>ospSetObject</code>.</p>
<p>One type of transfer function that is built-in in OSPRay is the linear transfer function, which interpolates between given equidistant colors and opacities. It is create by passing the string “<code>piecewise_linear</code>” to <code>ospNewTransferFunction</code> and it is controlled by these parameters:</p>
<table>
<caption>Parameters accepted by the linear transfer function.</caption>
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">vec3f[]</td>
<td align="left">colors</td>
<td align="left"><a href="#data">data</a> array of RGB colors</td>
</tr>
<tr class="even">
<td align="left">float[]</td>
<td align="left">opacities</td>
<td align="left"><a href="#data">data</a> array of opacities</td>
</tr>
<tr class="odd">
<td align="left">vec2f</td>
<td align="left">valueRange</td>
<td align="left">domain (scalar range) this function maps from</td>
</tr>
</tbody>
</table>
<h2 id="geometries">Geometries</h2>
<p>Geometries in OSPRay are objects that describe surfaces. To create a new geometry object of given type <code>type</code> use</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">OSPGeometry ospNewGeometry(<span class="at">const</span> <span class="dt">char</span> *type);</code></pre></div>
<p>The call returns <code>NULL</code> if that type of geometry is not known by OSPRay, or else an <code>OSPGeometry</code> handle.</p>
<h3 id="triangle-mesh">Triangle Mesh</h3>
<p>A traditional triangle mesh (indexed face set) geometry is created by calling <code>ospNewGeometry</code> with type string “<code>triangles</code>”. Once created, a triangle mesh recognizes the following parameters:</p>
<table>
<caption>Parameters defining a triangle mesh geometry.</caption>
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">vec3f(a)[]</td>
<td align="left">vertex</td>
<td align="left"><a href="#data">data</a> array of vertex positions</td>
</tr>
<tr class="even">
<td align="left">vec3f(a)[]</td>
<td align="left">vertex.normal</td>
<td align="left"><a href="#data">data</a> array of vertex normals</td>
</tr>
<tr class="odd">
<td align="left">vec4f[] / vec3fa[]</td>
<td align="left">vertex.color</td>
<td align="left"><a href="#data">data</a> array of vertex colors (RGBA/RGB)</td>
</tr>
<tr class="even">
<td align="left">vec2f[]</td>
<td align="left">vertex.texcoord</td>
<td align="left"><a href="#data">data</a> array of vertex texture coordinates</td>
</tr>
<tr class="odd">
<td align="left">vec3i(a)[]</td>
<td align="left">index</td>
<td align="left"><a href="#data">data</a> array of triangle indices (into vertex.*)</td>
</tr>
</tbody>
</table>
<h3 id="spheres">Spheres</h3>
<p>A geometry consisting of individual spheres, each of which can have an own radius, is created by calling <code>ospNewGeometry</code> with type string “<code>spheres</code>”. The spheres will not be tessellated but rendered procedurally and are thus perfectly round. To allow a variety of sphere representations in the application this geometry allows a flexible way of specifying the data of center position and radius within a <a href="#data">data</a> array:</p>
<table style="width:98%;">
<caption>Parameters defining a spheres geometry.</caption>
<colgroup>
<col width="13%" />
<col width="22%" />
<col width="12%" />
<col width="48%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="right">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">float</td>
<td align="left">radius</td>
<td align="right">0.01</td>
<td align="left">radius of all spheres (if <code>offset_radius</code> is not used)</td>
</tr>
<tr class="even">
<td align="left">OSPData</td>
<td align="left">spheres</td>
<td align="right">NULL</td>
<td align="left">memory holding the spatial <a href="#data">data</a> of all spheres</td>
</tr>
<tr class="odd">
<td align="left">int</td>
<td align="left">bytes_per_sphere</td>
<td align="right">16</td>
<td align="left">size (in bytes) of each sphere within the <code>spheres</code> array</td>
</tr>
<tr class="even">
<td align="left">int</td>
<td align="left">offset_center</td>
<td align="right">0</td>
<td align="left">offset (in bytes) of each sphere’s “vec3f center” position (in object-space) within the <code>spheres</code> array</td>
</tr>
<tr class="odd">
<td align="left">int</td>
<td align="left">offset_radius</td>
<td align="right">-1</td>
<td align="left">offset (in bytes) of each sphere’s “float radius” within the <code>spheres</code> array (<code>-1</code> means disabled and use <code>radius</code>)</td>
</tr>
<tr class="even">
<td align="left">vec4f[] / vec3f(a)[]</td>
<td align="left">color</td>
<td align="right">NULL</td>
<td align="left"><a href="#data">data</a> array of colors (RGBA/RGB), color is constant for each sphere</td>
</tr>
<tr class="odd">
<td align="left">vec2f[]</td>
<td align="left">texcoord</td>
<td align="right">NULL</td>
<td align="left"><a href="#data">data</a> array of texture coordinates, coordinate is constant for each sphere</td>
</tr>
</tbody>
</table>
<h3 id="cylinders">Cylinders</h3>
<p>A geometry consisting of individual cylinders, each of which can have an own radius, is created by calling <code>ospNewGeometry</code> with type string “<code>cylinders</code>”. The cylinders will not be tessellated but rendered procedurally and are thus perfectly round. To allow a variety of cylinder representations in the application this geometry allows a flexible way of specifying the data of offsets for start position, end position and radius within a <a href="#data">data</a> array. All parameters are listed in the table below.</p>
<table style="width:98%;">
<caption>Parameters defining a cylinders geometry.</caption>
<colgroup>
<col width="13%" />
<col width="25%" />
<col width="12%" />
<col width="46%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="right">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">float</td>
<td align="left">radius</td>
<td align="right">0.01</td>
<td align="left">radius of all cylinders (if <code>offset_radius</code> is not used)</td>
</tr>
<tr class="even">
<td align="left">OSPData</td>
<td align="left">cylinders</td>
<td align="right">NULL</td>
<td align="left">memory holding the spatial <a href="#data">data</a> of all cylinders</td>
</tr>
<tr class="odd">
<td align="left">int</td>
<td align="left">bytes_per_cylinder</td>
<td align="right">24</td>
<td align="left">size (in bytes) of each cylinder within the <code>cylinders</code> array</td>
</tr>
<tr class="even">
<td align="left">int</td>
<td align="left">offset_v0</td>
<td align="right">0</td>
<td align="left">offset (in bytes) of each cylinder’s “vec3f v0” position (the start vertex, in object-space) within the <code>cylinders</code> array</td>
</tr>
<tr class="odd">
<td align="left">int</td>
<td align="left">offset_v1</td>
<td align="right">12</td>
<td align="left">offset (in bytes) of each cylinder’s “vec3f v1” position (the end vertex, in object-space) within the <code>cylinders</code> array</td>
</tr>
<tr class="even">
<td align="left">int</td>
<td align="left">offset_radius</td>
<td align="right">-1</td>
<td align="left">offset (in bytes) of each cylinder’s “float radius” within the <code>cylinders</code> array (<code>-1</code> means disabled and use <code>radius</code> instead)</td>
</tr>
<tr class="odd">
<td align="left">vec4f[] / vec3f(a)[]</td>
<td align="left">color</td>
<td align="right">NULL</td>
<td align="left"><a href="#data">data</a> array of colors (RGBA/RGB), color is constant for each cylinder</td>
</tr>
<tr class="even">
<td align="left">OSPData</td>
<td align="left">texcoord</td>
<td align="right">NULL</td>
<td align="left"><a href="#data">data</a> array of texture coordinates, in pairs (each a vec2f at vertex v0 and v1)</td>
</tr>
</tbody>
</table>
<p>For texturing each cylinder is seen as a 1D primitive, i.e. a line segment: the 2D texture coordinates at its vertices v0 and v1 are linearly interpolated.</p>
<h3 id="streamlines">Streamlines</h3>
<p>A geometry consisting of multiple stream lines of constant radius is created by calling <code>ospNewGeometry</code> with type string “<code>streamlines</code>”. The stream lines are internally assembled from connected (and rounded) cylinder segments and are thus perfectly round. The parameters defining this geometry are listed in the table below.</p>
<table>
<caption>Parameters defining a streamlines geometry.</caption>
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">float</td>
<td align="left">radius</td>
<td align="left">radius of all stream lines, default 0.01</td>
</tr>
<tr class="even">
<td align="left">vec3fa[]</td>
<td align="left">vertex</td>
<td align="left"><a href="#data">data</a> array of all vertices for <em>all</em> stream lines</td>
</tr>
<tr class="odd">
<td align="left">vec4f[]</td>
<td align="left">vertex.color</td>
<td align="left"><a href="#data">data</a> array of corresponding vertex colors (RGBA)</td>
</tr>
<tr class="even">
<td align="left">int32[]</td>
<td align="left">index</td>
<td align="left"><a href="#data">data</a> array of indices to the first vertex of a link</td>
</tr>
</tbody>
</table>
<p>Each stream line is specified by a set of (aligned) vec3fa control points in <code>vertex</code>; all vertices belonging to to the same logical stream line are connected via <a href="#cylinders">cylinders</a> of a fixed radius <code>radius</code>, with additional <a href="#spheres">spheres</a> at each vertex to make for a smooth transition between the cylinders.</p>
<p>A streamlines geometry can contain multiple disjoint stream lines, each streamline is specified as a list of linear segments (or links) referenced via <code>index</code>: each entry <code>e</code> of the <code>index</code> array points the first vertex of a link (<code>vertex[index[e]]</code>) and the second vertex of the link is implicitly the directly following one (<code>vertex[index[e]+1]</code>). For example, two stream lines of vertices <code>(A-B-C-D)</code> and <code>(E-F-G)</code>, respectively, would internally correspond to five links (<code>A-B</code>, <code>B-C</code>, <code>C-D</code>, <code>E-F</code>, and <code>F-G</code>), and would be specified via an array of vertices <code>[A,B,C,D,E,F,G]</code>, plus an array of link indices <code>[0,1,2,4,5]</code>.</p>
<h3 id="isosurfaces">Isosurfaces</h3>
<p>OSPRay can directly render multiple isosurfaces of a volume without first tessellating them. To do so create an isosurfaces geometry by calling <code>ospNewGeometry</code> with type string “<code>isosurfaces</code>”. Each isosurface will be colored according to the provided volume’s <a href="#transfer-function">transfer function</a>.</p>
<table>
<caption>Parameters defining an isosurfaces geometry.</caption>
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">float[]</td>
<td align="left">isovalues</td>
<td align="left"><a href="#data">data</a> array of isovalues</td>
</tr>
<tr class="even">
<td align="left">OSPVolume</td>
<td align="left">volume</td>
<td align="left">handle of the <a href="documentation.html#volumes">volume</a> to be isosurfaced</td>
</tr>
</tbody>
</table>
<h3 id="slices">Slices</h3>
<p>One tool to highlight interesting features of volumetric data is to visualize 2D cuts (or slices) by placing planes into the volume. Such a slices geometry is created by calling <code>ospNewGeometry</code> with type string “<code>slices</code>”. The planes are defined by the coefficients <span class="math inline">(<em>a</em>, <em>b</em>, <em>c</em>, <em>d</em>)</span> of the plane equation <span class="math inline"><em>a</em><em>x</em> + <em>b</em><em>y</em> + <em>c</em><em>z</em> + <em>d</em> = 0</span>. Each slice is colored according to the provided volume’s <a href="#transfer-function">transfer function</a>.</p>
<table>
<caption>Parameters defining a slices geometry.</caption>
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">vec4f[]</td>
<td align="left">planes</td>
<td align="left"><a href="#data">data</a> array with plane coefficients for all slices</td>
</tr>
<tr class="even">
<td align="left">OSPVolume</td>
<td align="left">volume</td>
<td align="left">handle of the <a href="documentation.html#volumes">volume</a> that will be sliced</td>
</tr>
</tbody>
</table>
<h3 id="instances">Instances</h3>
<p>OSPRay supports instancing via a special type of geometry. Instances are created by transforming another given <a href="#model">model</a> <code>modelToInstantiate</code> with the given affine transformation <code>transform</code> by calling</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">OSPGeometry ospNewInstance(OSPModel modelToInstantiate, <span class="at">const</span> affine3f &amp;transform);</code></pre></div>
<h2 id="renderer">Renderer</h2>
<p>A renderer is the central object for rendering in OSPRay. Different renderers implement different features and support different materials. To create a new renderer of given type <code>type</code> use</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">OSPRenderer ospNewRenderer(<span class="at">const</span> <span class="dt">char</span> *type);</code></pre></div>
<p>The call returns <code>NULL</code> if that type of renderer is not known, or else an <code>OSPRenderer</code> handle to the created renderer. General parameters of all renderers are</p>
<table>
<caption>Parameters understood by all renderers.</caption>
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">OSPModel</td>
<td align="left">model</td>
<td align="left">the <a href="#model">model</a> to render</td>
</tr>
<tr class="even">
<td align="left">OSPCamera</td>
<td align="left">camera</td>
<td align="left">the <a href="documentation.html#cameras">camera</a> to be used for rendering</td>
</tr>
<tr class="odd">
<td align="left">OSPLight[]</td>
<td align="left">lights</td>
<td align="left"><a href="#data">data</a> array with handles of the <a href="#lights">lights</a></td>
</tr>
<tr class="even">
<td align="left">float</td>
<td align="left">epsilon</td>
<td align="left">ray epsilon to avoid self-intersections, relative to scene diameter, default 10<sup>-6</sup></td>
</tr>
<tr class="odd">
<td align="left">int</td>
<td align="left">spp</td>
<td align="left">samples per pixel, default 1</td>
</tr>
<tr class="even">
<td align="left">int</td>
<td align="left">maxDepth</td>
<td align="left">maximum ray recursion depth</td>
</tr>
<tr class="odd">
<td align="left">float</td>
<td align="left">varianceThreshold</td>
<td align="left">threshold for adaptive accumulation</td>
</tr>
</tbody>
</table>
<p>OSPRay’s renderers support a feature called adaptive accumulation, which accelerates progressive <a href="#rendering">rendering</a> by stopping the rendering and refinement of image regions that have an estimated variance below the <code>varianceThreshold</code>. This feature requires a <a href="#framebuffer">framebuffer</a> with an <code>OSP_FB_VARIANCE</code> channel.</p>
<h3 id="scivis-renderer">SciVis Renderer</h3>
<p>The SciVis renderer is a fast ray tracer for scientific visualization which supports volume rendering and ambient occlusion (AO). It is created by passing the type string “<code>scivis</code>” or “<code>raytracer</code>” to <code>ospNewRenderer</code>. In addition to the <a href="#renderer">general parameters</a> understood by all renderers the SciVis renderer supports the following special parameters:</p>
<table style="width:98%;">
<caption>Special parameters understood by the SciVis renderer.</caption>
<colgroup>
<col width="17%" />
<col width="28%" />
<col width="17%" />
<col width="34%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="right">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">bool</td>
<td align="left">shadowsEnabled</td>
<td align="right">false</td>
<td align="left">whether to compute (hard) shadows</td>
</tr>
<tr class="even">
<td align="left">int</td>
<td align="left">aoSamples</td>
<td align="right">0</td>
<td align="left">number of rays per sample to compute ambient occlusion</td>
</tr>
<tr class="odd">
<td align="left">float</td>
<td align="left">aoDistance</td>
<td align="right">10<sup>20</sup></td>
<td align="left">maximum distance to consider for ambient occlusion</td>
</tr>
<tr class="even">
<td align="left">bool</td>
<td align="left">aoTransparencyEnabled</td>
<td align="right">false</td>
<td align="left">whether object transparency is respected when computing ambient occlusion (slower)</td>
</tr>
<tr class="odd">
<td align="left">bool</td>
<td align="left">oneSidedLighting</td>
<td align="right">true</td>
<td align="left">if true back-facing surfaces (wrt. light source) receive no illumination</td>
</tr>
<tr class="even">
<td align="left">float / vec3f / vec4f</td>
<td align="left">bgColor</td>
<td align="right">black, transparent</td>
<td align="left">background color and alpha (RGBA)</td>
</tr>
<tr class="odd">
<td align="left">OSPTexture2D</td>
<td align="left">maxDepthTexture</td>
<td align="right">NULL</td>
<td align="left">screen-sized float <a href="#texture">texture</a> with maximum far distance per pixel</td>
</tr>
</tbody>
</table>
<p>Note that the intensity (and color) of AO is controlled via an <a href="#ambient-light">ambient light</a>. If <code>aoSamples</code> is zero (the default) then ambient lights cause ambient illumination (without occlusion).</p>
<p>Per default the background of the rendered image will be transparent black, i.e. the alpha channel holds the opacity of the rendered objects. This facilitates transparency-aware blending of the image with an arbitrary background image by the application. The parameter <code>bgColor</code> can be used to already blend with a constant background color (and alpha) during rendering.</p>
<p>The SciVis renderer supports depth composition with images of other renderers, for example to incorporate help geometries of a 3D UI that were rendered with OpenGL. The screen-sized <a href="#texture">texture</a> <code>maxDepthTexture</code> must have format <code>OSP_TEXTURE_R32F</code> and flag <code>OSP_TEXTURE_FILTER_NEAREST</code>. The fetched values are used to limit the distance of primary rays, thus objects of other renderers can hide objects rendered by OSPRay.</p>
<h3 id="path-tracer">Path Tracer</h3>
<p>The path tracer supports soft shadows, indirect illumination and realistic materials. In addition to the <a href="#renderer">general parameters</a> understood by all renderers the path tracer supports the following special parameters:</p>
<table style="width:98%;">
<caption>Special parameters understood by the path tracer.</caption>
<colgroup>
<col width="17%" />
<col width="21%" />
<col width="12%" />
<col width="46%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="right">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">float</td>
<td align="left">minContribution</td>
<td align="right">0.01</td>
<td align="left">sample contributions below this value will be neglected to speed-up rendering</td>
</tr>
<tr class="even">
<td align="left">float</td>
<td align="left">maxContribution</td>
<td align="right">∞</td>
<td align="left">samples are clamped to this value before they are accumulated into the framebuffer</td>
</tr>
<tr class="odd">
<td align="left">OSPTexture2D</td>
<td align="left">backplate</td>
<td align="right">NULL</td>
<td align="left"><a href="#texture">texture</a> image used as background, replacing visible lights in infinity (e.g. the <a href="#hdri-light">HDRI light</a>)</td>
</tr>
</tbody>
</table>
<h3 id="model">Model</h3>
<p>Models are a container of scene data. They can hold the different <a href="#geometries">geometries</a> and <a href="#volumes">volumes</a> as well as references to (and <a href="#instances">instances</a> of) other models. A model is associated with a single logical acceleration structure. To create an (empty) model call</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">OSPModel ospNewModel();</code></pre></div>
<p>The call returns an <code>OSPModel</code> handle to the created model. To add an already created geometry or volume to a model use</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> ospAddGeometry(OSPModel, OSPGeometry);
<span class="dt">void</span> ospAddVolume(OSPModel, OSPVolume);</code></pre></div>
<p>An existing geometry or volume can be removed from a model with</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> ospRemoveGeometry(OSPModel, OSPGeometry);
<span class="dt">void</span> ospRemoveVolume(OSPModel, OSPVolume);</code></pre></div>
<h3 id="lights">Lights</h3>
<p>To let the given <code>renderer</code> create a new light source of given type <code>type</code> use</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">OSPLight ospNewLight(OSPRenderer renderer, <span class="at">const</span> <span class="dt">char</span> *type);</code></pre></div>
<p>The call returns <code>NULL</code> if that type of camera is not known by the renderer, or else an <code>OSPLight</code> handle to the created light source. All light sources<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> accept the following parameters:</p>
<table>
<caption>Parameters accepted by the all lights.</caption>
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="right">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">vec3f(a)</td>
<td align="left">color</td>
<td align="right">white</td>
<td align="left">color of the light</td>
</tr>
<tr class="even">
<td align="left">float</td>
<td align="left">intensity</td>
<td align="right">1</td>
<td align="left">intensity of the light (a factor)</td>
</tr>
<tr class="odd">
<td align="left">bool</td>
<td align="left">isVisible</td>
<td align="right">true</td>
<td align="left">whether the light can be directly seen</td>
</tr>
</tbody>
</table>
<p>The following light types are supported by most OSPRay renderers.</p>
<h4 id="directional-light-distant-light">Directional Light / Distant Light</h4>
<p>The distant light (or traditionally the directional light) is thought to be very far away (outside of the scene), thus its light arrives (almost) as parallel rays. It is created by passing the type string “<code>distant</code>” to <code>ospNewLight</code>. In addition to the <a href="#lights">general parameters</a> understood by all lights the distant light supports the following special parameters:</p>
<table>
<caption>Special parameters accepted by the distant light.</caption>
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">vec3f(a)</td>
<td align="left">direction</td>
<td align="left">main emission direction of the distant light</td>
</tr>
<tr class="even">
<td align="left">float</td>
<td align="left">angularDiameter</td>
<td align="left">apparent size (angle in degree) of the light</td>
</tr>
</tbody>
</table>
<p>Setting the angular diameter to a value greater than zero will result in soft shadows when the renderer uses stochastic sampling (like the <a href="documentation.html#path-tracer">path tracer</a>). For instance, the apparent size of the sun is about 0.53°.</p>
<h4 id="point-light-sphere-light">Point Light / Sphere Light</h4>
<p>The sphere light (or the special case point light) is a light emitting uniformly in all directions. It is created by passing the type string “<code>sphere</code>” to <code>ospNewLight</code>. In addition to the <a href="#lights">general parameters</a> understood by all lights the sphere light supports the following special parameters:</p>
<table>
<caption>Special parameters accepted by the sphere light.</caption>
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">vec3f(a)</td>
<td align="left">position</td>
<td align="left">the center of the sphere light, in world-space</td>
</tr>
<tr class="even">
<td align="left">float</td>
<td align="left">radius</td>
<td align="left">the size of the sphere light</td>
</tr>
</tbody>
</table>
<p>Setting the radius to a value greater than zero will result in soft shadows when the renderer uses stochastic sampling (like the <a href="documentation.html#path-tracer">path tracer</a>).</p>
<h4 id="spot-light">Spot Light</h4>
<p>The spot light is a light emitting into a cone of directions. It is created by passing the type string “<code>spot</code>” to <code>ospNewLight</code>. In addition to the <a href="#lights">general parameters</a> understood by all lights the spot light supports the special parameters listed in the table.</p>
<table style="width:96%;">
<caption>Special parameters accepted by the spot light.</caption>
<colgroup>
<col width="12%" />
<col width="19%" />
<col width="63%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">vec3f(a)</td>
<td align="left">position</td>
<td align="left">the center of the spot light, in world-space</td>
</tr>
<tr class="even">
<td align="left">vec3f(a)</td>
<td align="left">direction</td>
<td align="left">main emission direction of the spot</td>
</tr>
<tr class="odd">
<td align="left">float</td>
<td align="left">openingAngle</td>
<td align="left">full opening angle (in degree) of the spot; outside of this cone is no illumination</td>
</tr>
<tr class="even">
<td align="left">float</td>
<td align="left">penumbraAngle</td>
<td align="left">size (angle in degree) of the “penumbra”, the region between the rim (of the illumination cone) and full intensity of the spot; should be smaller than half of <code>openingAngle</code></td>
</tr>
<tr class="odd">
<td align="left">float</td>
<td align="left">radius</td>
<td align="left">the size of the spot light, the radius of a disk with normal <code>direction</code></td>
</tr>
</tbody>
</table>
<div class="figure">
<img src="images/spot_light.png" alt="Angles used by SpotLight." />
<p class="caption">Angles used by SpotLight.</p>
</div>
<p>Setting the radius to a value greater than zero will result in soft shadows when the renderer uses stochastic sampling (like the <a href="documentation.html#path-tracer">path tracer</a>).</p>
<h4 id="quad-light">Quad Light</h4>
<p>The quad<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> light is a planar, procedural area light source emitting uniformly on one side into the half space. It is created by passing the type string “<code>quad</code>” to <code>ospNewLight</code>. In addition to the <a href="#lights">general parameters</a> understood by all lights the spot light supports the following special parameters:</p>
<table>
<caption>Special parameters accepted by the quad light.</caption>
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">vec3f(a)</td>
<td align="left">position</td>
<td align="left">world-space position of one vertex of the quad light</td>
</tr>
<tr class="even">
<td align="left">vec3f(a)</td>
<td align="left">edge1</td>
<td align="left">vector to one adjacent vertex</td>
</tr>
<tr class="odd">
<td align="left">vec3f(a)</td>
<td align="left">edge2</td>
<td align="left">vector to the other adjacent vertex</td>
</tr>
</tbody>
</table>
<div class="figure">
<img src="images/quad_light.png" alt="Defining a Quad Light." />
<p class="caption">Defining a Quad Light.</p>
</div>
<p>The emission side is determined by the cross product of <code>edge1</code>×<code>edge2</code>. Note that only renderers that use stochastic sampling (like the path tracer) will compute soft shadows from the quad light. Other renderers will just sample the center of the quad light, which results in hard shadows.</p>
<h4 id="hdri-light">HDRI Light</h4>
<p>The HDRI light is a textured light source surrounding the scene and illuminating it from infinity. It is created by passing the type string “<code>hdri</code>” to <code>ospNewLight</code>. In addition to the <a href="#lights">parameter <code>intensity</code></a> the HDRI light supports the following special parameters:</p>
<table style="width:96%;">
<caption>Special parameters accepted by the HDRI light.</caption>
<colgroup>
<col width="18%" />
<col width="8%" />
<col width="69%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">vec3f(a)</td>
<td align="left">up</td>
<td align="left">up direction of the light in world-space</td>
</tr>
<tr class="even">
<td align="left">vec3f(a)</td>
<td align="left">dir</td>
<td align="left">direction to which the center of the texture will be mapped to (analog to <a href="#panoramic-camera">panoramic camera</a>)</td>
</tr>
<tr class="odd">
<td align="left">OSPTexture2D</td>
<td align="left">map</td>
<td align="left">environment map in latitude / longitude format</td>
</tr>
</tbody>
</table>
<div class="figure">
<img src="images/hdri_light.png" alt="Orientation and Mapping of an HDRI Light." />
<p class="caption">Orientation and Mapping of an HDRI Light.</p>
</div>
<p>Note that the currently only the <a href="documentation.html#path-tracer">path tracer</a> supports the HDRI light.</p>
<h4 id="ambient-light">Ambient Light</h4>
<p>The ambient light surrounds the scene and illuminates it from infinity with constant radiance (determined by combining the <a href="#lights">parameters <code>color</code> and <code>intensity</code></a>). It is created by passing the type string “<code>ambient</code>” to <code>ospNewLight</code>.</p>
<p>Note that the <a href="#scivis-renderer">SciVis renderer</a> uses ambient lights to control the color and intensity of the computed ambient occlusion (AO).</p>
<h4 id="emissive-objects">Emissive Objects</h4>
<p>The <a href="documentation.html#path-tracer">path tracer</a> will consider illumination by <a href="#geometries">geometries</a> which have a light emitting material assigned (for example the <a href="#luminous">Luminous</a> material).</p>
<h3 id="materials">Materials</h3>
<p>Materials describe how light interacts with surfaces, they give objects their distinctive look. To let the given renderer create a new material of given type <code>type</code> call</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">OSPMaterial ospNewMaterial(OSPRenderer, <span class="at">const</span> <span class="dt">char</span> *type);</code></pre></div>
<p>The call returns <code>NULL</code> if the material type is not known by the renderer, or else an <code>OSPMaterial</code> handle to the created material. The handle can then be used to assign the material to a given geometry with</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> ospSetMaterial(OSPGeometry, OSPMaterial);</code></pre></div>
<h4 id="obj-material">OBJ Material</h4>
<p>The OBJ material is the workhorse material supported by both the <a href="#scivis-renderer">SciVis renderer</a> and the <a href="documentation.html#path-tracer">path tracer</a>. It offers widely used common properties like diffuse and specular reflection and is based on the <a href="http://paulbourke.net/dataformats/mtl/">MTL material format</a> of Lightwave’s OBJ scene files. To create an OBJ material pass the type string “<code>OBJMaterial</code>” to <code>ospNewMaterial</code>. Its main parameters are</p>
<table>
<caption>Main parameters of the OBJ material.</caption>
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="right">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">vec3f</td>
<td align="left">Kd</td>
<td align="right">white 0.8</td>
<td align="left">diffuse color</td>
</tr>
<tr class="even">
<td align="left">vec3f</td>
<td align="left">Ks</td>
<td align="right">black</td>
<td align="left">specular color</td>
</tr>
<tr class="odd">
<td align="left">float</td>
<td align="left">Ns</td>
<td align="right">10</td>
<td align="left">shininess (Phong exponent), usually in [2–10<sup>4</sup>]</td>
</tr>
<tr class="even">
<td align="left">float</td>
<td align="left">d</td>
<td align="right">opaque</td>
<td align="left">opacity</td>
</tr>
<tr class="odd">
<td align="left">vec3f</td>
<td align="left">Tf</td>
<td align="right">black</td>
<td align="left">transparency filter color</td>
</tr>
<tr class="even">
<td align="left">OSPTexture2D</td>
<td align="left">map_Bump</td>
<td align="right">NULL</td>
<td align="left">normal map</td>
</tr>
</tbody>
</table>
<p>In particular when using the path tracer it is important to adhere to the principle of energy conservation, i.e. that the amount of light reflected by a surface is not larger than the light arriving. Therefore the path tracer issues a warning and renormalizes the color parameters if the sum of <code>Kd</code>, <code>Ks</code>, and <code>Tf</code> is larger than one in any color channel. Similarly important to mention is that almost all materials of the real world reflect at most only about 80% of the incoming light. So even for a white sheet of paper or white wall paint do better not set <code>Kd</code> larger than 0.8; otherwise rendering times are unnecessary long and the contrast in the final images is low (for example, the corners of a white room would hardly be discernible).</p>
<p>Note that currently only the path tracer implements colored transparency with <code>Tf</code>.</p>
<p>Normal mapping can simulate small geometric features via the texture <code>map_Bump</code>. The normals <span class="math inline"><em>n</em></span> in the normal map are wrt. the local tangential shading coordinate system and are encoded as <span class="math inline">½(<em>n</em> + 1)</span>, thus a texel <span class="math inline">(0.5, 0.5, 1)</span><a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a> represents the unperturbed shading normal <span class="math inline">(0, 0, 1)</span>. Because of this encoding an sRGB gamma <a href="#texture">texture</a> format is ignored and normals are always fetched as linear from a normal map. Note that the orientation of normal maps is important for a visually consistent look: by convention OSPRay uses a coordinate system with the origin in the lower left corner; thus a convexity will look green towards the top of the texture image (see also the example image of a normal map). If this is not the case flip the normal map vertically or invert its green channel.</p>
<div class="figure">
<img src="images/normalmap_frustum.png" alt="Normal map representing an exalted square pyramidal frustum." style="width:60.0%" />
<p class="caption">Normal map representing an exalted square pyramidal frustum.</p>
</div>
<p>All parameters (except <code>Tf</code>) can be textured by passing a <a href="#texture">texture</a> handle, prefixed with “<code>map_</code>”. The fetched texels are multiplied by the respective parameter value. Texturing requires <a href="#geometries">geometries</a> with texture coordinates, e.g. a <a href="#triangle-mesh">triangle mesh</a> with <code>vertex.texcoord</code> provided. The color textures <code>map_Kd</code> and <code>map_Ks</code> are typically in one of the sRGB gamma encoded formats, whereas textures <code>map_Ns</code> and <code>map_d</code> are usually in a linear format (and only the first component is used). The path tracer additionally supports <a href="#texture-transformations">texture transformations</a> for all textures.</p>
<h4 id="glass">Glass</h4>
<p>The <a href="documentation.html#path-tracer">path tracer</a> offers a realistic a glass material, supporting refraction and volumetric attenuation (i.e. the transparency color varies with the geometric thickness). To create a Glass material pass the type string “<code>Glass</code>” to <code>ospNewMaterial</code>. Its parameters are</p>
<table>
<caption>Parameters of the Glass material.</caption>
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="right">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">float</td>
<td align="left">eta</td>
<td align="right">1.5</td>
<td align="left">index of refraction</td>
</tr>
<tr class="even">
<td align="left">vec3f</td>
<td align="left">attenuationColor</td>
<td align="right">white</td>
<td align="left">resulting color due to attenuation</td>
</tr>
<tr class="odd">
<td align="left">float</td>
<td align="left">attenuationDistance</td>
<td align="right">1</td>
<td align="left">distance affecting attenuation</td>
</tr>
</tbody>
</table>
<p>For convenience, the rather counterintuitive physical attenuation coefficients will be calculated from the user inputs in such a way, that the <code>attenuationColor</code> will be the result when white light traveled trough a glass of thickness <code>attenuationDistance</code>.</p>
<h4 id="luminous">Luminous</h4>
<p>The <a href="documentation.html#path-tracer">path tracer</a> supports the Luminous material which emits light uniformly in all directions and which can thus be used to turn any geometric object into a light source. It is created by passing the type string “<code>Luminous</code>” to <code>ospNewMaterial</code>. The amount of constant radiance that is emitted is determined by combining the general parameters of lights: <a href="#lights"><code>color</code> and <code>intensity</code></a>.</p>
<h3 id="texture">Texture</h3>
<p>To create a new 2D texture of size <code>size</code> (in pixels) and with the given format and flags use</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">OSPTexture2D ospNewTexture2D(<span class="at">const</span> vec2i &amp;size,
                             <span class="at">const</span> OSPTextureFormat,
                             <span class="dt">void</span> *source = NULL,
                             <span class="at">const</span> <span class="dt">uint32_t</span> textureCreationFlags = <span class="dv">0</span>);</code></pre></div>
<p>The call returns <code>NULL</code> if the texture could not be created with the given parameters, or else an <code>OSPTexture2D</code> handle to the created texture. The supported texture formats are:</p>
<table>
<caption>Supported texture formats by <code>ospNewTexture2D</code>, i.e. valid constants of type <code>OSPTextureFormat</code>.</caption>
<thead>
<tr class="header">
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">OSP_TEXTURE_RGBA8</td>
<td align="left">8 bit [0–255] linear components red, green, blue, alpha</td>
</tr>
<tr class="even">
<td align="left">OSP_TEXTURE_SRGBA</td>
<td align="left">8 bit sRGB gamma encoded color components, and linear alpha</td>
</tr>
<tr class="odd">
<td align="left">OSP_TEXTURE_RGBA32F</td>
<td align="left">32 bit float components red, green, blue, alpha</td>
</tr>
<tr class="even">
<td align="left">OSP_TEXTURE_RGB8</td>
<td align="left">8 bit [0–255] linear components red, green, blue</td>
</tr>
<tr class="odd">
<td align="left">OSP_TEXTURE_SRGB</td>
<td align="left">8 bit sRGB gamma encoded components red, green, blue</td>
</tr>
<tr class="even">
<td align="left">OSP_TEXTURE_RGB32F</td>
<td align="left">32 bit float components red, green, blue</td>
</tr>
<tr class="odd">
<td align="left">OSP_TEXTURE_R8</td>
<td align="left">8 bit [0–255] linear single component</td>
</tr>
<tr class="even">
<td align="left">OSP_TEXTURE_R32F</td>
<td align="left">32 bit float single component</td>
</tr>
</tbody>
</table>
<p>The texel data addressed by <code>source</code> starts with the texels in the lower left corner of the texture image, like in OpenGL. Similar to <a href="#data">data</a> buffers the texel data can be shared by the application by specifying the <code>OSP_TEXTURE_SHARED_BUFFER</code> flag. Per default a texture fetch is filtered by performing bi-linear interpolation of the nearest 2×2 texels; if instead fetching only the nearest texel is desired (i.e. no filtering) then pass the <code>OSP_TEXTURE_FILTER_NEAREST</code> flag. Both texture creating flags can be combined with a bitwise OR.</p>
<h3 id="texture-transformations">Texture Transformations</h3>
<p>Many materials with textures also offer to manipulate the placement of these textures with the help of texture transformations. If so, this convention shall be used. The following parameters (prefixed with “<code>texture_name.</code>”) are combined into one transformation matrix:</p>
<table>
<caption>Parameters to define texture coordinate transformations.</caption>
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">vec4f</td>
<td align="left">transform</td>
<td align="left">interpreted as 2×2 matrix (linear part), column-major</td>
</tr>
<tr class="even">
<td align="left">float</td>
<td align="left">rotation</td>
<td align="left">angle in degree, counterclock-wise, around center</td>
</tr>
<tr class="odd">
<td align="left">vec2f</td>
<td align="left">scale</td>
<td align="left">enlarge texture, relative to center (0.5, 0.5)</td>
</tr>
<tr class="even">
<td align="left">vec2f</td>
<td align="left">translation</td>
<td align="left">move texture in positive direction (right/up)</td>
</tr>
</tbody>
</table>
<p>The transformations are applied in the given order. Rotation, scale and translation are interpreted “texture centric”, i.e. their effect seen by an user are relative to the texture (although the transformations are applied to the texture coordinates).</p>
<h3 id="cameras">Cameras</h3>
<p>To create a new camera of given type <code>type</code> use</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">OSPCamera ospNewCamera(<span class="at">const</span> <span class="dt">char</span> *type);</code></pre></div>
<p>The call returns <code>NULL</code> if that type of camera is not known, or else an <code>OSPCamera</code> handle to the created camera. All cameras accept these parameters:</p>
<table>
<caption>Parameters accepted by all cameras.</caption>
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">vec3f(a)</td>
<td align="left">pos</td>
<td align="left">position of the camera in world-space</td>
</tr>
<tr class="even">
<td align="left">vec3f(a)</td>
<td align="left">dir</td>
<td align="left">main viewing direction of the camera</td>
</tr>
<tr class="odd">
<td align="left">vec3f(a)</td>
<td align="left">up</td>
<td align="left">up direction of the camera</td>
</tr>
<tr class="even">
<td align="left">float</td>
<td align="left">nearClip</td>
<td align="left">near clipping distance</td>
</tr>
<tr class="odd">
<td align="left">vec2f</td>
<td align="left">imageStart</td>
<td align="left">start of image region (lower left corner)</td>
</tr>
<tr class="even">
<td align="left">vec2f</td>
<td align="left">imageEnd</td>
<td align="left">end of image region (upper right corner)</td>
</tr>
</tbody>
</table>
<p>The camera is placed and oriented in the world with <code>pos</code>, <code>dir</code> and <code>up</code>. The region of the camera sensor that is rendered to the image can be specified in normalized screen-space coordinates with <code>imageStart</code> (lower left corner) and <code>imageEnd</code> (upper right corner). This can be used, for example, to crop the image or to achieve asymmetrical view frusta. Note that values outside the default range of [0–1] are valid, which is useful to easily realize overscan or film gate, or to emulate a shifted sensor.</p>
<h4 id="perspective-camera">Perspective Camera</h4>
<p>The perspective camera implements a simple thinlens camera for perspective rendering, supporting optionally depth of field and stereo rendering, but no motion blur. It is created by passing the type string “<code>perspective</code>” to <code>ospNewCamera</code>. In addition to the <a href="#cameras">general parameters</a> understood by all cameras the perspective camera supports the special parameters listed in the table below.</p>
<table style="width:97%;">
<caption>Parameters accepted by the perspective camera.</caption>
<colgroup>
<col width="8%" />
<col width="31%" />
<col width="56%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">float</td>
<td align="left">fovy</td>
<td align="left">the field of view (angle in degree) of the frame’s height</td>
</tr>
<tr class="even">
<td align="left">float</td>
<td align="left">aspect</td>
<td align="left">ratio of width by height of the frame</td>
</tr>
<tr class="odd">
<td align="left">float</td>
<td align="left">apertureRadius</td>
<td align="left">size of the aperture, controls the depth of field</td>
</tr>
<tr class="even">
<td align="left">float</td>
<td align="left">focusDistance</td>
<td align="left">distance at where the image is sharpest when depth of field is enabled</td>
</tr>
<tr class="odd">
<td align="left">bool</td>
<td align="left">architectural</td>
<td align="left">vertical edges are projected to be parallel</td>
</tr>
<tr class="even">
<td align="left">int</td>
<td align="left">stereoMode</td>
<td align="left">0: no stereo (default), 1: left eye, 2: right eye, 3: side-by-side</td>
</tr>
<tr class="odd">
<td align="left">float</td>
<td align="left">interpupillaryDistance</td>
<td align="left">distance between left and right eye when stereo is enabled</td>
</tr>
</tbody>
</table>
<p>Note that when setting the <code>aspect</code> ratio a non-default image region (using <code>imageStart</code> &amp; <code>imageEnd</code>) needs to be regarded.</p>
<p>In architectural photography it is often desired for aesthetic reasons to display the vertical edges of buildings or walls vertically in the image as well, regardless of how the camera is tilted. Enabling the <code>architectural</code> mode achieves this by internally leveling the camera parallel to the ground (based on the <code>up</code> direction) and then shifting the lens such that the objects in direction <code>dir</code> are centered in the image. If finer control of the lens shift is needed use <code>imageStart</code> &amp; <code>imageEnd</code>. Because the camera is now effectively leveled its image plane and thus the plane of focus is oriented parallel to the front of buildings, the whole façade appears sharp, as can be seen in the example images below.</p>
<div class="figure">
<img src="images/camera_perspective.jpg" alt="Example image created with the perspective camera, featuring depth of field." style="width:60.0%" />
<p class="caption">Example image created with the perspective camera, featuring depth of field.</p>
</div>
<div class="figure">
<img src="images/camera_architectual.jpg" alt="Enabling the architectural flag corrects the perspective projection distortion, resulting in parallel vertical edges." style="width:60.0%" />
<p class="caption">Enabling the <code>architectural</code> flag corrects the perspective projection distortion, resulting in parallel vertical edges.</p>
</div>
<div class="figure">
<img src="images/camera_stereo.jpg" alt="Example 3D stereo image using stereoMode side-by-side." style="width:90.0%" />
<p class="caption">Example 3D stereo image using <code>stereoMode</code> side-by-side.</p>
</div>
<h4 id="orthographic-camera">Orthographic Camera</h4>
<p>The orthographic camera implements a simple camera with orthographic projection, without support for depth of field or motion blur. It is created by passing the type string “<code>orthographic</code>” to <code>ospNewCamera</code>. In addition to the <a href="#cameras">general parameters</a> understood by all cameras the orthographic camera supports the following special parameters:</p>
<table>
<caption>Parameters accepted by the orthographic camera.</caption>
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">float</td>
<td align="left">height</td>
<td align="left">size of the camera’s image plane in y, in world coordinates</td>
</tr>
<tr class="even">
<td align="left">float</td>
<td align="left">aspect</td>
<td align="left">ratio of width by height of the frame</td>
</tr>
</tbody>
</table>
<p>For convenience the size of the camera sensor, and thus the extent of the scene that is captured in the image, can be controlled with the <code>height</code> parameter. The same effect can be achieved with <code>imageStart</code> and <code>imageEnd</code>, and both methods can be combined. In any case, the <code>aspect</code> ratio needs to be set accordingly to get an undistorted image.</p>
<div class="figure">
<img src="images/camera_orthographic.jpg" alt="Example image created with the orthographic camera." style="width:60.0%" />
<p class="caption">Example image created with the orthographic camera.</p>
</div>
<h4 id="panoramic-camera">Panoramic Camera</h4>
<p>The panoramic camera implements a simple camera without support for motion blur. It captures the complete surrounding with a latitude / longitude mapping and thus the rendered images should best have a ratio of 2:1. A panoramic camera is created by passing the type string “<code>panoramic</code>” to <code>ospNewCamera</code>. It is placed and oriented in the scene by using the <a href="#cameras">general parameters</a> understood by all cameras.</p>
<div class="figure">
<img src="images/camera_panoramic.jpg" alt="Latitude / longitude map created with the panoramic camera." style="width:90.0%" />
<p class="caption">Latitude / longitude map created with the panoramic camera.</p>
</div>
<h3 id="picking">Picking</h3>
<p>To get the world-space position of the geometry (if any) seen at [0–1] normalized screen-space pixel coordinates <code>screenPos</code> use</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> ospPick(OSPPickResult*, OSPRenderer, <span class="at">const</span> vec2f &amp;screenPos);</code></pre></div>
<p>The result is returned in the provided <code>OSPPickResult</code> struct:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">typedef</span> <span class="kw">struct</span> {
    vec3f position; <span class="co">// the position of the hit point (in world-space)</span>
    <span class="dt">bool</span> hit;       <span class="co">// whether or not a hit actually occurred</span>
} OSPPickResult;</code></pre></div>
<p>Note that <code>ospPick</code> considers exactly the same camera of the given renderer that is used to render an image, thus matching results can be expected. If the camera supports depth of field then the center of the lens and thus the center of the circle of confusion is used for picking.</p>
<h2 id="framebuffer">Framebuffer</h2>
<p>The framebuffer holds the rendered 2D image (and optionally auxiliary information associated with pixels). To create a new framebuffer object of given size <code>size</code> (in pixels), color format, and channels use</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">OSPFrameBuffer ospNewFrameBuffer(<span class="at">const</span> vec2i &amp;size,
                                 <span class="at">const</span> OSPFrameBufferFormat format = OSP_FB_SRGBA,
                                 <span class="at">const</span> <span class="dt">uint32_t</span> frameBufferChannels = OSP_FB_COLOR);</code></pre></div>
<p>The parameter <code>format</code> describes the format the color buffer has <em>on the host</em>, and the format that <code>ospMapFrameBuffer</code> will eventually return. Valid values are:</p>
<table>
<caption>Supported color formats of the framebuffer that can be passed to <code>ospNewFrameBuffer</code>, i.e. valid constants of type <code>OSPFrameBufferFormat</code>.</caption>
<thead>
<tr class="header">
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">OSP_FB_NONE</td>
<td align="left">framebuffer will not be mapped by the application</td>
</tr>
<tr class="even">
<td align="left">OSP_FB_RGBA8</td>
<td align="left">8 bit [0–255] linear component red, green, blue, alpha</td>
</tr>
<tr class="odd">
<td align="left">OSP_FB_SRGBA</td>
<td align="left">8 bit sRGB gamma encoded color components, and linear alpha</td>
</tr>
<tr class="even">
<td align="left">OSP_FB_RGBA32F</td>
<td align="left">32 bit float components red, green, blue, alpha</td>
</tr>
</tbody>
</table>
<p>The parameter <code>frameBufferChannels</code> specifies which channels the framebuffer holds, and can be combined together by bitwise OR from the values of <code>OSPFrameBufferChannel</code> listed in the table below.</p>
<table>
<caption>Framebuffer channels constants (of type <code>OSPFrameBufferChannel</code>), naming optional information the framebuffer can store. These values can be combined by bitwise OR when passed to <code>ospNewFrameBuffer</code> or <code>ospClearFrameBuffer</code>.</caption>
<thead>
<tr class="header">
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">OSP_FB_COLOR</td>
<td align="left">RGB color including alpha</td>
</tr>
<tr class="even">
<td align="left">OSP_FB_DEPTH</td>
<td align="left">euclidean distance to the camera (<em>not</em> to the image plane)</td>
</tr>
<tr class="odd">
<td align="left">OSP_FB_ACCUM</td>
<td align="left">accumulation buffer for progressive refinement</td>
</tr>
<tr class="even">
<td align="left">OSP_FB_VARIANCE</td>
<td align="left">estimate of the current variance, see <a href="#rendering">rendering</a></td>
</tr>
</tbody>
</table>
<p>If a certain channel value is <em>not</em> specified, the given buffer channel will not be present. Note that ospray makes a very clear distinction between the <em>external</em> format of the framebuffer and the internal one: The external format is the format the user specifies in the <code>format</code> parameter; it specifies what color format OSPRay will eventually <em>return</em> the framebuffer to the application (when calling <code>ospMapFrameBuffer</code>): no matter what OSPRay uses internally, it will simply return a 2D array of pixels of that format, with possibly all kinds of reformatting, compression/decompression, etc, going on in-between the generation of the <em>internal</em> framebuffer and the mapping of the externally visible one.</p>
<p>In particular, <code>OSP_FB_NONE</code> is a perfectly valid pixel format for a framebuffer that an application will never map. For example, an application driving a display wall may well generate an intermediate framebuffer and eventually transfer its pixel to the individual displays using an <code>OSPPixelOp</code> <a href="#pixel-operation">pixel operation</a>.</p>
<p>A framebuffer can be freed again using</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> ospFreeFrameBuffer(OSPFrameBuffer);</code></pre></div>
<p>Because OSPRay uses reference counting internally the framebuffer may not immediately be deleted at this time.</p>
<p>The application can map the given channel of a framebuffer – and thus access the stored pixel information – via</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="at">const</span> <span class="dt">void</span> *ospMapFrameBuffer(OSPFrameBuffer,
                              <span class="at">const</span> OSPFrameBufferChannel = OSP_FB_COLOR);</code></pre></div>
<p>Note that only <code>OSP_FB_COLOR</code> or <code>OSP_FB_DEPTH</code> can be mapped. The origin of the screen coordinate system in OSPRay is the lower left corner (as in OpenGL), thus the first pixel addressed by the returned pointer is the lower left pixel of the image.</p>
<p>A previously mapped channel of a framebuffer can be unmapped by passing the received pointer <code>mapped</code> to</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> ospUnmapFrameBuffer(<span class="at">const</span> <span class="dt">void</span> *mapped, OSPFrameBuffer);</code></pre></div>
<p>The individual channels of a framebuffer can be cleared with</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> ospFrameBufferClear(OSPFrameBuffer, <span class="at">const</span> <span class="dt">uint32_t</span> frameBufferChannels);</code></pre></div>
<p>When selected, <code>OSP_FB_COLOR</code> will clear the color buffer to black <code>(0, 0, 0, 0)</code>, <code>OSP_FB_DEPTH</code> will clear the depth buffer to <code>inf</code>, <code>OSP_FB_ACCUM</code> will clear the accumulation buffer to black, resets the accumulation counter <code>accumID</code> and also clears the variance buffer (if present) to <code>inf</code>.</p>
<h3 id="pixel-operation" class="unnumbered">Pixel Operation</h3>
<p>A pixel operation are functions that are applied to every pixel that gets written into a framebuffer. Examples include post-processing, filtering, blending, tone mapping, or sending tiles to a display wall. To create a new pixel operation of given type <code>type</code> use</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">OSPPixelOp ospNewPixelOp(<span class="at">const</span> <span class="dt">char</span> *type);</code></pre></div>
<p>The call returns <code>NULL</code> if that type is not known, or else an <code>OSPPixelOp</code> handle to the created pixel operation.</p>
<p>To set a pixel operation to the given framebuffer use</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> ospSetPixelOp(OSPFrameBuffer, OSPPixelOp);</code></pre></div>
<h2 id="rendering">Rendering</h2>
<p>To render a frame into the given framebuffer with the given renderer use</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">float</span> ospRenderFrame(OSPFrameBuffer, OSPRenderer,
                     <span class="at">const</span> <span class="dt">uint32_t</span> frameBufferChannels = OSP_FB_COLOR);</code></pre></div>
<p>The third parameter specifies what channel(s) of the framebuffer is written to<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a>. What to render and how to render it depends on the renderer’s parameters. If the framebuffer supports accumulation (i.e. it was created with <code>OSP_FB_ACCUM</code>) then successive calls to <code>ospRenderFrame</code> will progressively refine the rendered image. If additionally the framebuffer has an <code>OSP_FB_VARIANCE</code> channel then <code>ospRenderFrame</code> returns an estimate of the current variance of the rendered image, otherwise <code>inf</code> is returned. The estimated variance can be used by the application as a quality indicator and thus to decide whether to stop or to continue progressive rendering.</p>
<h1 id="parallel-rendering-with-mpi">Parallel Rendering with MPI</h1>
<p>OSPRay has the ability to scale to multiple nodes in a cluster via MPI. This enables applications to take advantage of larger compute and memory resources when available.</p>
<h2 id="prerequisites-for-mpi-mode">Prerequisites for MPI Mode</h2>
<p>In addition to the standard build requirements of OSPRay, you must have the following items available in your environment in order to build&amp;run OSPRay in MPI mode:</p>
<ul>
<li>An MPI enabled multi-node environment, such as an HPC cluster</li>
<li>An MPI implementation you can build against (i.e. Intel MPI, MVAPICH2, etc…)</li>
</ul>
<h2 id="enabling-the-mpi-module-in-your-build">Enabling the MPI module in your build</h2>
<p>To build the MPI module the CMake variable <code>OSPRAY_MODULE_MPI</code> must be enabled, which can be done directly on the command line (with <code>-D...</code>) or through a configuration dialog (<code>ccmake</code>, <code>cmake-gui</code>), see also [Compiling OSPRay].</p>
<p>This will trigger CMake to go look for an MPI implementation in your environment. You can then inspect the CMake value of <code>MPI_LIBRARY</code> to make sure that CMake found your MPI build environment correctly.</p>
<p>This will result in an OSPRay module being built. To enable using it, applications will need to either link <code>libospray_module_mpi</code>, or call</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">ospLoadModule(<span class="st">&quot;mpi&quot;</span>);</code></pre></div>
<p>before initializing OSPRay.</p>
<h2 id="modes-of-using-osprays-mpi-features">Modes of using OSPRay’s MPI features</h2>
<p>OSPRay provides two ways of using MPI to scale up rendering: offload and distributed.</p>
<p>The “offload” rendering mode is where a single (not-distributed) calling application treats the OSPRay API the same as with local rendering. However, OSPRay uses multiple MPI connected nodes to evenly distribute frame rendering work, where each node contains a full copy of all scene data. This method is most effective for scenes which can fit into memory, but are very expensive to render: for example, path tracing with many samples-per-pixel is very compute heavy, making it a good situation to use the offload feature. This can be done with any application which already uses OSPRay for local rendering without the need for any code changes.</p>
<p>The “distributed” rendering mode is where a MPI distributed application (such as a scientific simulation) uses OSPRay collectively to render frames. In this case, the API expects all calls (both created objects and parameters) to be the same on every application rank, except each rank can specify arbitrary geometries and volumes. Each renderer will have its own limitations on the topology of the data (i.e. overlapping data regions, concave data, etc.), but the API calls will only differ for scene objects. Thus all other calls (i.e. setting camera, creating framebuffer, rendering frame, etc.) will all be assumed to be identical, but only rendering a frame and committing the model must be in lock-step. This mode targets using all available aggregate memory for very large scenes and for “in-situ” visualization where the data is already distributed by a simulation app.</p>
<h2 id="running-an-application-with-the-offload-device">Running an application with the “offload” device</h2>
<p>As an example, our sample viewer can be run as a single application which offloads rendering work to multiple MPI processes running on multiple machines.</p>
<p>The example apps are setup to be launched in two different setups. In either setup, the application must initialize OSPRay with the offload device. This can be done by creating an “<code>mpi_offload</code>” device and setting it as the current device (via the <code>ospSetCurrentDevice()</code> function), or passing either “<code>--osp:mpi</code>” or “<code>--osp:mpi-offload</code>” as a command line parameter to <code>ospInit()</code>. Note that passing a command line parameter will automatically call <code>ospLoadModule(&quot;mpi&quot;)</code> to load the MPI module, while the application will have to load the module explicitly if using <code>ospNewDevice()</code>.</p>
<p><strong>Option 1: single MPI launch</strong></p>
<p>OSPRay is initialized with the <code>ospInit()</code> function call which takes command line arguments in and configures OSPRay based on what it finds. In this setup, the app is launched across all ranks, but workers will never return from <code>ospInit()</code>, essentially turning the application into a worker process for OSPRay. Here’s an example of running the ospVolumeViewer data-replicated, using <code>c1</code>-<code>c4</code> as compute nodes and <code>localhost</code> the process running the viewer itself:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">% mpirun -perhost <span class="dv">1</span> -hosts localhost,c1,c2,c3,c4 ./ospExampleViewer [scene_file] --osp:mpi</code></pre></div>
<p><strong>Option 2: separate app/worker launches</strong></p>
<p>The second option is to explicitly launch the app on rank 0 and worker ranks on the other nodes. This is done by running <code>ospray_mpi_worker</code> on worker nodes and the application on the display node. Here’s the same example above using this syntax:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">% mpirun -perhost <span class="dv">1</span> -hosts localhost ./ospExampleViewer [scene_file] --osp:mpi \
  : -hosts c1,c2,c3,c4 ./ospray_mpi_worker --osp:mpi</code></pre></div>
<p>This method of launching the application and OSPRay worker separately works best for applications which do not immediately call <code>ospInit()</code> in their <code>main()</code> function, or for environments where application dependencies (such as GUI libraries) may not be available on compute nodes.</p>
<h2 id="running-an-application-with-the-distributed-device">Running an application with the “distributed” device</h2>
<p>Applications using the new distributed device should initialize OSPRay by creating (and setting current) an “<code>mpi_distributed</code>” device or pass <code>&quot;--osp:mpi-distributed&quot;</code> as a command line argument to <code>ospInit()</code>. Note that due to the semantic differences the distributed device gives the OSPRay API, it is not expected for applications which can already use the offload device to correctly use the distributed device without changes to the application.</p>
<h1 id="examples">Examples</h1>
<h2 id="tutorial">Tutorial</h2>
<p>A minimal working example demonstrating how to use OSPRay can be found at <code>apps/ospTutorial.cpp</code><a href="#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a>. On Linux build it in the build directory with</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">g++ ../apps/ospTutorial.cpp -I ../ospray/include -I .. ./libospray.so -Wl,-rpath,. -o ospTutorial</code></pre></div>
<p>On Windows build it in the build_directory\$Configuration with</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">cl ..\..\apps\ospTutorial.cpp /EHsc -I ..\..\ospray\include -I ..\.. ospray.lib</code></pre></div>
<p>Running <code>ospTutorial</code> will create two images of two triangles, rendered with the Scientific Visualization renderer with full Ambient Occlusion. The first image <code>firstFrame.ppm</code> shows the result after one call to <code>ospRenderFrame</code> – jagged edges and noise in the shadow can be seen. Calling <code>ospRenderFrame</code> multiple times enables progressive refinement, resulting in antialiased edges and converged shadows, shown after ten frames in the second image <code>accumulatedFrames.png</code>.</p>
<div class="figure">
<img src="images/tutorial_firstframe.png" alt="First frame." />
<p class="caption">First frame.</p>
</div>
<div class="figure">
<img src="images/tutorial_accumulatedframe.png" alt="After accumulating ten frames." />
<p class="caption">After accumulating ten frames.</p>
</div>
<h2 id="example-viewer">Example Viewer</h2>
<p>OSPRay also includes an exemplary viewer application <code>ospExampleViewerSg</code>, showcasing all features of OSPRay. The Example Viewer uses the ImGui library for user interface controls. The viewer is based on a prototype OSPRay scenegraph interface where its nodes are displayed in the GUI and can be manipulated interactively. For instance, simply run it as <code>ospExampleViewerSg teapot.obj</code>.</p>
<p>This application also functions as an OSPRay state debugger – invalid values will be shown in red up the hierarchy and won’t change the viewer until corrected. You can also add new nodes where appropriate: for example, when “lights” is expanded right clicking on “lights” and typing in a light type, such as “point”, will add it to the scene. Similarly, right clicking on “world” and creating an “Importer” node will add a new scene importer from a file. Changing the filename to an appropriate file will load the scene and propagate the resulting state.</p>
<div class="figure">
<img src="images/exampleViewer.jpg" alt="Screenshot of ospExampleViewerSg" style="width:80.0%" />
<p class="caption">Screenshot of <code>ospExampleViewerSg</code></p>
</div>
<h2 id="demos">Demos</h2>
<p>Several ready-to-run demos, models and data sets for OSPRay can be found at the <a href="demos.html">OSPRay Demos and Examples</a> page.</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>The <a href="#hdri-light">HDRI Light</a> is an exception, it knows about <code>intensity</code>, but not about <code>color</code>.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>actually a parallelogram<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>respectively <span class="math inline">(127, 127, 255)</span> for 8 bit textures<a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>This is currently not implemented, i.e. all channels of the framebuffer are always updated.<a href="#fnref4">↩</a></p></li>
<li id="fn5"><p>A C99 version is available at <code>apps/ospTutorial.c</code>.<a href="#fnref5">↩</a></p></li>
</ol>
</div>

      </div>
    </div>

      <div id="footer">
        © 2013–2017 Intel Corporation <a href="legal.html">Disclaimer and Legal Information</a>
      </div>
  </body>
</html>
