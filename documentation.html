<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html" charset="utf-8">
    <title>Intel OSPRay Documentation</title>
    <link rel="stylesheet" type="text/css" media="screen" href="stylesheet.css">
    <style type="text/css">
code.sourceCode > span { display: inline-block; line-height: 1.25; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
div.sourceCode { overflow-x: initial; }
    </style>

  </head>

  <body>
    <div id="header">
      <div id="header-github">
        <a id="forkme-banner" href="https://github.com/ospray/OSPRay">View on GitHub</a>
      </div>
      <div id="header-title">
        Intel<sup>&reg;</sup> OSPRay
      </div>

      <div id="header-navbar">
        <ul>
          <li><a href="index.html">Overview</a></li>
	  <li><a href="downloads.html">Downloads</a></li>
	  <li id="selected"><a href="documentation.html">Documentation</a></li>
	  <li><a href="examples.html">Examples</a></li>
	  <li><a href="gallery.html">Gallery</a></li>
	  <li><a href="https://github.com/ospray/OSPRay/issues">Bugs/Issues</a></li>
	  <li><a href="related_projects.html">Related Projects</a></li>
	</ul>
      </div>
      <div id="header-spacing"></div>
    </div>

    <div id="content-wrap">
      <div id="content">

<h1 id="documentation">Documentation</h1>
<p>The following <a href="http://www.sdvis.org/ospray/download/OSPRay_readme.pdf" title="OSPRay Documentation">API documentation</a> of OSPRay can also be found as a <a href="http://www.sdvis.org/ospray/download/OSPRay_readme.pdf" title="OSPRay Documentation">pdf document</a>.</p>
<p>For a deeper explanation of the concepts, design, features and performance of OSPRay also have a look at the IEEE Vis 2016 paper “<a href="http://www.sdvis.org/ospray/download/talks/IEEEVis2016_OSPRay_paper.pdf">OSPRay – A CPU Ray Tracing Framework for Scientific Visualization</a>” (49MB, or get the <a href="http://www.sdvis.org/ospray/download/talks/IEEEVis2016_OSPRay_paper_small.pdf">smaller version</a> 1.8MB). The <a href="http://www.sdvis.org/ospray/download/talks/IEEEVis2016_OSPRay_talk.pdf">slides of the talk</a> (5.2MB) are also available.</p>
<h1 id="ospray-api">OSPRay API</h1>
<p>To access the OSPRay API you first need to include the OSPRay header</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1"></a><span class="pp">#include </span><span class="im">&quot;ospray/ospray.h&quot;</span></span></code></pre></div>
<p>where the API is compatible with C99 and C++.</p>
<h2 id="initialization-and-shutdown">Initialization and Shutdown</h2>
<p>To use the API, OSPRay must be initialized with a “device”. A device is the object which implements the API. Creating and initializing a device can be done in either of two ways: command line arguments using <code>ospInit</code> or manually instantiating a device and setting parameters on it.</p>
<h3 id="command-line-arguments">Command Line Arguments</h3>
<p>The first is to do so by giving OSPRay the command line from <code>main()</code> by calling</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1"></a>OSPError ospInit(<span class="dt">int</span> *argc, <span class="at">const</span> <span class="dt">char</span> **argv);</span></code></pre></div>
<p>OSPRay parses (and removes) its known command line parameters from your application’s <code>main</code> function. For an example see the <a href="#tutorial">tutorial</a>. For possible error codes see section <a href="#error-handling-and-status-messages">Error Handling and Status Messages</a>. It is important to note that the arguments passed to <code>ospInit()</code> are processed in order they are listed. The following parameters (which are prefixed by convention with “<code>--osp:</code>”) are understood:</p>
<table style="width:98%;">
<caption>Command line parameters accepted by OSPRay’s <code>ospInit</code>.</caption>
<colgroup>
<col style="width: 53%" />
<col style="width: 44%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Parameter</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>--osp:debug</code></td>
<td style="text-align: left;">enables various extra checks and debug output, and disables multi-threading</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>--osp:num-threads=&lt;n&gt;</code></td>
<td style="text-align: left;">use <code>n</code> threads instead of per default using all detected hardware threads</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>--osp:log-level=&lt;str&gt;</code></td>
<td style="text-align: left;">set logging level; valid values (in order of severity) are <code>none</code>, <code>error</code>, <code>warning</code>, <code>info</code>, and <code>debug</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>--osp:warn-as-error</code></td>
<td style="text-align: left;">send <code>warning</code> and <code>error</code> messages through the error callback, otherwise send <code>warning</code> messages through the message callback; must have sufficient <code>logLevel</code> to enable warnings</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>--osp:verbose</code></td>
<td style="text-align: left;">shortcut for <code>--osp:log-level=info</code> and enable debug output on <code>cout</code>, error output on <code>cerr</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>--osp:vv</code></td>
<td style="text-align: left;">shortcut for <code>--osp:log-level=debug</code> and enable debug output on <code>cout</code>, error output on <code>cerr</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>--osp:load-modules=&lt;name&gt;[,...]</code></td>
<td style="text-align: left;">load one or more modules during initialization; equivalent to calling <code>ospLoadModule(name)</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>--osp:log-output=&lt;dst&gt;</code></td>
<td style="text-align: left;">convenience for setting where status messages go; valid values for <code>dst</code> are <code>cerr</code> and <code>cout</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>--osp:error-output=&lt;dst&gt;</code></td>
<td style="text-align: left;">convenience for setting where error messages go; valid values for <code>dst</code> are <code>cerr</code> and <code>cout</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>--osp:device=&lt;name&gt;</code></td>
<td style="text-align: left;">use <code>name</code> as the type of device for OSPRay to create; e.g., <code>--osp:device=cpu</code> gives you the default <code>cpu</code> device; Note if the device to be used is defined in a module, remember to pass <code>--osp:load-modules=&lt;name&gt;</code> first</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>--osp:set-affinity=&lt;n&gt;</code></td>
<td style="text-align: left;">if <code>1</code>, bind software threads to hardware threads; <code>0</code> disables binding; default is <code>1</code> on KNL and <code>0</code> otherwise</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>--osp:device-params=&lt;param&gt;:&lt;value&gt;[,...]</code></td>
<td style="text-align: left;">set one or more other device parameters; equivalent to calling <code>ospDeviceSet*(param, value)</code></td>
</tr>
</tbody>
</table>
<h3 id="manual-device-instantiation">Manual Device Instantiation</h3>
<p>The second method of initialization is to explicitly create the device and possibly set parameters. This method looks almost identical to how other <a href="#objects">objects</a> are created and used by OSPRay (described in later sections). The first step is to create the device with</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1"></a>OSPDevice ospNewDevice(<span class="at">const</span> <span class="dt">char</span> *type);</span></code></pre></div>
<p>where the <code>type</code> string maps to a specific device implementation. OSPRay always provides the “<code>cpu</code>” device, which maps to a fast, local CPU implementation. Other devices can also be added through additional modules, such as distributed MPI device implementations.</p>
<p>Once a device is created, you can call</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1"></a><span class="dt">void</span> ospDeviceSet1i(OSPDevice, <span class="at">const</span> <span class="dt">char</span> *id, <span class="dt">int</span> val);</span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="dt">void</span> ospDeviceSetString(OSPDevice, <span class="at">const</span> <span class="dt">char</span> *id, <span class="at">const</span> <span class="dt">char</span> *val);</span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="dt">void</span> ospDeviceSetVoidPtr(OSPDevice, <span class="at">const</span> <span class="dt">char</span> *id, <span class="dt">void</span> *val);</span></code></pre></div>
<p>to set parameters on the device. The following parameters can be set on all devices:</p>
<table style="width:97%;">
<caption>Parameters shared by all devices.</caption>
<colgroup>
<col style="width: 11%" />
<col style="width: 18%" />
<col style="width: 67%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">int</td>
<td style="text-align: left;">numThreads</td>
<td style="text-align: left;">number of threads which OSPRay should use</td>
</tr>
<tr class="even">
<td style="text-align: left;">string</td>
<td style="text-align: left;">logLevel</td>
<td style="text-align: left;">logging level; valid values (in order of severity) are <code>none</code>, <code>error</code>, <code>warning</code>, <code>info</code>, and <code>debug</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">string</td>
<td style="text-align: left;">logOutput</td>
<td style="text-align: left;">convenience for setting where status messages go; valid values are <code>cerr</code> and <code>cout</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">string</td>
<td style="text-align: left;">errorOutput</td>
<td style="text-align: left;">convenience for setting where error messages go; valid values are <code>cerr</code> and <code>cout</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">bool</td>
<td style="text-align: left;">debug</td>
<td style="text-align: left;">set debug mode; equivalent to <code>logLevel=debug</code> and <code>numThreads=1</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">bool</td>
<td style="text-align: left;">warnAsError</td>
<td style="text-align: left;">send <code>warning</code> and <code>error</code> messages through the error callback, otherwise send <code>warning</code> messages through the message callback; must have sufficient <code>logLevel</code> to enable warnings</td>
</tr>
<tr class="odd">
<td style="text-align: left;">bool</td>
<td style="text-align: left;">setAffinity</td>
<td style="text-align: left;">bind software threads to hardware threads if set to 1; 0 disables binding omitting the parameter will let OSPRay choose</td>
</tr>
</tbody>
</table>
<p>Once parameters are set on the created device, the device must be committed with</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1"></a><span class="dt">void</span> ospDeviceCommit(OSPDevice);</span></code></pre></div>
<p>To use the newly committed device, you must call</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1"></a><span class="dt">void</span> ospSetCurrentDevice(OSPDevice);</span></code></pre></div>
<p>This then sets the given device as the object which will respond to all other OSPRay API calls.</p>
<p>Users can change parameters on the device after initialization (from either method above), by calling</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1"></a>OSPDevice ospGetCurrentDevice();</span></code></pre></div>
<p>This function returns the handle to the device currently used to respond to OSPRay API calls, where users can set/change parameters and recommit the device. If changes are made to the device that is already set as the current device, it does not need to be set as current again.</p>
<p>OSPRay allows applications to query runtime properties of a device in order to do enhanced validation of what device was loaded at runtime. The following function can be used to get these device-specific properties (attiributes about the device, not paramter values)</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1"></a><span class="dt">int64_t</span> ospDeviceGetProperty(OSPDevice, OSPDeviceProperty);</span></code></pre></div>
<p>It returns an integer value of the queried property and the following properties can be provided as parameter:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1"></a>OSP_DEVICE_VERSION</span>
<span id="cb9-2"><a href="#cb9-2"></a>OSP_DEVICE_VERSION_MAJOR</span>
<span id="cb9-3"><a href="#cb9-3"></a>OSP_DEVICE_VERSION_MINOR</span>
<span id="cb9-4"><a href="#cb9-4"></a>OSP_DEVICE_VERSION_PATCH</span>
<span id="cb9-5"><a href="#cb9-5"></a>OSP_DEVICE_SO_VERSION</span></code></pre></div>
<h3 id="environment-variables">Environment Variables</h3>
<p>OSPRay’s generic device parameters can be overridden via environment variables for easy changes to OSPRay’s behavior without needing to change the application (variables are prefixed by convention with “<code>OSPRAY_</code>”):</p>
<table style="width:97%;">
<caption>Environment variables interpreted by OSPRay.</caption>
<colgroup>
<col style="width: 33%" />
<col style="width: 64%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Variable</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">OSPRAY_NUM_THREADS</td>
<td style="text-align: left;">equivalent to <code>--osp:num-threads</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">OSPRAY_LOG_LEVEL</td>
<td style="text-align: left;">equivalent to <code>--osp:log-level</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSPRAY_LOG_OUTPUT</td>
<td style="text-align: left;">equivalent to <code>--osp:log-output</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">OSPRAY_ERROR_OUTPUT</td>
<td style="text-align: left;">equivalent to <code>--osp:error-output</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSPRAY_DEBUG</td>
<td style="text-align: left;">equivalent to <code>--osp:debug</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">OSPRAY_WARN_AS_ERROR</td>
<td style="text-align: left;">equivalent to <code>--osp:warn-as-error</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSPRAY_SET_AFFINITY</td>
<td style="text-align: left;">equivalent to <code>--osp:set-affinity</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">OSPRAY_LOAD_MODULES</td>
<td style="text-align: left;">equivalent to <code>--osp:load-modules</code>, can be a comma separated list of modules which will be loaded in order</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSPRAY_DEVICE</td>
<td style="text-align: left;">equivalent to <code>--osp:device:</code></td>
</tr>
</tbody>
</table>
<p>Note that these environment variables take precedence over values specified through <code>ospInit</code> or manually set device parameters.</p>
<h3 id="error-handling-and-status-messages">Error Handling and Status Messages</h3>
<p>The following errors are currently used by OSPRay:</p>
<table>
<caption>Possible error codes, i.e., valid named constants of type <code>OSPError</code>.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">OSP_NO_ERROR</td>
<td style="text-align: left;">no error occurred</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_UNKNOWN_ERROR</td>
<td style="text-align: left;">an unknown error occurred</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_INVALID_ARGUMENT</td>
<td style="text-align: left;">an invalid argument was specified</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_INVALID_OPERATION</td>
<td style="text-align: left;">the operation is not allowed for the specified object</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_OUT_OF_MEMORY</td>
<td style="text-align: left;">there is not enough memory to execute the command</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_UNSUPPORTED_CPU</td>
<td style="text-align: left;">the CPU is not supported (minimum ISA is SSE4.1)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_VERSION_MISMATCH</td>
<td style="text-align: left;">a module could not be loaded due to mismatching version</td>
</tr>
</tbody>
</table>
<p>These error codes are either directly return by some API functions, or are recorded to be later queried by the application via</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1"></a>OSPError ospDeviceGetLastErrorCode(OSPDevice);</span></code></pre></div>
<p>A more descriptive error message can be queried by calling</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1"></a><span class="at">const</span> <span class="dt">char</span>* ospDeviceGetLastErrorMsg(OSPDevice);</span></code></pre></div>
<p>Alternatively, the application can also register a callback function of type</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1"></a><span class="kw">typedef</span> <span class="dt">void</span> (*OSPErrorFunc)(OSPError, <span class="at">const</span> <span class="dt">char</span>* errorDetails);</span></code></pre></div>
<p>via</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1"></a><span class="dt">void</span> ospDeviceSetErrorFunc(OSPDevice, OSPErrorFunc);</span></code></pre></div>
<p>to get notified when errors occur.</p>
<p>Applications may be interested in messages which OSPRay emits, whether for debugging or logging events. Applications can call</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1"></a><span class="dt">void</span> ospDeviceSetStatusFunc(OSPDevice, OSPStatusFunc);</span></code></pre></div>
<p>in order to register a callback function of type</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1"></a><span class="kw">typedef</span> <span class="dt">void</span> (*OSPStatusFunc)(<span class="at">const</span> <span class="dt">char</span>* messageText);</span></code></pre></div>
<p>which OSPRay will use to emit status messages. By default, OSPRay uses a callback which does nothing, so any output desired by an application will require that a callback is provided. Note that callbacks for C++ <code>std::cout</code> and <code>std::cerr</code> can be alternatively set through <code>ospInit()</code> or the <code>OSPRAY_LOG_OUTPUT</code> environment variable.</p>
<p>Applications can clear either callback by passing <code>nullptr</code> instead of an actual function pointer.</p>
<h3 id="loading-ospray-extensions-at-runtime">Loading OSPRay Extensions at Runtime</h3>
<p>OSPRay’s functionality can be extended via plugins (which we call “modules”), which are implemented in shared libraries. To load module <code>name</code> from <code>libospray_module_&lt;name&gt;.so</code> (on Linux and Mac OS X) or <code>ospray_module_&lt;name&gt;.dll</code> (on Windows) use</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1"></a>OSPError ospLoadModule(<span class="at">const</span> <span class="dt">char</span> *name);</span></code></pre></div>
<p>Modules are searched in OS-dependent paths. <code>ospLoadModule</code> returns <code>OSP_NO_ERROR</code> if the plugin could be successfully loaded.</p>
<h3 id="shutting-down-ospray">Shutting Down OSPRay</h3>
<p>When the application is finished using OSPRay (typically on application exit), the OSPRay API should be finalized with</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1"></a><span class="dt">void</span> ospShutdown();</span></code></pre></div>
<p>This API call ensures that the current device is cleaned up appropriately. Due to static object allocation having non-deterministic ordering, it is recommended that applications call <code>ospShutdown()</code> before the calling application process terminates.</p>
<h2 id="objects">Objects</h2>
<p>All entities of OSPRay (the renderer, volumes, geometries, lights, cameras, …) are a logical specialization of <code>OSPObject</code> and share common mechanism to deal with parameters and lifetime.</p>
<p>An important aspect of object parameters is that parameters do not get passed to objects immediately. Instead, parameters are not visible at all to objects until they get explicitly committed to a given object via a call to</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1"></a><span class="dt">void</span> ospCommit(OSPObject);</span></code></pre></div>
<p>at which time all previously additions or changes to parameters are visible at the same time. If a user wants to change the state of an existing object (e.g., to change the origin of an already existing camera) it is perfectly valid to do so, as long as the changed parameters are recommitted.</p>
<p>The commit semantic allow for batching up multiple small changes, and specifies exactly when changes to objects will occur. This can impact performance and consistency for devices crossing a PCI bus or across a network.</p>
<p>Note that OSPRay uses reference counting to manage the lifetime of all objects, so one cannot explicitly “delete” any object. Instead, to indicate that the application does not need and does not access the given object anymore, call</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1"></a><span class="dt">void</span> ospRelease(OSPObject);</span></code></pre></div>
<p>This decreases its reference count and if the count reaches <code>0</code> the object will automatically get deleted. Passing <code>NULL</code> is not an error.</p>
<p>Sometimes applications may want to have more than one reference to an object, where it is desirable for the application to increment the reference count of an object. This is done with</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb20-1"><a href="#cb20-1"></a><span class="dt">void</span> ospRetain(OSPObject);</span></code></pre></div>
<p>It is important to note that this is only necessary if the application wants to call <code>ospRelease</code> on an object more than once: objects which contain other objects as parameters internally increment/decrement ref counts and should not be explicitly done by the application.</p>
<h3 id="parameters">Parameters</h3>
<p>Parameters allow to configure the behavior of and to pass data to objects. However, objects do <em>not</em> have an explicit interface for reasons of high flexibility and a more stable compile-time API. Instead, parameters are passed separately to objects in an arbitrary order, and unknown parameters will simply be ignored (though a warning message will be posted). The following function allows adding various types of parameters with name <code>id</code> to a given object:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb21-1"><a href="#cb21-1"></a><span class="dt">void</span> ospSetParam(OSPObject, <span class="at">const</span> <span class="dt">char</span> *id, OSPDataType type, <span class="at">const</span> <span class="dt">void</span> *mem);</span></code></pre></div>
<p>The valid parameter names for all <code>OSPObject</code>s and what types are valid are discussed in future sections.</p>
<p>Note that <code>mem</code> must always be a pointer <em>to</em> the object, otherwise accidental type casting can occur. This is especially true for pointer types (<code>OSP_VOID_PTR</code> and <code>OSPObject</code> handles), as they will implicitly cast to <code>void *</code>, but be incorrectly interpreted. To help with some of these issues, there also exist variants of <code>ospSetParam</code> for specific types, such as <code>ospSetInt</code> and <code>ospSetVec3f</code> in the OSPRay utility library (found in <code>ospray_util.h</code>).</p>
<p>Users can also remove parameters that have been explicitly set from <code>ospSetParam</code>. Any parameters which have been removed will go back to their default value during the next commit unless a new parameter was set after the parameter was removed. To remove a parameter, use</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb22-1"><a href="#cb22-1"></a><span class="dt">void</span> ospRemoveParam(OSPObject, <span class="at">const</span> <span class="dt">char</span> *id);</span></code></pre></div>
<h3 id="data">Data</h3>
<p>OSPRay consumes data arrays from the application using a specific object type, <code>OSPData</code>. There are several components to describing a data array: element type, 1/2/3 dimensional striding, and whether the array is shared with the application or copied into opaque, OSPRay-owned memory.</p>
<p>Shared data arrays require that the application’s array memory outlives the lifetime of the created <code>OSPData</code>, as OSPRay is referring to application memory. Where this is not preferable, applications use opaque arrays to allow the <code>OSPData</code> to own the lifetime of the array memory. However, opaque arrays dictate the cost of copying data into it, which should be kept in mind.</p>
<p>Thus the most efficient way to specify a data array from the application is to created a shared data array, which is done with</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb23-1"><a href="#cb23-1"></a>OSPData ospNewSharedData(<span class="at">const</span> <span class="dt">void</span> *sharedData,</span>
<span id="cb23-2"><a href="#cb23-2"></a>                   OSPDataType,</span>
<span id="cb23-3"><a href="#cb23-3"></a>  <span class="dt">uint64_t</span> numItems1,</span>
<span id="cb23-4"><a href="#cb23-4"></a>  <span class="dt">int64_t</span> byteStride1 = <span class="dv">0</span>,</span>
<span id="cb23-5"><a href="#cb23-5"></a>  <span class="dt">uint64_t</span> numItems2 = <span class="dv">1</span>,</span>
<span id="cb23-6"><a href="#cb23-6"></a>  <span class="dt">int64_t</span> byteStride2 = <span class="dv">0</span>,</span>
<span id="cb23-7"><a href="#cb23-7"></a>  <span class="dt">uint64_t</span> numItems3 = <span class="dv">1</span>,</span>
<span id="cb23-8"><a href="#cb23-8"></a>  <span class="dt">int64_t</span> byteStride3 = <span class="dv">0</span>);</span></code></pre></div>
<p>The call returns an <code>OSPData</code> handle to the created array. The calling program guarantees that the <code>sharedData</code> pointer will remain valid for the duration that this data array is being used. The number of elements <code>numItems</code> must be positive (there cannot be an empty data object). The data is arranged in three dimensions, with specializations to two or one dimension (if some <code>numItems</code> are 1). The distance between consecutive elements (per dimension) is given in bytes with <code>byteStride</code> and can also be negative. If <code>byteStride</code> is zero it will be determined automatically (e.g., as <code>sizeof(type)</code>). Strides do not need to be ordered, i.e., <code>byteStride2</code> can be smaller than <code>byteStride1</code>, which is equivalent to a transpose. However, if the stride should be calculated, then an ordering like <code>byteStride1 &lt; byteStride2</code> is assumed to disambiguate.</p>
<p>The enum type <code>OSPDataType</code> describes the different element types that can be represented in OSPRay; valid constants are listed in the table below.</p>
<table>
<caption>Valid named constants for <code>OSPDataType</code>.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Type/Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">OSP_DEVICE</td>
<td style="text-align: left;">API device object reference</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_DATA</td>
<td style="text-align: left;">data reference</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_OBJECT</td>
<td style="text-align: left;">generic object reference</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_CAMERA</td>
<td style="text-align: left;">camera object reference</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_FRAMEBUFFER</td>
<td style="text-align: left;">framebuffer object reference</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_LIGHT</td>
<td style="text-align: left;">light object reference</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_MATERIAL</td>
<td style="text-align: left;">material object reference</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_TEXTURE</td>
<td style="text-align: left;">texture object reference</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_RENDERER</td>
<td style="text-align: left;">renderer object reference</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_WORLD</td>
<td style="text-align: left;">world object reference</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_GEOMETRY</td>
<td style="text-align: left;">geometry object reference</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_VOLUME</td>
<td style="text-align: left;">volume object reference</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_TRANSFER_FUNCTION</td>
<td style="text-align: left;">transfer function object reference</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_IMAGE_OPERATION</td>
<td style="text-align: left;">image operation object reference</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_STRING</td>
<td style="text-align: left;">C-style zero-terminated character string</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_CHAR</td>
<td style="text-align: left;">8 bit signed character scalar</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_UCHAR</td>
<td style="text-align: left;">8 bit unsigned character scalar</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_VEC[234]UC</td>
<td style="text-align: left;">… and [234]-element vector</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_USHORT</td>
<td style="text-align: left;">16 bit unsigned integer scalar</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_INT</td>
<td style="text-align: left;">32 bit signed integer scalar</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_VEC[234]I</td>
<td style="text-align: left;">… and [234]-element vector</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_UINT</td>
<td style="text-align: left;">32 bit unsigned integer scalar</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_VEC[234]UI</td>
<td style="text-align: left;">… and [234]-element vector</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_LONG</td>
<td style="text-align: left;">64 bit signed integer scalar</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_VEC[234]L</td>
<td style="text-align: left;">… and [234]-element vector</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_ULONG</td>
<td style="text-align: left;">64 bit unsigned integer scalar</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_VEC[234]UL</td>
<td style="text-align: left;">… and [234]-element vector</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_FLOAT</td>
<td style="text-align: left;">32 bit single precision floating-point scalar</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_VEC[234]F</td>
<td style="text-align: left;">… and [234]-element vector</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_DOUBLE</td>
<td style="text-align: left;">64 bit double precision floating-point scalar</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_BOX[1234]I</td>
<td style="text-align: left;">32 bit integer box (lower + upper bounds)</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_BOX[1234]F</td>
<td style="text-align: left;">32 bit single precision floating-point box (lower + upper bounds)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_LINEAR[234]F</td>
<td style="text-align: left;">32 bit single precision floating-point linear transform</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_AFFINE[234]F</td>
<td style="text-align: left;">32 bit single precision floating-point affine transform</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_VOID_PTR</td>
<td style="text-align: left;">raw memory address (only found in module extensions)</td>
</tr>
</tbody>
</table>
<p>An opaque <code>OSPData</code> with memory allocated by OSPRay is created with</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb24-1"><a href="#cb24-1"></a>OSPData ospNewData(OSPDataType,</span>
<span id="cb24-2"><a href="#cb24-2"></a>  <span class="dt">uint32_t</span> numItems1,</span>
<span id="cb24-3"><a href="#cb24-3"></a>  <span class="dt">uint32_t</span> numItems2 = <span class="dv">1</span>,</span>
<span id="cb24-4"><a href="#cb24-4"></a>  <span class="dt">uint32_t</span> numItems3 = <span class="dv">1</span>);</span></code></pre></div>
<p>To allow for (partial) copies or updates of data arrays use</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb25-1"><a href="#cb25-1"></a><span class="dt">void</span> ospCopyData(<span class="at">const</span> OSPData source,</span>
<span id="cb25-2"><a href="#cb25-2"></a>  OSPData destination,</span>
<span id="cb25-3"><a href="#cb25-3"></a>  <span class="dt">uint32_t</span> destinationIndex1 = <span class="dv">0</span>,</span>
<span id="cb25-4"><a href="#cb25-4"></a>  <span class="dt">uint32_t</span> destinationIndex2 = <span class="dv">0</span>,</span>
<span id="cb25-5"><a href="#cb25-5"></a>  <span class="dt">uint32_t</span> destinationIndex3 = <span class="dv">0</span>);</span></code></pre></div>
<p>which will copy the whole<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> content of the <code>source</code> array into <code>destination</code> at the given location <code>destinationIndex</code>. The <code>OSPDataType</code>s of the data objects must match. The region to be copied must be valid inside the destination, i.e., in all dimensions, <code>destinationIndex + sourceSize &lt;= destinationSize</code>. The affected region <code>[destinationIndex, destinationIndex + sourceSize)</code> is marked as dirty, which may be used by OSPRay to only process or update that sub-region (e.g., updating an acceleration structure). If the destination array is shared with OSPData by the application (created with <code>ospNewSharedData</code>), then</p>
<ul>
<li>the source array must be shared as well (thus <code>ospCopyData</code> cannot be used to read opaque data)</li>
<li>if source and destination memory overlaps (aliasing), then behaviour is undefined</li>
<li>except if source and destination regions are identical (including matching strides), which can be used by application to mark that region as dirty (instead of the whole <code>OSPData</code>)</li>
</ul>
<p>To add a data array as parameter named <code>id</code> to another object call also use</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb26-1"><a href="#cb26-1"></a><span class="dt">void</span> ospSetObject(OSPObject, <span class="at">const</span> <span class="dt">char</span> *id, OSPData);</span></code></pre></div>
<h2 id="volumes">Volumes</h2>
<p>Volumes are volumetric data sets with discretely sampled values in 3D space, typically a 3D scalar field. To create a new volume object of given type <code>type</code> use</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb27-1"><a href="#cb27-1"></a>OSPVolume ospNewVolume(<span class="at">const</span> <span class="dt">char</span> *type);</span></code></pre></div>
<p>Note that OSPRay’s implementation forwards <code>type</code> directly to Open VKL, allowing new Open VKL volume types to be usable within OSPRay without the need to change (or even recompile) OSPRay.</p>
<h3 id="structured-regular-volume">Structured Regular Volume</h3>
<p>Structured volumes only need to store the values of the samples, because their addresses in memory can be easily computed from a 3D position. A common type of structured volumes are regular grids.</p>
<p>Structured regular volumes are created by passing the <code>structuredRegular</code> type string to <code>ospNewVolume</code>. Structured volumes are represented through an <code>OSPData</code> 3D array <code>data</code> (which may or may not be shared with the application), where currently the voxel data needs to be laid out compact in memory in xyz-order<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<p>The parameters understood by structured volumes are summarized in the table below.</p>
<table>
<caption>Additional configuration parameters for structured regular volumes.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: right;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">gridOrigin</td>
<td style="text-align: right;"><span class="math inline">(0, 0, 0)</span></td>
<td style="text-align: left;">origin of the grid in object-space</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">gridSpacing</td>
<td style="text-align: right;"><span class="math inline">(1, 1, 1)</span></td>
<td style="text-align: left;">size of the grid cells in object-space</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSPData</td>
<td style="text-align: left;">data</td>
<td style="text-align: right;"></td>
<td style="text-align: left;">the actual voxel 3D <a href="#data">data</a></td>
</tr>
</tbody>
</table>
<p>The size of the volume is inferred from the size of the 3D array <code>data</code>, as is the type of the voxel values (currently supported are: <code>OSP_UCHAR</code>, <code>OSP_SHORT</code>, <code>OSP_USHORT</code>, <code>OSP_FLOAT</code>, and <code>OSP_DOUBLE</code>).</p>
<h3 id="structured-spherical-volume">Structured Spherical Volume</h3>
<p>Structured spherical volumes are also supported, which are created by passing a type string of <code>"structuredSpherical"</code> to <code>ospNewVolume</code>. The grid dimensions and parameters are defined in terms of radial distance <span class="math inline"><em>r</em></span>, inclination angle <span class="math inline"><em>θ</em></span>, and azimuthal angle <span class="math inline"><em>ϕ</em></span>, conforming with the ISO convention for spherical coordinate systems. The coordinate system and parameters understood by structured spherical volumes are summarized below.</p>
<figure>
<img src="images/structured_spherical_coords.svg" style="width:60.0%" alt="" /><figcaption>Coordinate system of structured spherical volumes.</figcaption>
</figure>
<table>
<caption>Additional configuration parameters for structured spherical volumes.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: center;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">gridOrigin</td>
<td style="text-align: center;"><span class="math inline">(0, 0, 0)</span></td>
<td style="text-align: left;">origin of the grid in units of <span class="math inline">(<em>r</em>, <em>θ</em>, <em>ϕ</em>)</span>; angles in degrees</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">gridSpacing</td>
<td style="text-align: center;"><span class="math inline">(1, 1, 1)</span></td>
<td style="text-align: left;">size of the grid cells in units of <span class="math inline">(<em>r</em>, <em>θ</em>, <em>ϕ</em>)</span>; angles in degrees</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSPData</td>
<td style="text-align: left;">data</td>
<td style="text-align: center;"></td>
<td style="text-align: left;">the actual voxel 3D <a href="#data">data</a></td>
</tr>
</tbody>
</table>
<p>The dimensions <span class="math inline">(<em>r</em>, <em>θ</em>, <em>ϕ</em>)</span> of the volume are inferred from the size of the 3D array <code>data</code>, as is the type of the voxel values (currently supported are: <code>OSP_UCHAR</code>, <code>OSP_SHORT</code>, <code>OSP_USHORT</code>, <code>OSP_FLOAT</code>, and <code>OSP_DOUBLE</code>).</p>
<p>These grid parameters support flexible specification of spheres, hemispheres, spherical shells, spherical wedges, and so forth. The grid extents (computed as <code>[gridOrigin, gridOrigin + (dimensions - 1) * gridSpacing]</code>) however must be constrained such that:</p>
<ul>
<li><span class="math inline"><em>r</em> ≥ 0</span></li>
<li><span class="math inline">0 ≤ <em>θ</em> ≤ 180</span></li>
<li><span class="math inline">0 ≤ <em>ϕ</em> ≤ 360</span></li>
</ul>
<h3 id="adaptive-mesh-refinement-amr-volume">Adaptive Mesh Refinement (AMR) Volume</h3>
<p>OSPRay currently supports block-structured (Berger-Colella) AMR volumes. Volumes are specified as a list of blocks, which exist at levels of refinement in potentially overlapping regions. Blocks exist in a tree structure, with coarser refinement level blocks containing finer blocks. The cell width is equal for all blocks at the same refinement level, though blocks at a coarser level have a larger cell width than finer levels.</p>
<p>There can be any number of refinement levels and any number of blocks at any level of refinement. An AMR volume type is created by passing the type string <code>"amr"</code> to <code>ospNewVolume</code>.</p>
<p>Blocks are defined by three parameters: their bounds, the refinement level in which they reside, and the scalar data contained within each block.</p>
<p>Note that cell widths are defined <em>per refinement level</em>, not per block.</p>
<table style="width:98%;">
<caption>Additional configuration parameters for AMR volumes.</caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 17%" />
<col style="width: 23%" />
<col style="width: 35%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: right;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>OSPAMRMethod</code></td>
<td style="text-align: left;">method</td>
<td style="text-align: right;"><code>OSP_AMR_CURRENT</code></td>
<td style="text-align: left;"><code>OSPAMRMethod</code> sampling method. Supported methods are:</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: right;"></td>
<td style="text-align: left;"><code>OSP_AMR_CURRENT</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: right;"></td>
<td style="text-align: left;"><code>OSP_AMR_FINEST</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: right;"></td>
<td style="text-align: left;"><code>OSP_AMR_OCTANT</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">float[]</td>
<td style="text-align: left;">cellWidth</td>
<td style="text-align: right;">NULL</td>
<td style="text-align: left;">array of each level’s cell width</td>
</tr>
<tr class="even">
<td style="text-align: left;">box3f[]</td>
<td style="text-align: left;">block.bounds</td>
<td style="text-align: right;">NULL</td>
<td style="text-align: left;"><a href="#data">data</a> array of bounds for each AMR block</td>
</tr>
<tr class="odd">
<td style="text-align: left;">int[]</td>
<td style="text-align: left;">block.level</td>
<td style="text-align: right;">NULL</td>
<td style="text-align: left;">array of each block’s refinement level</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSPData[]</td>
<td style="text-align: left;">block.data</td>
<td style="text-align: right;">NULL</td>
<td style="text-align: left;"><a href="#data">data</a> array of OSPData containing the actual scalar voxel data</td>
</tr>
<tr class="odd">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">gridOrigin</td>
<td style="text-align: right;"><span class="math inline">(0, 0, 0)</span></td>
<td style="text-align: left;">origin of the grid in world-space</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">gridSpacing</td>
<td style="text-align: right;"><span class="math inline">(1, 1, 1)</span></td>
<td style="text-align: left;">size of the grid cells in world-space</td>
</tr>
</tbody>
</table>
<p>Lastly, note that the <code>gridOrigin</code> and <code>gridSpacing</code> parameters act just like the structured volume equivalent, but they only modify the root (coarsest level) of refinement.</p>
<p>In particular, OSPRay’s AMR implementation was designed to cover Berger-Colella [1] and Chombo [2] AMR data. The <code>method</code> parameter above determines the interpolation method used when sampling the volume.</p>
<ul>
<li><code>OSP_AMR_CURRENT</code> finds the finest refinement level at that cell and interpolates through this “current” level</li>
<li><code>OSP_AMR_FINEST</code> will interpolate at the closest existing cell in the volume-wide finest refinement level regardless of the sample cell’s level</li>
<li><code>OSP_AMR_OCTANT</code> interpolates through all available refinement levels</li>
<li>at that cell. This method avoids discontinuities at refinement level boundaries at the cost of performance</li>
</ul>
<p>Details and more information can be found in the publication for the implementation [3].</p>
<ol type="1">
<li>M. J. Berger, and P. Colella. “Local adaptive mesh refinement for shock hydrodynamics.” Journal of Computational Physics 82.1 (1989): 64-84. DOI: 10.1016/0021-9991(89)90035-1</li>
<li>M. Adams, P. Colella, D. T. Graves, J.N. Johnson, N.D. Keen, T. J. Ligocki. D. F. Martin. P.W. McCorquodale, D. Modiano. P.O. Schwartz, T.D. Sternberg and B. Van Straalen, Chombo Software Package for AMR Applications - Design Document, Lawrence Berkeley National Laboratory Technical Report LBNL-6616E.</li>
<li>I. Wald, C. Brownlee, W. Usher, and A. Knoll. CPU volume rendering of adaptive mesh refinement data. SIGGRAPH Asia 2017 Symposium on Visualization on - SA ’17, 18(8), 1–8. DOI: 10.1145/3139295.3139305</li>
</ol>
<h3 id="unstructured-volume">Unstructured Volume</h3>
<p>Unstructured volumes can have their topology and geometry freely defined. Geometry can be composed of tetrahedral, hexahedral, wedge or pyramid cell types. The data format used is compatible with VTK and consists of multiple arrays: vertex positions and values, vertex indices, cell start indices, cell types, and cell values. An unstructured volume type is created by passing the type string “<code>unstructured</code>” to <code>ospNewVolume</code>.</p>
<p>Sampled cell values can be specified either per-vertex (<code>vertex.data</code>) or per-cell (<code>cell.data</code>). If both arrays are set, <code>cell.data</code> takes precedence.</p>
<p>Similar to a mesh, each cell is formed by a group of indices into the vertices. For each vertex, the corresponding (by array index) data value will be used for sampling when rendering, if specified. The index order for a tetrahedron is the same as <code>VTK_TETRA</code>: bottom triangle counterclockwise, then the top vertex.</p>
<p>For hexahedral cells, each hexahedron is formed by a group of eight indices into the vertices and data values. Vertex ordering is the same as <code>VTK_HEXAHEDRON</code>: four bottom vertices counterclockwise, then top four counterclockwise.</p>
<p>For wedge cells, each wedge is formed by a group of six indices into the vertices and data values. Vertex ordering is the same as <code>VTK_WEDGE</code>: three bottom vertices counterclockwise, then top three counterclockwise.</p>
<p>For pyramid cells, each cell is formed by a group of five indices into the vertices and data values. Vertex ordering is the same as <code>VTK_PYRAMID</code>: four bottom vertices counterclockwise, then the top vertex.</p>
<p>To maintain VTK data compatibility an index array may be specified via the <code>indexPrefixed</code> array that allow vertex indices to be interleaved with cell sizes in the following format: <span class="math inline"><em>n</em>, <em>i</em><em>d</em><sub>1</sub>, ..., <em>i</em><em>d</em><sub><em>n</em></sub>, <em>m</em>, <em>i</em><em>d</em><sub>1</sub>, ..., <em>i</em><em>d</em><sub><em>m</em></sub></span>.</p>
<table style="width:98%;">
<caption>Additional configuration parameters for unstructured volumes.</caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 25%" />
<col style="width: 12%" />
<col style="width: 38%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">vec3f[]</td>
<td style="text-align: left;">vertex.position</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><a href="#data">data</a> array of vertex positions</td>
</tr>
<tr class="even">
<td style="text-align: left;">float[]</td>
<td style="text-align: left;">vertex.data</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><a href="#data">data</a> array of vertex data values to be sampled</td>
</tr>
<tr class="odd">
<td style="text-align: left;">uint32[] / uint64[]</td>
<td style="text-align: left;">index</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><a href="#data">data</a> array of indices (into the vertex array(s)) that form cells</td>
</tr>
<tr class="even">
<td style="text-align: left;">uint32[] / uint64[]</td>
<td style="text-align: left;">indexPrefixed</td>
<td style="text-align: left;"></td>
<td style="text-align: left;">alternative <a href="#data">data</a> array of indices compatible to VTK, where the indices of each cell are prefixed with the number of vertices</td>
</tr>
<tr class="odd">
<td style="text-align: left;">uint32[] / uint64[]</td>
<td style="text-align: left;">cell.index</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><a href="#data">data</a> array of locations (into the index array), specifying the first index of each cell</td>
</tr>
<tr class="even">
<td style="text-align: left;">float[]</td>
<td style="text-align: left;">cell.data</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><a href="#data">data</a> array of cell data values to be sampled</td>
</tr>
<tr class="odd">
<td style="text-align: left;">uint8[]</td>
<td style="text-align: left;">cell.type</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><a href="#data">data</a> array of cell types (VTK compatible). Supported types are:</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><code>OSP_TETRAHEDRON</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><code>OSP_HEXAHEDRON</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><code>OSP_WEDGE</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><code>OSP_PYRAMID</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">bool</td>
<td style="text-align: left;">hexIterative</td>
<td style="text-align: left;">false</td>
<td style="text-align: left;">hexahedron interpolation method, defaults to fast non-iterative version which could have rendering inaccuracies may appear if hex is not parallelepiped</td>
</tr>
<tr class="odd">
<td style="text-align: left;">bool</td>
<td style="text-align: left;">precomputedNormals</td>
<td style="text-align: left;">true</td>
<td style="text-align: left;">whether to accelerate by precomputing, at a cost of 12 bytes/face</td>
</tr>
</tbody>
</table>
<h3 id="transfer-function">Transfer Function</h3>
<p>Transfer functions map the scalar values of volumes to color and opacity and thus they can be used to visually emphasize certain features of the volume. To create a new transfer function of given type <code>type</code> use</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb28-1"><a href="#cb28-1"></a>OSPTransferFunction ospNewTransferFunction(<span class="at">const</span> <span class="dt">char</span> *type);</span></code></pre></div>
<p>The returned handle can be assigned to a volumetric model (described below) as parameter “<code>transferFunction</code>” using <code>ospSetObject</code>.</p>
<p>One type of transfer function that is supported by OSPRay is the linear transfer function, which interpolates between given equidistant colors and opacities. It is create by passing the string “<code>piecewiseLinear</code>” to <code>ospNewTransferFunction</code> and it is controlled by these parameters:</p>
<table>
<caption>Parameters accepted by the linear transfer function.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">vec3f[]</td>
<td style="text-align: left;">color</td>
<td style="text-align: left;"><a href="#data">data</a> array of RGB colors</td>
</tr>
<tr class="even">
<td style="text-align: left;">float[]</td>
<td style="text-align: left;">opacity</td>
<td style="text-align: left;"><a href="#data">data</a> array of opacities</td>
</tr>
<tr class="odd">
<td style="text-align: left;">vec2f</td>
<td style="text-align: left;">valueRange</td>
<td style="text-align: left;">domain (scalar range) this function maps from</td>
</tr>
</tbody>
</table>
<h3 id="volumetricmodels">VolumetricModels</h3>
<p>Volumes in OSPRay are given volume rendering appearance information through VolumetricModels. This decouples the physical representation of the volume (and possible acceleration structures it contains) to rendering-specific parameters (where more than one set may exist concurrently). To create a volume instance, call</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb29-1"><a href="#cb29-1"></a>OSPVolumetricModel ospNewVolumetricModel(OSPVolume volume);</span></code></pre></div>
<table style="width:98%;">
<caption>Parameters understood by VolumetricModel.</caption>
<colgroup>
<col style="width: 25%" />
<col style="width: 22%" />
<col style="width: 11%" />
<col style="width: 37%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">OSPTransferFunction</td>
<td style="text-align: left;">transferFunction</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><a href="#transfer-function">transfer function</a> to use</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">densityScale</td>
<td style="text-align: left;">1.0</td>
<td style="text-align: left;">makes volumes uniformly thinner or thicker</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">anisotropy</td>
<td style="text-align: left;">0.0</td>
<td style="text-align: left;">anisotropy of the (Henyey-Greenstein) phase function in [-1, 1] (<a href="#path-tracer">path tracer</a> only), default to isotropic scattering</td>
</tr>
</tbody>
</table>
<h2 id="geometries">Geometries</h2>
<p>Geometries in OSPRay are objects that describe intersectable surfaces. To create a new geometry object of given type <code>type</code> use</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb30-1"><a href="#cb30-1"></a>OSPGeometry ospNewGeometry(<span class="at">const</span> <span class="dt">char</span> *type);</span></code></pre></div>
<p>Note that in the current implementation geometries are limited to a maximum of 2<sup>32</sup> primitives.</p>
<h3 id="mesh">Mesh</h3>
<p>A mesh consiting of either triangles or quads is created by calling <code>ospNewGeometry</code> with type string “<code>mesh</code>”. Once created, a mesh recognizes the following parameters:</p>
<table>
<caption>Parameters defining a mesh geometry.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">vec3f[]</td>
<td style="text-align: left;">vertex.position</td>
<td style="text-align: left;"><a href="#data">data</a> array of vertex positions</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec3f[]</td>
<td style="text-align: left;">vertex.normal</td>
<td style="text-align: left;"><a href="#data">data</a> array of vertex normals</td>
</tr>
<tr class="odd">
<td style="text-align: left;">vec4f[] / vec3f[]</td>
<td style="text-align: left;">vertex.color</td>
<td style="text-align: left;"><a href="#data">data</a> array of vertex colors (RGBA/RGB)</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec2f[]</td>
<td style="text-align: left;">vertex.texcoord</td>
<td style="text-align: left;"><a href="#data">data</a> array of vertex texture coordinates</td>
</tr>
<tr class="odd">
<td style="text-align: left;">vec3ui[] / vec4ui[]</td>
<td style="text-align: left;">index</td>
<td style="text-align: left;"><a href="#data">data</a> array of (either triangle or quad) indices (into the vertex array(s))</td>
</tr>
</tbody>
</table>
<p>The data type of index arrays differentiates between the underlying geometry, triangles are used for a index with <code>vec3ui</code> type and quads for <code>vec4ui</code> type. Quads are internally handled as a pair of two triangles, thus mixing triangles and quads is supported by encoding some triangle as a quad with the last two vertex indices being identical (<code>w=z</code>).</p>
<p>The <code>vertex.position</code> and <code>index</code> arrays are mandatory to create a valid mesh.</p>
<h3 id="subdivision">Subdivision</h3>
<p>A mesh consisting of subdivision surfaces, created by specifying a geometry of type “<code>subdivision</code>”. Once created, a subdivision recognizes the following parameters:</p>
<table style="width:98%;">
<caption>Parameters defining a Subdivision geometry.</caption>
<colgroup>
<col style="width: 11%" />
<col style="width: 20%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: right;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">vec3f[]</td>
<td style="text-align: left;">vertex.position</td>
<td style="text-align: right;">NULL</td>
<td style="text-align: left;"><a href="#data">data</a> array of vertex positions</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec4f[]</td>
<td style="text-align: left;">vertex.color</td>
<td style="text-align: right;">NULL</td>
<td style="text-align: left;"><a href="#data">data</a> array of vertex colors (RGBA)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">vec2f[]</td>
<td style="text-align: left;">vertex.texcoord</td>
<td style="text-align: right;">NULL</td>
<td style="text-align: left;"><a href="#data">data</a> array of vertex texture coordinates</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">level</td>
<td style="text-align: right;"></td>
<td style="text-align: left;">5 global level of tessellation, default is 5</td>
</tr>
<tr class="odd">
<td style="text-align: left;">uint[]</td>
<td style="text-align: left;">index</td>
<td style="text-align: right;">NULL</td>
<td style="text-align: left;"><a href="#data">data</a> array of indices (into the vertex array(s))</td>
</tr>
<tr class="even">
<td style="text-align: left;">float[]</td>
<td style="text-align: left;">index.level</td>
<td style="text-align: right;">NULL</td>
<td style="text-align: left;"><a href="#data">data</a> array of per-edge levels of tessellation, overrides global level</td>
</tr>
<tr class="odd">
<td style="text-align: left;">uint[]</td>
<td style="text-align: left;">face</td>
<td style="text-align: right;">NULL</td>
<td style="text-align: left;"><a href="#data">data</a> array holding the number of indices/edges (3 to 15) per face</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec2i[]</td>
<td style="text-align: left;">edgeCrease.index</td>
<td style="text-align: right;">NULL</td>
<td style="text-align: left;"><a href="#data">data</a> array of edge crease indices</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float[]</td>
<td style="text-align: left;">edgeCrease.weight</td>
<td style="text-align: right;">NULL</td>
<td style="text-align: left;"><a href="#data">data</a> array of edge crease weights</td>
</tr>
<tr class="even">
<td style="text-align: left;">uint[]</td>
<td style="text-align: left;">vertexCrease.index</td>
<td style="text-align: right;">NULL</td>
<td style="text-align: left;"><a href="#data">data</a> array of vertex crease indices</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float[]</td>
<td style="text-align: left;">vertexCrease.weight</td>
<td style="text-align: right;">NULL</td>
<td style="text-align: left;"><a href="#data">data</a> array of vertex crease weights</td>
</tr>
<tr class="even">
<td style="text-align: left;">int</td>
<td style="text-align: left;">mode</td>
<td style="text-align: right;"><code>OSP_SUBDIVISION_SMOOTH_BOUNDARY</code></td>
<td style="text-align: left;">subdivision edge boundary mode. Supported modes are:</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: right;"></td>
<td style="text-align: left;"><code>OSP_SUBDIVISION_NO_BOUNDARY</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: right;"></td>
<td style="text-align: left;"><code>OSP_SUBDIVISION_SMOOTH_BOUNDARY</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: right;"></td>
<td style="text-align: left;"><code>OSP_SUBDIVISION_PIN_CORNERS</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: right;"></td>
<td style="text-align: left;"><code>OSP_SUBDIVISION_PIN_BOUNDARY</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: right;"></td>
<td style="text-align: left;"><code>OSP_SUBDIVISION_PIN_ALL</code></td>
</tr>
</tbody>
</table>
<p>The <code>vertex</code> and <code>index</code> arrays are mandatory to create a valid subdivision surface. If no <code>face</code> array is present then a pure quad mesh is assumed (the number of indices must be a multiple of 4). Optionally supported are edge and vertex creases.</p>
<h3 id="spheres">Spheres</h3>
<p>A geometry consisting of individual spheres, each of which can have an own radius, is created by calling <code>ospNewGeometry</code> with type string “<code>sphere</code>”. The spheres will not be tessellated but rendered procedurally and are thus perfectly round. To allow a variety of sphere representations in the application this geometry allows a flexible way of specifying the data of center position and radius within a <a href="#data">data</a> array:</p>
<table style="width:97%;">
<caption>Parameters defining a spheres geometry.</caption>
<colgroup>
<col style="width: 15%" />
<col style="width: 22%" />
<col style="width: 12%" />
<col style="width: 46%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: right;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">vec3f[]</td>
<td style="text-align: left;">sphere.position</td>
<td style="text-align: right;"></td>
<td style="text-align: left;"><a href="#data">data</a> array of center positions</td>
</tr>
<tr class="even">
<td style="text-align: left;">float[]</td>
<td style="text-align: left;">sphere.radius</td>
<td style="text-align: right;">NULL</td>
<td style="text-align: left;">optional <a href="#data">data</a> array of the per-sphere radius</td>
</tr>
<tr class="odd">
<td style="text-align: left;">vec2f[]</td>
<td style="text-align: left;">sphere.texcoord</td>
<td style="text-align: right;">NULL</td>
<td style="text-align: left;">optional <a href="#data">data</a> array of texture coordinates (constant per sphere)</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">radius</td>
<td style="text-align: right;">0.01</td>
<td style="text-align: left;">default radius for all spheres (if <code>sphere.radius</code> is not set)</td>
</tr>
</tbody>
</table>
<h3 id="curves">Curves</h3>
<p>A geometry consisting of multiple curves is created by calling <code>ospNewGeometry</code> with type string “<code>curve</code>”. The parameters defining this geometry are listed in the table below.</p>
<table style="width:98%;">
<caption>Parameters defining a curves geometry.</caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 32%" />
<col style="width: 45%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">vec4f[]</td>
<td style="text-align: left;">vertex.position_radius</td>
<td style="text-align: left;"><a href="#data">data</a> array of vertex position and per-vertex radius</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec3f[]</td>
<td style="text-align: left;">vertex.position</td>
<td style="text-align: left;"><a href="#data">data</a> array of vertex position</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">radius</td>
<td style="text-align: left;">global radius of all curves (if per-vertex radius is not used), default 0.01</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec2f[]</td>
<td style="text-align: left;">vertex.texcoord</td>
<td style="text-align: left;"><a href="#data">data</a> array of per-vertex texture coordinates</td>
</tr>
<tr class="odd">
<td style="text-align: left;">vec4f[]</td>
<td style="text-align: left;">vertex.color</td>
<td style="text-align: left;"><a href="#data">data</a> array of corresponding vertex colors (RGBA)</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec3f[]</td>
<td style="text-align: left;">vertex.normal</td>
<td style="text-align: left;"><a href="#data">data</a> array of curve normals (only for “ribbon” curves)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">vec3f[]</td>
<td style="text-align: left;">vertex.tangent</td>
<td style="text-align: left;"><a href="#data">data</a> array of curve tangents (only for “hermite” curves)</td>
</tr>
<tr class="even">
<td style="text-align: left;">uint32[]</td>
<td style="text-align: left;">index</td>
<td style="text-align: left;"><a href="#data">data</a> array of indices to the first vertex or tangent of a curve segment</td>
</tr>
<tr class="odd">
<td style="text-align: left;">int</td>
<td style="text-align: left;">type</td>
<td style="text-align: left;"><code>OSPCurveType</code> for rendering the curve. Supported types are:</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><code>OSP_FLAT</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><code>OSP_ROUND</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><code>OSP_RIBBON</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">int</td>
<td style="text-align: left;">basis</td>
<td style="text-align: left;"><code>OSPCurveBasis</code> for defining the curve. Supported bases are:</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><code>OSP_LINEAR</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><code>OSP_BEZIER</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><code>OSP_BSPLINE</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><code>OSP_HERMITE</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><code>OSP_CATMULL_ROM</code></td>
</tr>
</tbody>
</table>
<p>Depending upon the specified data type of vertex positions, the curves will be implemented Embree curves or assembled from rounded and linearly-connected segments.</p>
<p>Positions in <code>vertex.position_radius</code> format supports per-vertex varying radii with data type <code>vec4f[]</code> and instantiate Embree curves internally for the relevant type/basis mapping (See Embree documentation for discussion of curve types and data formatting).</p>
<p>If a constant <code>radius</code> is used and positions are specified in a <code>vec3f[]</code> type of <code>vertex.position</code> format, then type/basis defaults to <code>OSP_ROUND</code> and <code>OSP_LINEAR</code> (this is the fastest and most memory efficient mode). Implementation is with round linear segements where each segment corresponds to a link between two vertices.</p>
<p>The following section describes the properties of different curve basis’ and how they use the data provided in data buffers:</p>
<dl>
<dt>OSP_LINEAR</dt>
<dd>The indices point to the first of 2 consecutive control points in the vertex buffer. The first control point is the start and the second control point the end of the line segment. The curve goes through all control points listed in the vertex buffer.
</dd>
<dt>OSP_BEZIER</dt>
<dd>The indices point to the first of 4 consecutive control points in the vertex buffer. The first control point represents the start point of the curve, and the 4th control point the end point of the curve. The Bézier basis is interpolating, thus the curve does go exactly through the first and fourth control vertex.
</dd>
<dt>OSP_BSPLINE</dt>
<dd>The indices point to the first of 4 consecutive control points in the vertex buffer. This basis is not interpolating, thus the curve does in general not go through any of the control points directly. Using this basis, 3 control points can be shared for two continuous neighboring curve segments, e.g. the curves <span class="math inline">(<em>p</em>0, <em>p</em>1, <em>p</em>2, <em>p</em>3)</span> and <span class="math inline">(<em>p</em>1, <em>p</em>2, <em>p</em>3, <em>p</em>4)</span> are C1 continuous. This feature make this basis a good choice to construct continuous multi-segment curves, as memory consumption can be kept minimal.
</dd>
<dt>OSP_HERMITE</dt>
<dd>It is necessary to have both vertex buffer and tangent buffer for using this basis. The indices point to the first of 2 consecutive points in the vertex buffer, and the first of 2 consecutive tangents in the tangent buffer. This basis is interpolating, thus does exactly go through the first and second control point, and the first order derivative at the begin and end matches exactly the value specified in the tangent buffer. When connecting two segments continuously, the end point and tangent of the previous segment can be shared.
</dd>
<dt>OSP_CATMULL_ROM</dt>
<dd>The indices point to the first of 4 consecutive control points in the vertex buffer. If <span class="math inline">(<em>p</em>0, <em>p</em>1, <em>p</em>2, <em>p</em>3)</span> represent the points then this basis goes through <span class="math inline"><em>p</em>1</span> and <span class="math inline"><em>p</em>2</span>, with tangents as <span class="math inline">(<em>p</em>2 − <em>p</em>0)/2</span> and <span class="math inline">(<em>p</em>3 − <em>p</em>1)/2</span>.
</dd>
</dl>
<p>The following section describes the properties of different curve types’ and how they define the geometry of a curve:</p>
<dl>
<dt>OSP_FLAT</dt>
<dd>This type enables faster rendering as the curve is rendered as a connected sequence of ray facing quads.
</dd>
<dt>OSP_ROUND</dt>
<dd>This type enables rendering a real geometric surface for the curve which allows closeup views. This mode renders a sweep surface by sweeping a varying radius circle tangential along the curve.
</dd>
<dt>OSP_RIBBON</dt>
<dd>The type enables normal orientation of the curve and requires a normal buffer be specified along with vertex buffer. The curve is rendered as a flat band whose center approximately follows the provided vertex buffer and whose normal orientation approximately follows the provided normal buffer.
</dd>
</dl>
<h3 id="boxes">Boxes</h3>
<p>OSPRay can directly render axis-aligned bounding boxes without the need to convert them to quads or triangles. To do so create a boxes geometry by calling <code>ospNewGeometry</code> with type string “<code>box</code>”.</p>
<table>
<caption>Parameters defining a boxes geometry.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">box3f[]</td>
<td style="text-align: left;">box</td>
<td style="text-align: left;"><a href="#data">data</a> array of boxes</td>
</tr>
</tbody>
</table>
<h3 id="isosurfaces">Isosurfaces</h3>
<p>OSPRay can directly render multiple isosurfaces of a volume without first tessellating them. To do so create an isosurfaces geometry by calling <code>ospNewGeometry</code> with type string “<code>isosurface</code>”. Each isosurface will be colored according to the <a href="#transfer-function">transfer function</a> assigned to the <code>volume</code>.</p>
<table>
<caption>Parameters defining an isosurfaces geometry.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">isovalue</td>
<td style="text-align: left;">single isovalues</td>
</tr>
<tr class="even">
<td style="text-align: left;">float[]</td>
<td style="text-align: left;">isovalue</td>
<td style="text-align: left;"><a href="#data">data</a> array of isovalues</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSPVolumetricModel</td>
<td style="text-align: left;">volume</td>
<td style="text-align: left;">handle of the <a href="#volumetricmodels">VolumetricModels</a> to be isosurfaced</td>
</tr>
</tbody>
</table>
<h3 id="geometricmodels">GeometricModels</h3>
<p>Geometries are matched with surface appearance information through GeometricModels. These take a geometry, which defines the surface representation, and applies either full-object or per-primitive color and material information. To create a geometric model, call</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb31-1"><a href="#cb31-1"></a>OSPGeometricModel ospNewGeometricModel(OSPGeometry geometry);</span></code></pre></div>
<p>Color and material are fetched with the primitive ID of the hit (clamped to the valid range, thus a single color or material is fine), or mapped first via the <code>index</code> array (if present). All paramters are optional, however, some renderers (notably the <a href="#path-tracer">path tracer</a>) require a material to be set. Materials are either handles of <code>OSPMaterial</code>, or indices into the <code>material</code> array on the <a href="#renderers">renderer</a>, which allows to build a <a href="#world">world</a> which can be used by different types of renderers.</p>
<table style="width:97%;">
<caption>Parameters understood by GeometricModel.</caption>
<colgroup>
<col style="width: 26%" />
<col style="width: 14%" />
<col style="width: 56%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">OSPMaterial / uint32</td>
<td style="text-align: left;">material</td>
<td style="text-align: left;">optional <a href="#materials">material</a> applied to the geometry, may be an index into the <code>material</code> parameter on the <a href="#renderers">renderer</a> (if it exists)</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSPMaterial[] / uint32[]</td>
<td style="text-align: left;">material</td>
<td style="text-align: left;">optional <a href="#data">data</a> array of (per-primitive) materials, may be an index into the <code>material</code> parameter on the renderer (if it exists)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">vec4f[]</td>
<td style="text-align: left;">color</td>
<td style="text-align: left;">optional <a href="#data">data</a> array of (per-primitive) colors</td>
</tr>
<tr class="even">
<td style="text-align: left;">uint8[]</td>
<td style="text-align: left;">index</td>
<td style="text-align: left;">optional <a href="#data">data</a> array of per-primitive indices into <code>color</code> and <code>material</code></td>
</tr>
</tbody>
</table>
<h2 id="lights">Lights</h2>
<p>To create a new light source of given type <code>type</code> use</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb32-1"><a href="#cb32-1"></a>OSPLight ospNewLight(<span class="at">const</span> <span class="dt">char</span> *type);</span></code></pre></div>
<p>All light sources accept the following parameters:</p>
<table>
<caption>Parameters accepted by all lights.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: right;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">color</td>
<td style="text-align: right;">white</td>
<td style="text-align: left;">color of the light</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">intensity</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">intensity of the light (a factor)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">bool</td>
<td style="text-align: left;">visible</td>
<td style="text-align: right;">true</td>
<td style="text-align: left;">whether the light can be directly seen</td>
</tr>
</tbody>
</table>
<p>The following light types are supported by most OSPRay renderers.</p>
<h3 id="directional-light-distant-light">Directional Light / Distant Light</h3>
<p>The distant light (or traditionally the directional light) is thought to be far away (outside of the scene), thus its light arrives (almost) as parallel rays. It is created by passing the type string “<code>distant</code>” to <code>ospNewLight</code>. In addition to the <a href="#lights">general parameters</a> understood by all lights the distant light supports the following special parameters:</p>
<table>
<caption>Special parameters accepted by the distant light.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">direction</td>
<td style="text-align: left;">main emission direction of the distant light</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">angularDiameter</td>
<td style="text-align: left;">apparent size (angle in degree) of the light</td>
</tr>
</tbody>
</table>
<p>Setting the angular diameter to a value greater than zero will result in soft shadows when the renderer uses stochastic sampling (like the <a href="#path-tracer">path tracer</a>). For instance, the apparent size of the sun is about 0.53°.</p>
<h3 id="point-light-sphere-light">Point Light / Sphere Light</h3>
<p>The sphere light (or the special case point light) is a light emitting uniformly in all directions from the surface towards the outside. It does not emit any light towards the inside of the sphere. It is created by passing the type string “<code>sphere</code>” to <code>ospNewLight</code>. In addition to the <a href="#lights">general parameters</a> understood by all lights the sphere light supports the following special parameters:</p>
<table>
<caption>Special parameters accepted by the sphere light.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">position</td>
<td style="text-align: left;">the center of the sphere light, in world-space</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">radius</td>
<td style="text-align: left;">the size of the sphere light</td>
</tr>
</tbody>
</table>
<p>Setting the radius to a value greater than zero will result in soft shadows when the renderer uses stochastic sampling (like the <a href="#path-tracer">path tracer</a>).</p>
<h3 id="spotlight">Spotlight</h3>
<p>The spotlight is a light emitting into a cone of directions. It is created by passing the type string “<code>spot</code>” to <code>ospNewLight</code>. In addition to the <a href="#lights">general parameters</a> understood by all lights the spotlight supports the special parameters listed in the table.</p>
<table style="width:98%;">
<caption>Special parameters accepted by the spotlight.</caption>
<colgroup>
<col style="width: 9%" />
<col style="width: 19%" />
<col style="width: 17%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">position</td>
<td style="text-align: left;"><span class="math inline">(0, 0, 0)</span></td>
<td style="text-align: left;">the center of the spotlight, in world-space</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">direction</td>
<td style="text-align: left;"><span class="math inline">(0, 0, 1)</span></td>
<td style="text-align: left;">main emission direction of the spot</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">openingAngle</td>
<td style="text-align: left;">180</td>
<td style="text-align: left;">full opening angle (in degree) of the spot; outside of this cone is no illumination</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">penumbraAngle</td>
<td style="text-align: left;">5</td>
<td style="text-align: left;">size (angle in degree) of the “penumbra”, the region between the rim (of the illumination cone) and full intensity of the spot; should be smaller than half of <code>openingAngle</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">radius</td>
<td style="text-align: left;">0</td>
<td style="text-align: left;">the size of the spotlight, the radius of a disk with normal <code>direction</code></td>
</tr>
</tbody>
</table>
<figure>
<img src="images/spot_light.png" alt="" /><figcaption>Angles used by the spotlight.</figcaption>
</figure>
<p>Setting the radius to a value greater than zero will result in soft shadows when the renderer uses stochastic sampling (like the <a href="#path-tracer">path tracer</a>).</p>
<h3 id="quad-light">Quad Light</h3>
<p>The quad<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> light is a planar, procedural area light source emitting uniformly on one side into the half-space. It is created by passing the type string “<code>quad</code>” to <code>ospNewLight</code>. In addition to the <a href="#lights">general parameters</a> understood by all lights the quad light supports the following special parameters:</p>
<table>
<caption>Special parameters accepted by the quad light.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">position</td>
<td style="text-align: left;">world-space position of one vertex of the quad light</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">edge1</td>
<td style="text-align: left;">vector to one adjacent vertex</td>
</tr>
<tr class="odd">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">edge2</td>
<td style="text-align: left;">vector to the other adjacent vertex</td>
</tr>
</tbody>
</table>
<figure>
<img src="images/quad_light.png" alt="" /><figcaption>Defining a quad light which emits toward the reader.</figcaption>
</figure>
<p>The emission side is determined by the cross product of <code>edge1</code>×<code>edge2</code>. Note that only renderers that use stochastic sampling (like the path tracer) will compute soft shadows from the quad light. Other renderers will just sample the center of the quad light, which results in hard shadows.</p>
<h3 id="hdri-light">HDRI Light</h3>
<p>The HDRI light is a textured light source surrounding the scene and illuminating it from infinity. It is created by passing the type string “<code>hdri</code>” to <code>ospNewLight</code>. In addition to the <a href="#lights">general parameters</a> the HDRI light supports the following special parameters:</p>
<table style="width:97%;">
<caption>Special parameters accepted by the HDRI light.</caption>
<colgroup>
<col style="width: 17%" />
<col style="width: 16%" />
<col style="width: 64%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">up</td>
<td style="text-align: left;">up direction of the light in world-space</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">direction</td>
<td style="text-align: left;">direction to which the center of the texture will be mapped to (analog to <a href="#panoramic-camera">panoramic camera</a>)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSPTexture</td>
<td style="text-align: left;">map</td>
<td style="text-align: left;">environment map in latitude / longitude format</td>
</tr>
</tbody>
</table>
<figure>
<img src="images/hdri_light.png" alt="" /><figcaption>Orientation and Mapping of an HDRI Light.</figcaption>
</figure>
<p>Note that the currently only the <a href="#path-tracer">path tracer</a> supports the HDRI light.</p>
<h3 id="ambient-light">Ambient Light</h3>
<p>The ambient light surrounds the scene and illuminates it from infinity with constant radiance (determined by combining the <a href="#lights">parameters <code>color</code> and <code>intensity</code></a>). It is created by passing the type string “<code>ambient</code>” to <code>ospNewLight</code>.</p>
<p>Note that the <a href="#scivis-renderer">SciVis renderer</a> uses ambient lights to control the color and intensity of the computed ambient occlusion (AO).</p>
<h3 id="emissive-objects">Emissive Objects</h3>
<p>The <a href="#path-tracer">path tracer</a> will consider illumination by <a href="#geometries">geometries</a> which have a light emitting material assigned (for example the <a href="#luminous">Luminous</a> material).</p>
<h2 id="scene-hierarchy">Scene Hierarchy</h2>
<h3 id="groups">Groups</h3>
<p>Groups in OSPRay represent collections of GeometricModels and VolumetricModels which share a common local-space coordinate system. To create a group call</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb33-1"><a href="#cb33-1"></a>OSPGroup ospNewGroup();</span></code></pre></div>
<p>Groups take arrays of geometric models and volumetric models, but they are optional. In other words, there is no need to create empty arrays if there are no geometries or volumes in the group.</p>
<table style="width:98%;">
<caption>Parameters understood by groups.</caption>
<colgroup>
<col style="width: 27%" />
<col style="width: 16%" />
<col style="width: 10%" />
<col style="width: 43%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: right;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">OSPGeometricModel[]</td>
<td style="text-align: left;">geometry</td>
<td style="text-align: right;">NULL</td>
<td style="text-align: left;"><a href="#data">data</a> array of <a href="#geometricmodels">GeometricModels</a></td>
</tr>
<tr class="even">
<td style="text-align: left;">OSPVolumetricModel[]</td>
<td style="text-align: left;">volume</td>
<td style="text-align: right;">NULL</td>
<td style="text-align: left;"><a href="#data">data</a> array of <a href="#volumetricmodels">VolumetricModels</a></td>
</tr>
<tr class="odd">
<td style="text-align: left;">bool</td>
<td style="text-align: left;">dynamicScene</td>
<td style="text-align: right;">false</td>
<td style="text-align: left;">use RTC_SCENE_DYNAMIC flag (faster BVH build, slower ray traversal), otherwise uses RTC_SCENE_STATIC flag (faster ray traversal, slightly slower BVH build)</td>
</tr>
<tr class="even">
<td style="text-align: left;">bool</td>
<td style="text-align: left;">compactMode</td>
<td style="text-align: right;">false</td>
<td style="text-align: left;">tell Embree to use a more compact BVH in memory by trading ray traversal performance</td>
</tr>
<tr class="odd">
<td style="text-align: left;">bool</td>
<td style="text-align: left;">robustMode</td>
<td style="text-align: right;">false</td>
<td style="text-align: left;">tell Embree to enable more robust ray intersection code paths (slightly slower)</td>
</tr>
</tbody>
</table>
<p>Note that groups only need to re re-committed if a geometry or volume changes (surface/scalar field representation). Appearance information on <code>OSPGeometricModel</code> and <code>OSPVolumetricModel</code> can be changed freely, as internal acceleration structures do not need to be reconstructed.</p>
<h3 id="instances">Instances</h3>
<p>Instances in OSPRay represent a single group’s placement into the world via a transform. To create and instance call</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb34-1"><a href="#cb34-1"></a>OSPInstance ospNewInstance(OSPGroup);</span></code></pre></div>
<table style="width:97%;">
<caption>Parameters understood by instances.</caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 18%" />
<col style="width: 16%" />
<col style="width: 41%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: right;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">affine3f</td>
<td style="text-align: left;">xfm</td>
<td style="text-align: right;">(identity)</td>
<td style="text-align: left;">world-space transform for all attached geometries and volumes</td>
</tr>
</tbody>
</table>
<h3 id="world">World</h3>
<p>Worlds are a container of scene data represented by <a href="#instances">instances</a>. To create an (empty) world call</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb35-1"><a href="#cb35-1"></a>OSPWorld ospNewWorld();</span></code></pre></div>
<p>Objects are placed in the world through an array of instances. Similar to [group], the array of instances is optional: there is no need to create empty arrays if there are no instances (though there will be nothing to render).</p>
<p>Applications can query the world (axis-aligned) bounding box after the world has been committed. To get this information, call</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb36-1"><a href="#cb36-1"></a>OSPBounds ospGetBounds(OSPObject);</span></code></pre></div>
<p>This call can also take <code>OSPGroup</code> and <code>OSPInstance</code> as well: all other object types will return an empty bounding box.</p>
<p>Finally, Worlds can be configured with parameters for making various feature/performance trade-offs (similar to groups).</p>
<table style="width:97%;">
<caption>Parameters understood by worlds.</caption>
<colgroup>
<col style="width: 22%" />
<col style="width: 18%" />
<col style="width: 12%" />
<col style="width: 43%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: right;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">OSPInstance[]</td>
<td style="text-align: left;">instance</td>
<td style="text-align: right;">NULL</td>
<td style="text-align: left;"><a href="#data">data</a> array with handles of the <a href="#instances">instances</a></td>
</tr>
<tr class="even">
<td style="text-align: left;">OSPLight[]</td>
<td style="text-align: left;">light</td>
<td style="text-align: right;">NULL</td>
<td style="text-align: left;"><a href="#data">data</a> array with handles of the <a href="#lights">lights</a></td>
</tr>
<tr class="odd">
<td style="text-align: left;">bool</td>
<td style="text-align: left;">dynamicScene</td>
<td style="text-align: right;">false</td>
<td style="text-align: left;">use RTC_SCENE_DYNAMIC flag (faster BVH build, slower ray traversal), otherwise uses RTC_SCENE_STATIC flag (faster ray traversal, slightly slower BVH build)</td>
</tr>
<tr class="even">
<td style="text-align: left;">bool</td>
<td style="text-align: left;">compactMode</td>
<td style="text-align: right;">false</td>
<td style="text-align: left;">tell Embree to use a more compact BVH in memory by trading ray traversal performance</td>
</tr>
<tr class="odd">
<td style="text-align: left;">bool</td>
<td style="text-align: left;">robustMode</td>
<td style="text-align: right;">false</td>
<td style="text-align: left;">tell Embree to enable more robust ray intersection code paths (slightly slower)</td>
</tr>
</tbody>
</table>
<h2 id="renderers">Renderers</h2>
<p>A renderer is the central object for rendering in OSPRay. Different renderers implement different features and support different materials. To create a new renderer of given type <code>type</code> use</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb37-1"><a href="#cb37-1"></a>OSPRenderer ospNewRenderer(<span class="at">const</span> <span class="dt">char</span> *type);</span></code></pre></div>
<p>General parameters of all renderers are</p>
<table style="width:98%;">
<caption>Parameters understood by all renderers.</caption>
<colgroup>
<col style="width: 19%" />
<col style="width: 21%" />
<col style="width: 15%" />
<col style="width: 41%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: right;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">int</td>
<td style="text-align: left;">pixelSamples</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">samples per pixel</td>
</tr>
<tr class="even">
<td style="text-align: left;">int</td>
<td style="text-align: left;">maxPathLength</td>
<td style="text-align: right;">20</td>
<td style="text-align: left;">maximum ray recursion depth</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">minContribution</td>
<td style="text-align: right;">0.001</td>
<td style="text-align: left;">sample contributions below this value will be neglected to speedup rendering</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">varianceThreshold</td>
<td style="text-align: right;">0</td>
<td style="text-align: left;">threshold for adaptive accumulation</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float / vec3f / vec4f</td>
<td style="text-align: left;">backgroundColor</td>
<td style="text-align: right;">black, transparent</td>
<td style="text-align: left;">background color and alpha (RGBA), if no map_backplate is set</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSPTexture</td>
<td style="text-align: left;">map_backplate</td>
<td style="text-align: right;"></td>
<td style="text-align: left;">optional <a href="#texture">texture</a> image used as background</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSPTexture</td>
<td style="text-align: left;">map_maxDepth</td>
<td style="text-align: right;"></td>
<td style="text-align: left;">optional screen-sized float <a href="#texture">texture</a> with maximum far distance per pixel (use texture type <code>texture2d</code>)</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSPMaterial[]</td>
<td style="text-align: left;">material</td>
<td style="text-align: right;"></td>
<td style="text-align: left;">optional <a href="#data">data</a> array of <a href="#materials">materials</a> which can be indexed by a <a href="#geometricmodels">GeometricModel</a>’s <code>material</code> parameter</td>
</tr>
</tbody>
</table>
<p>OSPRay’s renderers support a feature called adaptive accumulation, which accelerates progressive <a href="#rendering">rendering</a> by stopping the rendering and refinement of image regions that have an estimated variance below the <code>varianceThreshold</code>. This feature requires a <a href="#framebuffer">framebuffer</a> with an <code>OSP_FB_VARIANCE</code> channel.</p>
<p>Per default the background of the rendered image will be transparent black, i.e., the alpha channel holds the opacity of the rendered objects. This eases transparency-aware blending of the image with an arbitrary background image by the application. The parameter <code>backgroundColor</code> or <code>map_backplate</code> can be used to already blend with a constant background color or backplate texture, respectively, (and alpha) during rendering.</p>
<p>OSPRay renderers support depth composition with images of other renderers, for example to incorporate help geometries of a 3D UI that were rendered with OpenGL. The screen-sized <a href="#texture">texture</a> <code>map_maxDepth</code> must have format <code>OSP_TEXTURE_R32F</code> and flag <code>OSP_TEXTURE_FILTER_NEAREST</code>. The fetched values are used to limit the distance of primary rays, thus objects of other renderers can hide objects rendered by OSPRay.</p>
<h3 id="scivis-renderer">SciVis Renderer</h3>
<p>The SciVis renderer is a fast ray tracer for scientific visualization which supports volume rendering and ambient occlusion (AO). It is created by passing the type string “<code>scivis</code>” to <code>ospNewRenderer</code>. In addition to the <a href="#renderer">general parameters</a> understood by all renderers, the SciVis renderer supports the following parameters:</p>
<table style="width:97%;">
<caption>Special parameters understood by the SciVis renderer.</caption>
<colgroup>
<col style="width: 17%" />
<col style="width: 28%" />
<col style="width: 17%" />
<col style="width: 34%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: right;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">int</td>
<td style="text-align: left;">aoSamples</td>
<td style="text-align: right;">0</td>
<td style="text-align: left;">number of rays per sample to compute ambient occlusion</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">aoRadius</td>
<td style="text-align: right;">10<sup>20</sup></td>
<td style="text-align: left;">maximum distance to consider for ambient occlusion</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">aoIntensity</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">ambient occlusion strength</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">volumeSamplingRate</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">sampling rate for volumes</td>
</tr>
</tbody>
</table>
<h3 id="path-tracer">Path Tracer</h3>
<p>The path tracer supports soft shadows, indirect illumination and realistic materials. This renderer is created by passing the type string “<code>pathtracer</code>” to <code>ospNewRenderer</code>. In addition to the <a href="#renderer">general parameters</a> understood by all renderers the path tracer supports the following special parameters:</p>
<table style="width:97%;">
<caption>Special parameters understood by the path tracer.</caption>
<colgroup>
<col style="width: 14%" />
<col style="width: 25%" />
<col style="width: 12%" />
<col style="width: 44%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: right;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">bool</td>
<td style="text-align: left;">geometryLights</td>
<td style="text-align: right;">true</td>
<td style="text-align: left;">whether to render light emitted from geometries</td>
</tr>
<tr class="even">
<td style="text-align: left;">int</td>
<td style="text-align: left;">roulettePathLengt</td>
<td style="text-align: right;">h 5</td>
<td style="text-align: left;">ray recursion depth at which to start Russian roulette termination</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">maxContribution</td>
<td style="text-align: right;">∞</td>
<td style="text-align: left;">samples are clamped to this value before they are accumulated into the framebuffer</td>
</tr>
</tbody>
</table>
<p>The path tracer requires that <a href="#materials">materials</a> are assigned to <a href="#geometries">geometries</a>, otherwise surfaces are treated as completely black.</p>
<p>The path tracer supports <a href="#volumes">volumes</a> with multiple scattering. The scattering albedo can be specified using the <a href="#transfer-function">transfer function</a>. Extinction is assumed to be spectrally constant.</p>
<h3 id="materials">Materials</h3>
<p>Materials describe how light interacts with surfaces, they give objects their distinctive look. To let the given renderer create a new material of given type <code>type</code> call</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb38-1"><a href="#cb38-1"></a>OSPMaterial ospNewMaterial(<span class="at">const</span> <span class="dt">char</span> *<span class="dt">renderer_type</span>, <span class="at">const</span> <span class="dt">char</span> *<span class="dt">material_type</span>);</span></code></pre></div>
<p>The returned handle can then be used to assign the material to a given geometry with</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb39-1"><a href="#cb39-1"></a><span class="dt">void</span> ospSetObject(OSPGeometricModel, <span class="st">&quot;material&quot;</span>, OSPMaterial);</span></code></pre></div>
<h4 id="obj-material">OBJ Material</h4>
<p>The OBJ material is the workhorse material supported by both the <a href="#scivis-renderer">SciVis renderer</a> and the <a href="#path-tracer">path tracer</a>. It offers widely used common properties like diffuse and specular reflection and is based on the <a href="http://paulbourke.net/dataformats/mtl/">MTL material format</a> of Lightwave’s OBJ scene files. To create an OBJ material pass the type string “<code>obj</code>” to <code>ospNewMaterial</code>. Its main parameters are</p>
<table>
<caption>Main parameters of the OBJ material.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: right;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">kd</td>
<td style="text-align: right;">white 0.8</td>
<td style="text-align: left;">diffuse color</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">ks</td>
<td style="text-align: right;">black</td>
<td style="text-align: left;">specular color</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">ns</td>
<td style="text-align: right;">10</td>
<td style="text-align: left;">shininess (Phong exponent), usually in [2–10<sup>4</sup>]</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">d</td>
<td style="text-align: right;">opaque</td>
<td style="text-align: left;">opacity</td>
</tr>
<tr class="odd">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">tf</td>
<td style="text-align: right;">black</td>
<td style="text-align: left;">transparency filter color</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSPTexture</td>
<td style="text-align: left;">map_bump</td>
<td style="text-align: right;">NULL</td>
<td style="text-align: left;">normal map</td>
</tr>
</tbody>
</table>
<p>In particular when using the path tracer it is important to adhere to the principle of energy conservation, i.e., that the amount of light reflected by a surface is not larger than the light arriving. Therefore the path tracer issues a warning and renormalizes the color parameters if the sum of <code>Kd</code>, <code>Ks</code>, and <code>Tf</code> is larger than one in any color channel. Similarly important to mention is that almost all materials of the real world reflect at most only about 80% of the incoming light. So even for a white sheet of paper or white wall paint do better not set <code>Kd</code> larger than 0.8; otherwise rendering times are unnecessary long and the contrast in the final images is low (for example, the corners of a white room would hardly be discernible, as can be seen in the figure below).</p>
<figure>
<img src="images/diffuse_rooms.png" style="width:80.0%" alt="" /><figcaption>Comparison of diffuse rooms with 100% reflecting white paint (left) and realistic 80% reflecting white paint (right), which leads to higher overall contrast. Note that exposure has been adjusted to achieve similar brightness levels.</figcaption>
</figure>
<p>If present, the color component of <a href="#geometries">geometries</a> is also used for the diffuse color <code>Kd</code> and the alpha component is also used for the opacity <code>d</code>.</p>
<p>Note that currently only the path tracer implements colored transparency with <code>Tf</code>.</p>
<p>Normal mapping can simulate small geometric features via the texture <code>map_Bump</code>. The normals <span class="math inline"><em>n</em></span> in the normal map are with respect to the local tangential shading coordinate system and are encoded as <span class="math inline">½(<em>n</em> + 1)</span>, thus a texel <span class="math inline">(0.5, 0.5, 1)</span><a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> represents the unperturbed shading normal <span class="math inline">(0, 0, 1)</span>. Because of this encoding an sRGB gamma <a href="#texture">texture</a> format is ignored and normals are always fetched as linear from a normal map. Note that the orientation of normal maps is important for a visually consistent look: by convention OSPRay uses a coordinate system with the origin in the lower left corner; thus a convexity will look green toward the top of the texture image (see also the example image of a normal map). If this is not the case flip the normal map vertically or invert its green channel.</p>
<figure>
<img src="images/normalmap_frustum.png" style="width:60.0%" alt="" /><figcaption>Normal map representing an exalted square pyramidal frustum.</figcaption>
</figure>
<p>All parameters (except <code>Tf</code>) can be textured by passing a <a href="#texture">texture</a> handle, prefixed with “<code>map_</code>”. The fetched texels are multiplied by the respective parameter value. Texturing requires <a href="#geometries">geometries</a> with texture coordinates, e.g., a [triangle mesh] with <code>vertex.texcoord</code> provided. The color textures <code>map_Kd</code> and <code>map_Ks</code> are typically in one of the sRGB gamma encoded formats, whereas textures <code>map_Ns</code> and <code>map_d</code> are usually in a linear format (and only the first component is used). Additionally, all textures support <a href="#texture2d-transformations">texture transformations</a>.</p>
<figure>
<img src="images/material_OBJ.jpg" style="width:60.0%" alt="" /><figcaption>Rendering of a OBJ material with wood textures.</figcaption>
</figure>
<h4 id="principled">Principled</h4>
<p>The Principled material is the most complex material offered by the <a href="#path-tracer">path tracer</a>, which is capable of producing a wide variety of materials (e.g., plastic, metal, wood, glass) by combining multiple different layers and lobes. It uses the GGX microfacet distribution with approximate multiple scattering for dielectrics and metals, uses the Oren-Nayar model for diffuse reflection, and is energy conserving. To create a Principled material, pass the type string “<code>principled</code>” to <code>ospNewMaterial</code>. Its parameters are listed in the table below.</p>
<table style="width:98%;">
<caption>Parameters of the Principled material.</caption>
<colgroup>
<col style="width: 9%" />
<col style="width: 24%" />
<col style="width: 12%" />
<col style="width: 51%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: right;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">baseColor</td>
<td style="text-align: right;">white 0.8</td>
<td style="text-align: left;">base reflectivity (diffuse and/or metallic)</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">edgeColor</td>
<td style="text-align: right;">white</td>
<td style="text-align: left;">edge tint (metallic only)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">metallic</td>
<td style="text-align: right;">0</td>
<td style="text-align: left;">mix between dielectric (diffuse and/or specular) and metallic (specular only with complex IOR) in [0–1]</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">diffuse</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">diffuse reflection weight in [0–1]</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">specular</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">specular reflection/transmission weight in [0–1]</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">ior</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">dielectric index of refraction</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">transmission</td>
<td style="text-align: right;">0</td>
<td style="text-align: left;">specular transmission weight in [0–1]</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">transmissionColor</td>
<td style="text-align: right;">white</td>
<td style="text-align: left;">attenuated color due to transmission (Beer’s law)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">transmissionDepth</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">distance at which color attenuation is equal to transmissionColor</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">roughness</td>
<td style="text-align: right;">0</td>
<td style="text-align: left;">diffuse and specular roughness in [0–1], 0 is perfectly smooth</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">anisotropy</td>
<td style="text-align: right;">0</td>
<td style="text-align: left;">amount of specular anisotropy in [0–1]</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">rotation</td>
<td style="text-align: right;">0</td>
<td style="text-align: left;">rotation of the direction of anisotropy in [0–1], 1 is going full circle</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">normal</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">default normal map/scale for all layers</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">baseNormal</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">base normal map/scale (overrides default normal)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">bool</td>
<td style="text-align: left;">thin</td>
<td style="text-align: right;">false</td>
<td style="text-align: left;">flag specifying whether the material is thin or solid</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">thickness</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">thickness of the material (thin only), affects the amount of color attenuation due to specular transmission</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">backlight</td>
<td style="text-align: right;">0</td>
<td style="text-align: left;">amount of diffuse transmission (thin only) in [0–2], 1 is 50% reflection and 50% transmission, 2 is transmission only</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">coat</td>
<td style="text-align: right;">0</td>
<td style="text-align: left;">clear coat layer weight in [0–1]</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">coatIor</td>
<td style="text-align: right;">1.5</td>
<td style="text-align: left;">clear coat index of refraction</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">coatColor</td>
<td style="text-align: right;">white</td>
<td style="text-align: left;">clear coat color tint</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">coatThickness</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">clear coat thickness, affects the amount of color attenuation</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">coatRoughness</td>
<td style="text-align: right;">0</td>
<td style="text-align: left;">clear coat roughness in [0–1], 0 is perfectly smooth</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">coatNormal</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">clear coat normal map/scale (overrides default normal)</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">sheen</td>
<td style="text-align: right;">0</td>
<td style="text-align: left;">sheen layer weight in [0–1]</td>
</tr>
<tr class="odd">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">sheenColor</td>
<td style="text-align: right;">white</td>
<td style="text-align: left;">sheen color tint</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">sheenTint</td>
<td style="text-align: right;">0</td>
<td style="text-align: left;">how much sheen is tinted from sheenColor toward baseColor</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">sheenRoughness</td>
<td style="text-align: right;">0.2</td>
<td style="text-align: left;">sheen roughness in [0–1], 0 is perfectly smooth</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">opacity</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">cut-out opacity/transparency, 1 is fully opaque</td>
</tr>
</tbody>
</table>
<p>All parameters can be textured by passing a <a href="#texture">texture</a> handle, prefixed with “<code>map_</code>” (e.g., “<code>map_baseColor</code>”). <a href="#texture2d-transformations">texture transformations</a> are supported as well.</p>
<figure>
<img src="images/material_Principled.jpg" style="width:60.0%" alt="" /><figcaption>Rendering of a Principled coated brushed metal material with textured anisotropic rotation and a dust layer (sheen) on top.</figcaption>
</figure>
<h4 id="carpaint">CarPaint</h4>
<p>The CarPaint material is a specialized version of the Principled material for rendering different types of car paints. To create a CarPaint material, pass the type string “<code>carPaint</code>” to <code>ospNewMaterial</code>. Its parameters are listed in the table below.</p>
<table style="width:98%;">
<caption>Parameters of the CarPaint material.</caption>
<colgroup>
<col style="width: 10%" />
<col style="width: 22%" />
<col style="width: 12%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: right;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">baseColor</td>
<td style="text-align: right;">white 0.8</td>
<td style="text-align: left;">diffuse base reflectivity</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">roughness</td>
<td style="text-align: right;">0</td>
<td style="text-align: left;">diffuse roughness in [0–1], 0 is perfectly smooth</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">normal</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">normal map/scale</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">flakeDensity</td>
<td style="text-align: right;">0</td>
<td style="text-align: left;">density of metallic flakes in [0–1], 0 disables flakes, 1 fully covers the surface with flakes</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">flakeScale</td>
<td style="text-align: right;">100</td>
<td style="text-align: left;">scale of the flake structure, higher values increase the amount of flakes</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">flakeSpread</td>
<td style="text-align: right;">0.3</td>
<td style="text-align: left;">flake spread in [0–1]</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">flakeJitter</td>
<td style="text-align: right;">0.75</td>
<td style="text-align: left;">flake randomness in [0–1]</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">flakeRoughness</td>
<td style="text-align: right;">0.3</td>
<td style="text-align: left;">flake roughness in [0–1], 0 is perfectly smooth</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">coat</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">clear coat layer weight in [0–1]</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">coatIor</td>
<td style="text-align: right;">1.5</td>
<td style="text-align: left;">clear coat index of refraction</td>
</tr>
<tr class="odd">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">coatColor</td>
<td style="text-align: right;">white</td>
<td style="text-align: left;">clear coat color tint</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">coatThickness</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">clear coat thickness, affects the amount of color attenuation</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">coatRoughness</td>
<td style="text-align: right;">0</td>
<td style="text-align: left;">clear coat roughness in [0–1], 0 is perfectly smooth</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">coatNormal</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">clear coat normal map/scale</td>
</tr>
<tr class="odd">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">flipflopColor</td>
<td style="text-align: right;">white</td>
<td style="text-align: left;">reflectivity of coated flakes at grazing angle, used together with coatColor produces a pearlescent paint</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">flipflopFalloff</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">flip flop color falloff, 1 disables the flip flop effect</td>
</tr>
</tbody>
</table>
<p>All parameters can be textured by passing a <a href="#texture">texture</a> handle, prefixed with “<code>map_</code>” (e.g., “<code>map_baseColor</code>”). <a href="#texture2d-transformations">texture transformations</a> are supported as well.</p>
<figure>
<img src="images/material_CarPaint.jpg" style="width:60.0%" alt="" /><figcaption>Rendering of a pearlescent CarPaint material.</figcaption>
</figure>
<h4 id="metal">Metal</h4>
<p>The <a href="#path-tracer">path tracer</a> offers a physical metal, supporting changing roughness and realistic color shifts at edges. To create a Metal material pass the type string “<code>metal</code>” to <code>ospNewMaterial</code>. Its parameters are</p>
<table style="width:97%;">
<caption>Parameters of the Metal material.</caption>
<colgroup>
<col style="width: 15%" />
<col style="width: 15%" />
<col style="width: 15%" />
<col style="width: 51%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: right;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">vec3f[]</td>
<td style="text-align: left;">ior</td>
<td style="text-align: right;">Aluminium</td>
<td style="text-align: left;"><a href="#data">data</a> array of spectral samples of complex refractive index, each entry in the form (wavelength, eta, k), ordered by wavelength (which is in nm)</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">eta</td>
<td style="text-align: right;"></td>
<td style="text-align: left;">RGB complex refractive index, real part</td>
</tr>
<tr class="odd">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">k</td>
<td style="text-align: right;"></td>
<td style="text-align: left;">RGB complex refractive index, imaginary part</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">roughness</td>
<td style="text-align: right;">0.1</td>
<td style="text-align: left;">roughness in [0–1], 0 is perfect mirror</td>
</tr>
</tbody>
</table>
<p>The main appearance (mostly the color) of the Metal material is controlled by the physical parameters <code>eta</code> and <code>k</code>, the wavelength-dependent, complex index of refraction. These coefficients are quite counter-intuitive but can be found in <a href="https://refractiveindex.info/">published measurements</a>. For accuracy the index of refraction can be given as an array of spectral samples in <code>ior</code>, each sample a triplet of wavelength (in nm), eta, and k, ordered monotonically increasing by wavelength; OSPRay will then calculate the Fresnel in the spectral domain. Alternatively, <code>eta</code> and <code>k</code> can also be specified as approximated RGB coefficients; some examples are given in below table.</p>
<table>
<caption>Index of refraction of selected metals as approximated RGB coefficients, based on data from https://refractiveindex.info/.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Metal</th>
<th style="text-align: center;">eta</th>
<th style="text-align: center;">k</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Ag, Silver</td>
<td style="text-align: center;">(0.051, 0.043, 0.041)</td>
<td style="text-align: center;">(5.3, 3.6, 2.3)</td>
</tr>
<tr class="even">
<td style="text-align: left;">Al, Aluminium</td>
<td style="text-align: center;">(1.5, 0.98, 0.6)</td>
<td style="text-align: center;">(7.6, 6.6, 5.4)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Au, Gold</td>
<td style="text-align: center;">(0.07, 0.37, 1.5)</td>
<td style="text-align: center;">(3.7, 2.3, 1.7)</td>
</tr>
<tr class="even">
<td style="text-align: left;">Cr, Chromium</td>
<td style="text-align: center;">(3.2, 3.1, 2.3)</td>
<td style="text-align: center;">(3.3, 3.3, 3.1)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Cu, Copper</td>
<td style="text-align: center;">(0.1, 0.8, 1.1)</td>
<td style="text-align: center;">(3.5, 2.5, 2.4)</td>
</tr>
</tbody>
</table>
<p>The <code>roughness</code> parameter controls the variation of microfacets and thus how polished the metal will look. The roughness can be modified by a <a href="#texture">texture</a> <code>map_roughness</code> (<a href="#texture2d-transformations">texture transformations</a> are supported as well) to create notable edging effects.</p>
<figure>
<img src="images/material_Metal.jpg" style="width:60.0%" alt="" /><figcaption>Rendering of golden Metal material with textured roughness.</figcaption>
</figure>
<h4 id="alloy">Alloy</h4>
<p>The <a href="#path-tracer">path tracer</a> offers an alloy material, which behaves similar to <a href="#metal">Metal</a>, but allows for more intuitive and flexible control of the color. To create an Alloy material pass the type string “<code>alloy</code>” to <code>ospNewMaterial</code>. Its parameters are</p>
<table>
<caption>Parameters of the Alloy material.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: right;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">color</td>
<td style="text-align: right;">white 0.9</td>
<td style="text-align: left;">reflectivity at normal incidence (0 degree)</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">edgeColor</td>
<td style="text-align: right;">white</td>
<td style="text-align: left;">reflectivity at grazing angle (90 degree)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">roughness</td>
<td style="text-align: right;">0.1</td>
<td style="text-align: left;">roughness, in [0–1], 0 is perfect mirror</td>
</tr>
</tbody>
</table>
<p>The main appearance of the Alloy material is controlled by the parameter <code>color</code>, while <code>edgeColor</code> influences the tint of reflections when seen at grazing angles (for real metals this is always 100% white). If present, the color component of <a href="#geometries">geometries</a> is also used for reflectivity at normal incidence <code>color</code>. As in <a href="#metal">Metal</a> the <code>roughness</code> parameter controls the variation of microfacets and thus how polished the alloy will look. All parameters can be textured by passing a <a href="#texture">texture</a> handle, prefixed with “<code>map_</code>”; <a href="#texture2d-transformations">texture transformations</a> are supported as well.</p>
<figure>
<img src="images/material_Alloy.jpg" style="width:60.0%" alt="" /><figcaption>Rendering of a fictional Alloy material with textured color.</figcaption>
</figure>
<h4 id="glass">Glass</h4>
<p>The <a href="#path-tracer">path tracer</a> offers a realistic a glass material, supporting refraction and volumetric attenuation (i.e., the transparency color varies with the geometric thickness). To create a Glass material pass the type string “<code>glass</code>” to <code>ospNewMaterial</code>. Its parameters are</p>
<table>
<caption>Parameters of the Glass material.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: right;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">eta</td>
<td style="text-align: right;">1.5</td>
<td style="text-align: left;">index of refraction</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">attenuationColor</td>
<td style="text-align: right;">white</td>
<td style="text-align: left;">resulting color due to attenuation</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">attenuationDistance</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">distance affecting attenuation</td>
</tr>
</tbody>
</table>
<p>For convenience, the rather counter-intuitive physical attenuation coefficients will be calculated from the user inputs in such a way, that the <code>attenuationColor</code> will be the result when white light traveled trough a glass of thickness <code>attenuationDistance</code>.</p>
<figure>
<img src="images/material_Glass.jpg" style="width:60.0%" alt="" /><figcaption>Rendering of a Glass material with orange attenuation.</figcaption>
</figure>
<h4 id="thinglass">ThinGlass</h4>
<p>The <a href="#path-tracer">path tracer</a> offers a thin glass material useful for objects with just a single surface, most prominently windows. It models a thin, transparent slab, i.e., it behaves as if a second, virtual surface is parallel to the real geometric surface. The implementation accounts for multiple internal reflections between the interfaces (including attenuation), but neglects parallax effects due to its (virtual) thickness. To create a such a thin glass material pass the type string “<code>thinGlass</code>” to <code>ospNewMaterial</code>. Its parameters are</p>
<table>
<caption>Parameters of the ThinGlass material.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: right;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">eta</td>
<td style="text-align: right;">1.5</td>
<td style="text-align: left;">index of refraction</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">attenuationColor</td>
<td style="text-align: right;">white</td>
<td style="text-align: left;">resulting color due to attenuation</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">attenuationDistance</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">distance affecting attenuation</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">thickness</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">virtual thickness</td>
</tr>
</tbody>
</table>
<p>For convenience the attenuation is controlled the same way as with the <a href="#glass">Glass</a> material. Additionally, the color due to attenuation can be modulated with a <a href="#texture">texture</a> <code>map_attenuationColor</code> (<a href="#texture2d-transformations">texture transformations</a> are supported as well). If present, the color component of <a href="#geometries">geometries</a> is also used for the attenuation color. The <code>thickness</code> parameter sets the (virtual) thickness and allows for easy exchange of parameters with the (real) <a href="#glass">Glass</a> material; internally just the ratio between <code>attenuationDistance</code> and <code>thickness</code> is used to calculate the resulting attenuation and thus the material appearance.</p>
<figure>
<img src="images/material_ThinGlass.jpg" style="width:60.0%" alt="" /><figcaption>Rendering of a ThinGlass material with red attenuation.</figcaption>
</figure>
<figure>
<img src="images/ColoredWindow.jpg" style="width:60.0%" alt="" /><figcaption>Example image of a colored window made with textured attenuation of the ThinGlass material.</figcaption>
</figure>
<h4 id="metallicpaint">MetallicPaint</h4>
<p>The <a href="#path-tracer">path tracer</a> offers a metallic paint material, consisting of a base coat with optional flakes and a clear coat. To create a MetallicPaint material pass the type string “<code>metallicPaint</code>” to <code>ospNewMaterial</code>. Its parameters are listed in the table below.</p>
<table>
<caption>Parameters of the MetallicPaint material.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: right;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">baseColor</td>
<td style="text-align: right;">white 0.8</td>
<td style="text-align: left;">color of base coat</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">flakeAmount</td>
<td style="text-align: right;">0.3</td>
<td style="text-align: left;">amount of flakes, in [0–1]</td>
</tr>
<tr class="odd">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">flakeColor</td>
<td style="text-align: right;">Aluminium</td>
<td style="text-align: left;">color of metallic flakes</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">flakeSpread</td>
<td style="text-align: right;">0.5</td>
<td style="text-align: left;">spread of flakes, in [0–1]</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">eta</td>
<td style="text-align: right;">1.5</td>
<td style="text-align: left;">index of refraction of clear coat</td>
</tr>
</tbody>
</table>
<p>The color of the base coat <code>baseColor</code> can be textured by a <a href="#texture">texture</a> <code>map_baseColor</code>, which also supports <a href="#texture2d-transformations">texture transformations</a>. If present, the color component of <a href="#geometries">geometries</a> is also used for the color of the base coat. Parameter <code>flakeAmount</code> controls the proportion of flakes in the base coat, so when setting it to 1 the <code>baseColor</code> will not be visible. The shininess of the metallic component is governed by <code>flakeSpread</code>, which controls the variation of the orientation of the flakes, similar to the <code>roughness</code> parameter of <a href="#metal">Metal</a>. Note that the effect of the metallic flakes is currently only computed on average, thus individual flakes are not visible.</p>
<figure>
<img src="images/material_MetallicPaint.jpg" style="width:60.0%" alt="" /><figcaption>Rendering of a MetallicPaint material.</figcaption>
</figure>
<h4 id="luminous">Luminous</h4>
<p>The <a href="#path-tracer">path tracer</a> supports the Luminous material which emits light uniformly in all directions and which can thus be used to turn any geometric object into a light source. It is created by passing the type string “<code>Luminous</code>” to <code>ospNewMaterial</code>. The amount of constant radiance that is emitted is determined by combining the general parameters of lights: <a href="#lights"><code>color</code> and <code>intensity</code></a>.</p>
<table>
<caption>Parameters accepted by the Luminous material.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: right;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">color</td>
<td style="text-align: right;">white</td>
<td style="text-align: left;">color of the emitted light</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">intensity</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">intensity of the light (a factor)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">transparency</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">material transparency</td>
</tr>
</tbody>
</table>
<figure>
<img src="images/material_Luminous.jpg" style="width:60.0%" alt="" /><figcaption>Rendering of a yellow Luminous material.</figcaption>
</figure>
<h3 id="texture">Texture</h3>
<p>OSPRay currently implements two texture types (<code>texture2d</code> and <code>volume</code>) and is open for extension to other types by applications. More types may be added in future releases.</p>
<p>To create a new texture use</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb40-1"><a href="#cb40-1"></a>OSPTexture ospNewTexture(<span class="at">const</span> <span class="dt">char</span> *type);</span></code></pre></div>
<h4 id="texture2d">Texture2D</h4>
<p>The <code>texture2d</code> texture type implements an image-based texture, where its parameters are as follows</p>
<table>
<caption>Parameters of <code>texture2d</code> texture type.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">int</td>
<td style="text-align: left;">format</td>
<td style="text-align: left;"><code>OSPTextureFormat</code> for the texture</td>
</tr>
<tr class="even">
<td style="text-align: left;">int</td>
<td style="text-align: left;">filter</td>
<td style="text-align: left;">default <code>OSP_TEXTURE_FILTER_BILINEAR</code>, alternatively <code>OSP_TEXTURE_FILTER_NEAREST</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSPData</td>
<td style="text-align: left;">data</td>
<td style="text-align: left;">the actual texel 2D <a href="#data">data</a></td>
</tr>
</tbody>
</table>
<p>The supported texture formats for <code>texture2d</code> are:</p>
<table>
<caption>Supported texture formats by <code>texture2d</code>, i.e., valid constants of type <code>OSPTextureFormat</code>.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">OSP_TEXTURE_RGBA8</td>
<td style="text-align: left;">8 bit [0–255] linear components red, green, blue, alpha</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_TEXTURE_SRGBA</td>
<td style="text-align: left;">8 bit sRGB gamma encoded color components, and linear alpha</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_TEXTURE_RGBA32F</td>
<td style="text-align: left;">32 bit float components red, green, blue, alpha</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_TEXTURE_RGB8</td>
<td style="text-align: left;">8 bit [0–255] linear components red, green, blue</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_TEXTURE_SRGB</td>
<td style="text-align: left;">8 bit sRGB gamma encoded components red, green, blue</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_TEXTURE_RGB32F</td>
<td style="text-align: left;">32 bit float components red, green, blue</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_TEXTURE_R8</td>
<td style="text-align: left;">8 bit [0–255] linear single component</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_TEXTURE_RA8</td>
<td style="text-align: left;">8 bit [0–255] linear two component</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_TEXTURE_L8</td>
<td style="text-align: left;">8 bit [0–255] gamma encoded luminance</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_TEXTURE_LA8</td>
<td style="text-align: left;">8 bit [0–255] gamma encoded luminance, and linear alpha</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_TEXTURE_R32F</td>
<td style="text-align: left;">32 bit float single component</td>
</tr>
</tbody>
</table>
<p>The size of the texture is inferred from the size of the 2D array <code>data</code>, which also needs have a compatible type to <code>format</code>. The texel data in <code>data</code> starts with the texels in the lower left corner of the texture image, like in OpenGL. Per default a texture fetch is filtered by performing bi-linear interpolation of the nearest 2×2 texels; if instead fetching only the nearest texel is desired (i.e., no filtering) then pass the <code>OSP_TEXTURE_FILTER_NEAREST</code> flag.</p>
<h4 id="texturevolume">TextureVolume</h4>
<p>The <code>volume</code> texture type implements texture lookups based on 3D world coordinates of the surface hit point on the associated geometry. If the given hit point is within the attached volume, the volume is sampled and classified with the transfer function attached to the volume. This implements the ability to visualize volume values (as colored by its transfer function) on arbitrary surfaces inside the volume (as opposed to an isosurface showing a particular value in the volume). Its parameters are as follows</p>
<table>
<caption>Parameters of <code>volume</code> texture type.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">OSPVolume</td>
<td style="text-align: left;">volume</td>
<td style="text-align: left;">volume used to generate color lookups</td>
</tr>
</tbody>
</table>
<p>TextureVolume can be used for implementing slicing of volumes with any geometry type. It enables coloring of the slicing geometry with a different transfer function than that of the sliced volume.</p>
<h3 id="texture2d-transformations">Texture2D Transformations</h3>
<p>All materials with textures also offer to manipulate the placement of these textures with the help of texture transformations. If so, this convention shall be used. The following parameters (prefixed with “<code>texture_name.</code>”) are combined into one transformation matrix:</p>
<table>
<caption>Parameters to define texture coordinate transformations.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">vec4f</td>
<td style="text-align: left;">transform</td>
<td style="text-align: left;">interpreted as 2×2 matrix (linear part), column-major</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">rotation</td>
<td style="text-align: left;">angle in degree, counterclockwise, around center</td>
</tr>
<tr class="odd">
<td style="text-align: left;">vec2f</td>
<td style="text-align: left;">scale</td>
<td style="text-align: left;">enlarge texture, relative to center (0.5, 0.5)</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec2f</td>
<td style="text-align: left;">translation</td>
<td style="text-align: left;">move texture in positive direction (right/up)</td>
</tr>
</tbody>
</table>
<p>The transformations are applied in the given order. Rotation, scale and translation are interpreted “texture centric”, i.e., their effect seen by an user are relative to the texture (although the transformations are applied to the texture coordinates).</p>
<h3 id="cameras">Cameras</h3>
<p>To create a new camera of given type <code>type</code> use</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb41-1"><a href="#cb41-1"></a>OSPCamera ospNewCamera(<span class="at">const</span> <span class="dt">char</span> *type);</span></code></pre></div>
<p>All cameras accept these parameters:</p>
<table>
<caption>Parameters accepted by all cameras.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">position</td>
<td style="text-align: left;">position of the camera in world-space</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">direction</td>
<td style="text-align: left;">main viewing direction of the camera</td>
</tr>
<tr class="odd">
<td style="text-align: left;">vec3f</td>
<td style="text-align: left;">up</td>
<td style="text-align: left;">up direction of the camera</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">nearClip</td>
<td style="text-align: left;">near clipping distance</td>
</tr>
<tr class="odd">
<td style="text-align: left;">vec2f</td>
<td style="text-align: left;">imageStart</td>
<td style="text-align: left;">start of image region (lower left corner)</td>
</tr>
<tr class="even">
<td style="text-align: left;">vec2f</td>
<td style="text-align: left;">imageEnd</td>
<td style="text-align: left;">end of image region (upper right corner)</td>
</tr>
</tbody>
</table>
<p>The camera is placed and oriented in the world with <code>position</code>, <code>direction</code> and <code>up</code>. OSPRay uses a right-handed coordinate system. The region of the camera sensor that is rendered to the image can be specified in normalized screen-space coordinates with <code>imageStart</code> (lower left corner) and <code>imageEnd</code> (upper right corner). This can be used, for example, to crop the image, to achieve asymmetrical view frusta, or to horizontally flip the image to view scenes which are specified in a left-handed coordinate system. Note that values outside the default range of [0–1] are valid, which is useful to easily realize overscan or film gate, or to emulate a shifted sensor.</p>
<h4 id="perspective-camera">Perspective Camera</h4>
<p>The perspective camera implements a simple thin lens camera for perspective rendering, supporting optionally depth of field and stereo rendering, but no motion blur. It is created by passing the type string “<code>perspective</code>” to <code>ospNewCamera</code>. In addition to the <a href="#cameras">general parameters</a> understood by all cameras the perspective camera supports the special parameters listed in the table below.</p>
<table style="width:97%;">
<caption>Parameters accepted by the perspective camera.</caption>
<colgroup>
<col style="width: 10%" />
<col style="width: 32%" />
<col style="width: 53%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">fovy</td>
<td style="text-align: left;">the field of view (angle in degree) of the frame’s height</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">aspect</td>
<td style="text-align: left;">ratio of width by height of the frame (and image region)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">apertureRadius</td>
<td style="text-align: left;">size of the aperture, controls the depth of field</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">focusDistance</td>
<td style="text-align: left;">distance at where the image is sharpest when depth of field is enabled</td>
</tr>
<tr class="odd">
<td style="text-align: left;">bool</td>
<td style="text-align: left;">architectural</td>
<td style="text-align: left;">vertical edges are projected to be parallel</td>
</tr>
<tr class="even">
<td style="text-align: left;">int</td>
<td style="text-align: left;">stereoMode</td>
<td style="text-align: left;">0: no stereo (default), 1: left eye, 2: right eye, 3: side-by-side</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">interpupillaryDistance</td>
<td style="text-align: left;">distance between left and right eye when stereo is enabled</td>
</tr>
</tbody>
</table>
<p>Note that when computing the <code>aspect</code> ratio a potentially set image region (using <code>imageStart</code> &amp; <code>imageEnd</code>) needs to be regarded as well.</p>
<p>In architectural photography it is often desired for aesthetic reasons to display the vertical edges of buildings or walls vertically in the image as well, regardless of how the camera is tilted. Enabling the <code>architectural</code> mode achieves this by internally leveling the camera parallel to the ground (based on the <code>up</code> direction) and then shifting the lens such that the objects in direction <code>dir</code> are centered in the image. If finer control of the lens shift is needed use <code>imageStart</code> &amp; <code>imageEnd</code>. Because the camera is now effectively leveled its image plane and thus the plane of focus is oriented parallel to the front of buildings, the whole façade appears sharp, as can be seen in the example images below.</p>
<figure>
<img src="images/camera_perspective.jpg" style="width:60.0%" alt="" /><figcaption>Example image created with the perspective camera, featuring depth of field.</figcaption>
</figure>
<figure>
<img src="images/camera_architectural.jpg" style="width:60.0%" alt="" /><figcaption>Enabling the <code>architectural</code> flag corrects the perspective projection distortion, resulting in parallel vertical edges.</figcaption>
</figure>
<figure>
<img src="images/camera_stereo.jpg" style="width:90.0%" alt="" /><figcaption>Example 3D stereo image using <code>stereoMode</code> side-by-side.</figcaption>
</figure>
<h4 id="orthographic-camera">Orthographic Camera</h4>
<p>The orthographic camera implements a simple camera with orthographic projection, without support for depth of field or motion blur. It is created by passing the type string “<code>orthographic</code>” to <code>ospNewCamera</code>. In addition to the <a href="#cameras">general parameters</a> understood by all cameras the orthographic camera supports the following special parameters:</p>
<table>
<caption>Parameters accepted by the orthographic camera.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">height</td>
<td style="text-align: left;">size of the camera’s image plane in y, in world coordinates</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">aspect</td>
<td style="text-align: left;">ratio of width by height of the frame</td>
</tr>
</tbody>
</table>
<p>For convenience the size of the camera sensor, and thus the extent of the scene that is captured in the image, can be controlled with the <code>height</code> parameter. The same effect can be achieved with <code>imageStart</code> and <code>imageEnd</code>, and both methods can be combined. In any case, the <code>aspect</code> ratio needs to be set accordingly to get an undistorted image.</p>
<figure>
<img src="images/camera_orthographic.jpg" style="width:60.0%" alt="" /><figcaption>Example image created with the orthographic camera.</figcaption>
</figure>
<h4 id="panoramic-camera">Panoramic Camera</h4>
<p>The panoramic camera implements a simple camera without support for motion blur. It captures the complete surrounding with a latitude / longitude mapping and thus the rendered images should best have a ratio of 2:1. A panoramic camera is created by passing the type string “<code>panoramic</code>” to <code>ospNewCamera</code>. It is placed and oriented in the scene by using the <a href="#cameras">general parameters</a> understood by all cameras.</p>
<figure>
<img src="images/camera_panoramic.jpg" style="width:90.0%" alt="" /><figcaption>Latitude / longitude map created with the panoramic camera.</figcaption>
</figure>
<h3 id="picking">Picking</h3>
<p>To get the world-space position of the geometry (if any) seen at [0–1] normalized screen-space pixel coordinates <code>screenPos</code> use</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb42-1"><a href="#cb42-1"></a><span class="dt">void</span> ospPick(OSPPickResult *,</span>
<span id="cb42-2"><a href="#cb42-2"></a>             OSPFrameBuffer,</span>
<span id="cb42-3"><a href="#cb42-3"></a>             OSPRenderer,</span>
<span id="cb42-4"><a href="#cb42-4"></a>             OSPCamera,</span>
<span id="cb42-5"><a href="#cb42-5"></a>             OSPWorld,</span>
<span id="cb42-6"><a href="#cb42-6"></a>             osp_vec2f screenPos);</span></code></pre></div>
<p>The result is returned in the provided <code>OSPPickResult</code> struct:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb43-1"><a href="#cb43-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> {</span>
<span id="cb43-2"><a href="#cb43-2"></a>    <span class="dt">int</span> hasHit;</span>
<span id="cb43-3"><a href="#cb43-3"></a>    osp_vec3f worldPosition;</span>
<span id="cb43-4"><a href="#cb43-4"></a>    OSPGeometricModel GeometricModel;</span>
<span id="cb43-5"><a href="#cb43-5"></a>    <span class="dt">uint32_t</span> primID;</span>
<span id="cb43-6"><a href="#cb43-6"></a>} OSPPickResult;</span></code></pre></div>
<p>Note that <code>ospPick</code> considers exactly the same camera of the given renderer that is used to render an image, thus matching results can be expected. If the camera supports depth of field then the center of the lens and thus the center of the circle of confusion is used for picking.</p>
<h2 id="framebuffer">Framebuffer</h2>
<p>The framebuffer holds the rendered 2D image (and optionally auxiliary information associated with pixels). To create a new framebuffer object of given size <code>size</code> (in pixels), color format, and channels use</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb44-1"><a href="#cb44-1"></a>OSPFrameBuffer ospNewFrameBuffer(osp_vec2i size,</span>
<span id="cb44-2"><a href="#cb44-2"></a>                                 OSPFrameBufferFormat format = OSP_FB_SRGBA,</span>
<span id="cb44-3"><a href="#cb44-3"></a>                                 <span class="dt">uint32_t</span> frameBufferChannels = OSP_FB_COLOR);</span></code></pre></div>
<p>The parameter <code>format</code> describes the format the color buffer has <em>on the host</em>, and the format that <code>ospMapFrameBuffer</code> will eventually return. Valid values are:</p>
<table>
<caption>Supported color formats of the framebuffer that can be passed to <code>ospNewFrameBuffer</code>, i.e., valid constants of type <code>OSPFrameBufferFormat</code>.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">OSP_FB_NONE</td>
<td style="text-align: left;">framebuffer will not be mapped by the application</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_FB_RGBA8</td>
<td style="text-align: left;">8 bit [0–255] linear component red, green, blue, alpha</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_FB_SRGBA</td>
<td style="text-align: left;">8 bit sRGB gamma encoded color components, and linear alpha</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_FB_RGBA32F</td>
<td style="text-align: left;">32 bit float components red, green, blue, alpha</td>
</tr>
</tbody>
</table>
<p>The parameter <code>frameBufferChannels</code> specifies which channels the framebuffer holds, and can be combined together by bitwise OR from the values of <code>OSPFrameBufferChannel</code> listed in the table below.</p>
<table>
<caption>Framebuffer channels constants (of type <code>OSPFrameBufferChannel</code>), naming optional information the framebuffer can store. These values can be combined by bitwise OR when passed to <code>ospNewFrameBuffer</code>.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">OSP_FB_COLOR</td>
<td style="text-align: left;">RGB color including alpha</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_FB_DEPTH</td>
<td style="text-align: left;">euclidean distance to the camera (<em>not</em> to the image plane), as linear 32 bit float</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_FB_ACCUM</td>
<td style="text-align: left;">accumulation buffer for progressive refinement</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_FB_VARIANCE</td>
<td style="text-align: left;">for estimation of the current noise level if OSP_FB_ACCUM is also present, see <a href="#rendering">rendering</a></td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_FB_NORMAL</td>
<td style="text-align: left;">accumulated world-space normal of the first hit, as vec3f</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_FB_ALBEDO</td>
<td style="text-align: left;">accumulated material albedo (color without illumination) at the first hit, as vec3f</td>
</tr>
</tbody>
</table>
<p>If a certain channel value is <em>not</em> specified, the given buffer channel will not be present. Note that OSPRay makes a clear distinction between the <em>external</em> format of the framebuffer and the internal one: The external format is the format the user specifies in the <code>format</code> parameter; it specifies what color format OSPRay will eventually <em>return</em> the framebuffer to the application (when calling <code>ospMapFrameBuffer</code>): no matter what OSPRay uses internally, it will simply return a 2D array of pixels of that format, with possibly all kinds of reformatting, compression/decompression, etc., going on in-between the generation of the <em>internal</em> framebuffer and the mapping of the externally visible one.</p>
<p>In particular, <code>OSP_FB_NONE</code> is a perfectly valid pixel format for a framebuffer that an application will never map. For example, an application driving a display wall may well generate an intermediate framebuffer and eventually transfer its pixel to the individual displays using an <code>OSPImageOperation</code> <a href="#image-operation">image operation</a>.</p>
<p>The application can map the given channel of a framebuffer – and thus access the stored pixel information – via</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb45-1"><a href="#cb45-1"></a><span class="at">const</span> <span class="dt">void</span> *ospMapFrameBuffer(OSPFrameBuffer,</span>
<span id="cb45-2"><a href="#cb45-2"></a>                              OSPFrameBufferChannel = OSP_FB_COLOR);</span></code></pre></div>
<p>Note that <code>OSP_FB_ACCUM</code> or <code>OSP_FB_VARIANCE</code> cannot be mapped. The origin of the screen coordinate system in OSPRay is the lower left corner (as in OpenGL), thus the first pixel addressed by the returned pointer is the lower left pixel of the image.</p>
<p>A previously mapped channel of a framebuffer can be unmapped by passing the received pointer <code>mapped</code> to</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb46-1"><a href="#cb46-1"></a><span class="dt">void</span> ospUnmapFrameBuffer(<span class="at">const</span> <span class="dt">void</span> *mapped, OSPFrameBuffer);</span></code></pre></div>
<p>The individual channels of a framebuffer can be cleared with</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb47-1"><a href="#cb47-1"></a><span class="dt">void</span> ospResetAccumulation(OSPFrameBuffer);</span></code></pre></div>
<p>This function will clear <em>all</em> accumulating buffers (<code>OSP_FB_VARIANCE</code>, <code>OSP_FB_NORMAL</code>, and <code>OSP_FB_ALBEDO</code>, if present) and resets the accumulation counter <code>accumID</code>. It is unspecified if the existing color and depth buffers are physically cleared when <code>ospResetAccumulation</code> is called.</p>
<p>If <code>OSP_FB_VARIANCE</code> is specified, an estimate of the variance of the last accumulated frame can be queried with</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb48-1"><a href="#cb48-1"></a><span class="dt">float</span> ospGetVariance(OSPFrameBuffer);</span></code></pre></div>
<p>Note this value is only updated after synchronizing with <code>OSP_FRAME_FINISHED</code>, as further described in <a href="#asynchronous-rendering">asynchronous rendering</a>.</p>
<p>The framebuffer takes a list of pixel operations to be applied to the image in sequence as an <code>OSPData</code>. The pixel operations will be run in the order they are in the array.</p>
<table>
<caption>Parameters accepted by the framebuffer.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">OSPImageOperation[]</td>
<td style="text-align: left;">imageOperation</td>
<td style="text-align: left;">ordered sequence of image operations</td>
</tr>
</tbody>
</table>
<h3 id="image-operation">Image Operation</h3>
<p>Image operations are functions that are applied to every pixel of a frame. Examples include post-processing, filtering, blending, tone mapping, or sending tiles to a display wall. To create a new pixel operation of given type <code>type</code> use</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb49-1"><a href="#cb49-1"></a>OSPImageOperation ospNewImageOperation(<span class="at">const</span> <span class="dt">char</span> *type);</span></code></pre></div>
<h4 id="tone-mapper">Tone Mapper</h4>
<p>The tone mapper is a pixel operation which implements a generic filmic tone mapping operator. Using the default parameters it approximates the Academy Color Encoding System (ACES). The tone mapper is created by passing the type string “<code>tonemapper</code>” to <code>ospNewImageOperation</code>. The tone mapping curve can be customized using the parameters listed in the table below.</p>
<table style="width:97%;">
<caption>Parameters accepted by the tone mapper.</caption>
<colgroup>
<col style="width: 10%" />
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 54%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Default</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">exposure</td>
<td style="text-align: left;">1.0</td>
<td style="text-align: left;">amount of light per unit area</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">contrast</td>
<td style="text-align: left;">1.6773</td>
<td style="text-align: left;">contrast (toe of the curve); typically is in [1–2]</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">shoulder</td>
<td style="text-align: left;">0.9714</td>
<td style="text-align: left;">highlight compression (shoulder of the curve); typically is in [0.9–1]</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">midIn</td>
<td style="text-align: left;">0.18</td>
<td style="text-align: left;">mid-level anchor input; default is 18% gray</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">midOut</td>
<td style="text-align: left;">0.18</td>
<td style="text-align: left;">mid-level anchor output; default is 18% gray</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">hdrMax</td>
<td style="text-align: left;">11.0785</td>
<td style="text-align: left;">maximum HDR input that is not clipped</td>
</tr>
<tr class="odd">
<td style="text-align: left;">bool</td>
<td style="text-align: left;">acesColor</td>
<td style="text-align: left;">true</td>
<td style="text-align: left;">apply the ACES color transforms</td>
</tr>
</tbody>
</table>
<p>To use the popular “Uncharted 2” filmic tone mapping curve instead, set the parameters to the values listed in the table below.</p>
<table>
<caption>Filmic tone mapping curve parameters. Note that the curve includes an exposure bias to match 18% middle gray.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Value</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">contrast</td>
<td style="text-align: left;">1.1759</td>
</tr>
<tr class="even">
<td style="text-align: left;">shoulder</td>
<td style="text-align: left;">0.9746</td>
</tr>
<tr class="odd">
<td style="text-align: left;">midIn</td>
<td style="text-align: left;">0.18</td>
</tr>
<tr class="even">
<td style="text-align: left;">midOut</td>
<td style="text-align: left;">0.18</td>
</tr>
<tr class="odd">
<td style="text-align: left;">hdrMax</td>
<td style="text-align: left;">6.3704</td>
</tr>
<tr class="even">
<td style="text-align: left;">acesColor</td>
<td style="text-align: left;">false</td>
</tr>
</tbody>
</table>
<h4 id="denoiser">Denoiser</h4>
<p>OSPRay comes with a module that adds support for Intel® Open Image Denoise. This is provided as an optional module as it creates an additional project dependency at compile time. The module implements a “<code>denoiser</code>” frame operation, which denoises the entire frame before the frame is completed.</p>
<h2 id="rendering">Rendering</h2>
<h3 id="asynchronous-rendering">Asynchronous Rendering</h3>
<p>Rendering is by default asynchronous (non-blocking), and is done by combining a frame buffer, renderer, camera, and world.</p>
<p>What to render and how to render it depends on the renderer’s parameters. If the framebuffer supports accumulation (i.e., it was created with <code>OSP_FB_ACCUM</code>) then successive calls to <code>ospRenderFrame</code> will progressively refine the rendered image. If additionally the framebuffer has an <code>OSP_FB_VARIANCE</code> channel then <code>ospRenderFrame</code> returns an estimate of the current variance of the rendered image, otherwise <code>inf</code> is returned. The estimated variance can be used by the application as a quality indicator and thus to decide whether to stop or to continue progressive rendering.</p>
<p>To start an render task, use</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb50-1"><a href="#cb50-1"></a>OSPFuture ospRenderFrame(OSPFrameBuffer, OSPRenderer, OSPCamera, OSPWorld);</span></code></pre></div>
<p>This returns an <code>OSPFuture</code> handle, which can be used to synchronize with the application, cancel, or query for progress of the running task. When <code>ospRenderFrame</code> is called, there is no guarantee when the associated task will begin execution.</p>
<p>Progress of a running frame can be queried with the following API function</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb51-1"><a href="#cb51-1"></a><span class="dt">float</span> ospGetProgress(OSPFuture);</span></code></pre></div>
<p>This returns the progress of the task in [0-1].</p>
<p>Applications can wait on the result of an asynchronous operation, or choose to only synchronize with a specific event. To synchronize with an <code>OSPFuture</code> use</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb52-1"><a href="#cb52-1"></a><span class="dt">void</span> ospWait(OSPFuture, OSPSyncEvent = OSP_TASK_FINISHED);</span></code></pre></div>
<p>The following are values which can be synchronized with the application</p>
<table style="width:97%;">
<caption>Supported events that can be passed to <code>ospWait</code>.</caption>
<colgroup>
<col style="width: 31%" />
<col style="width: 66%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">OSP_NONE_FINISHED</td>
<td style="text-align: left;">Don’t wait for anything to be finished (immediately return from <code>ospWait</code>)</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_WORLD_COMMITTED</td>
<td style="text-align: left;">Wait for the world to be committed (not yet implemented)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_WORLD_RENDERED</td>
<td style="text-align: left;">Wait for the world to be rendered, but not post-processing operations (Pixel/Tile/Frame Op)</td>
</tr>
<tr class="even">
<td style="text-align: left;">OSP_FRAME_FINISHED</td>
<td style="text-align: left;">Wait for all rendering operations to complete</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OSP_TASK_FINISHED</td>
<td style="text-align: left;">Wait on full completion of the task associated with the future. The underlying task may involve one or more of the above synchronization events</td>
</tr>
</tbody>
</table>
<p>Currently only rendering can be invoked asynchronously. However, future releases of OSPRay may add more asynchronous versions of API calls (and thus return <code>OSPFuture</code>).</p>
<p>Applications can query whether particular events are complete with</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb53-1"><a href="#cb53-1"></a><span class="dt">int</span> ospIsReady(OSPFuture, OSPSyncEvent = OSP_TASK_FINISHED);</span></code></pre></div>
<p>As the given running task runs (as tracked by the <code>OSPFuture</code>), applications can query a boolean [0,1] result if the passed event has been completed.</p>
<h3 id="asynchronously-rendering-and-ospcommit">Asynchronously Rendering and ospCommit()</h3>
<p>The use of either <code>ospRenderFrame</code> or <code>ospRenderFrame</code> requires that all objects in the scene being rendered have been committed before rendering occurs. If a call to <code>ospCommit()</code> happens while a frame is rendered, the result is undefined behavior and should be avoided.</p>
<h3 id="synchronous-rendering">Synchronous Rendering</h3>
<p>For convenience in certain use cases, <code>ospray_util.h</code> provides a synchronous version of <code>ospRenderFrame</code>:</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb54-1"><a href="#cb54-1"></a><span class="dt">float</span> ospRenderFrameBlocking(OSPFrameBuffer, OSPRenderer, OSPCamera, OSPWorld);</span></code></pre></div>
<p>This version is the equivalent of:</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb55-1"><a href="#cb55-1"></a>ospRenderFrame</span>
<span id="cb55-2"><a href="#cb55-2"></a>ospWait(f, OSP_TASK_FINISHED)</span>
<span id="cb55-3"><a href="#cb55-3"></a><span class="cf">return</span> ospGetVariance(fb)</span></code></pre></div>
<p>This version is closest to <code>ospRenderFrame</code> from OSPRay v1.x.</p>
<h2 id="distributed-rendering-with-mpi">Distributed rendering with MPI</h2>
<p>The OSPRay MPI module is now a stand alone repository. It can be found on GitHub <a href="https://github.com/ospray/module_mpi">here</a>, where all code and documentation can be found.</p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>The number of items to be copied is defined by the size of the source array<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>For consecutive memory addresses the x-index of the corresponding voxel changes the quickest.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>actually a parallelogram<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>respectively <span class="math inline">(127, 127, 255)</span> for 8 bit textures<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

      </div>
    </div>

      <div id="footer">
        © 2013–2020 Intel Corporation <a href="legal.html">Disclaimer and Legal Information</a>
        <a href="https://www.intel.com/privacy">Privacy</a>
      </div>
  </body>
</html>
